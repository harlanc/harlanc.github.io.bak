<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HarlanC&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-20T01:49:31.115Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Harlan Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>effective c++ Item 41 理解隐式接口和编译期多态</title>
    <link href="http://yoursite.com/2016/06/01/effecitve_c++_Item41/"/>
    <id>http://yoursite.com/2016/06/01/effecitve_c++_Item41/</id>
    <published>2016-06-01T15:47:44.000Z</published>
    <updated>2017-05-20T01:49:31.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-显示接口和运行时多态"><a href="#1-显示接口和运行时多态" class="headerlink" title="1. 显示接口和运行时多态"></a>1. 显示接口和运行时多态</h1><p>面向对象编程的世界围绕着显式接口和运行时多态。举个例子，考虑下面的类（无意义的类），</p>
<pre><code> 1 class Widget {
 2 public:
 3 Widget();
 4 virtual ~Widget();
 5 
 6 virtual std::size_t size() const;
 7 virtual void normalize();
 8 
 9 void swap(Widget&amp; other);  // see Item 25
10 
11 ... 
12 
13 };
</code></pre><p>考虑下面的函数（同样没有意义），</p>
<pre><code> 1 void doProcessing(Widget&amp; w)
 2 
 3 {
 4 
 5 if (w.size() &gt; 10 &amp;&amp; w != someNastyWidget) {
 6 
 7 Widget temp(w);
 8 
 9 temp.normalize();
10 
11 temp.swap(w);
12 
13 }
14 
15 }
</code></pre><a id="more"></a> 
<p>对于doProcessing中的w，我们可以这样说：</p>
<pre><code>因为w被声明为Widget类型，w必须支持Widget接口。我们可以在源码中搜寻这个接口（例如，在Widget的头文件中），以便能够确切的知道它长成什么样子，所以我将其叫做一个显式的接口（explicit interface）——可以显式的在源码中看到的接口。
因为Widget中的一些成员函数是虚的，w对这些函数的调用会展示出运行时多态：w具体调用哪个函数会根据运行时w的动态类型来决定。
</code></pre><h1 id="2-隐式接口和编译期多态"><a href="#2-隐式接口和编译期多态" class="headerlink" title="2. 隐式接口和编译期多态"></a>2. 隐式接口和编译期多态</h1><p>模板（template）和泛型编程（generic programming）的世界从根本上发生了变化。在这个世界中，显式接口和运行时多态继续存在，但是它们不再像以前那么重要。相反，隐式接口和编译时多态被挪到了前台。为了了解这是什么样子的，我们将doProcessing从函数转换为一个函数模板，看看会发生什么：</p>
<pre><code> 1 template&lt;typename T&gt;
 2 
 3 void doProcessing(T&amp; w)
 4 
 5 {
 6 
 7 if (w.size() &gt; 10 &amp;&amp; w != someNastyWidget) {
 8 
 9 T temp(w);
10 
11 temp.normalize();
12 
13 temp.swap(w);
14 
15 }
16 
17 }
</code></pre><p>现在我们能对doProcessing中的w说些什么呢？</p>
<pre><code>W必须支持的接口由模板中w需要执行的操作所决定。例如，w的类型T必须支持size，normalize和swap成员函数；拷贝构造函数（来创建temp）；和不等比较（同someNastyWidget进行比较）。我们很快就能发现这也不是很精确的，但是对于现在来说足够了。重要的是，这些表达式必须是T所支持的隐式接口，它们对于模板来说必须是有效的以便能够通过编译。
对于涉及到w的像operator&gt;和operator!=这样的函数调用，可能涉及到模板的实例化来让这些调用成功。这些实例化在编译期发生。因为用不同的模板参数实例化出来的函数模板会导致不同的函数被调用，这叫做“编译时多态”。
</code></pre><h1 id="3-显示接口和隐式接口的区别"><a href="#3-显示接口和隐式接口的区别" class="headerlink" title="3. 显示接口和隐式接口的区别"></a>3. 显示接口和隐式接口的区别</h1><h2 id="3-1-显示接口的特点"><a href="#3-1-显示接口的特点" class="headerlink" title="3.1 显示接口的特点"></a>3.1 显示接口的特点</h2><p>即使你永远不使用模板，你也应该熟悉运行时多态和编译期多态的区别，因为这同编译期决定调用哪个重载函数以及运行期决定绑定哪个虚函数是类似的。隐式和显式接口的区别对于模板来说是新的概念，然而，一个显式的接口由函数签名组成，也即是函数名字，参数类型，返回值类型等等。Widget类的公共接口，例如：</p>
<pre><code> class Widget {
 public:
 Widget();
 virtual ~Widget();
 virtual std::size_t size() const; virtual void normalize();
 void swap(Widget&amp; other);
};
</code></pre><p>由一个构造函数，一个析构函数，和函数size，normalize和swap以及参数类型，返回值类型和这些函数的常量性组成。（同样包含编译器生成的拷贝构造函数和拷贝赋值运算符——看Item 5）。它同样可以包含typedef和数据成员，如果你够大胆违反Item22的建议的话（将数据成员声明为private）。虽然在这个例子中没有这么做。</p>
<h2 id="3-2-隐式接口的特点"><a href="#3-2-隐式接口的特点" class="headerlink" title="3.2 隐式接口的特点"></a>3.2 隐式接口的特点</h2><p>一个隐式的接口会有很大的不同。它不是基于函数签名。而是由有效表达式组成。再看一下doProcessing模板开始部分的条件表达式：</p>
<pre><code>1 template&lt;typename T&gt;
2 void doProcessing(T&amp; w)
3 {
4 if (w.size() &gt; 10 &amp;&amp; w != someNastyWidget) {
5 ...
</code></pre><p>T（w的类型）的隐式接口看上去会有如下限制：</p>
<pre><code>它必须提供一个名字为size的成员函数并且返回一个整型值。
它必须支持!=操作符函数，能够对两个T类型的对象进行比较。（这里，我们假设someNastWidget的类型为T。）
</code></pre><p>多亏了操作符重载，上面的两个限制都不需要满足。T必须支持一个size成员函数，值得提及的是这个函数可能继承自一个基类。但是这个成员函数没有必要返回一个整型值。甚至不需要返回一个数字类型值。如果这么说的话，它甚至不需要返回operator&gt;定义中所需要的值。他需要的是返回一个类型X的对象，于是可以在一个类型X对象和int（因为10是int型的）型对象上调用operator&gt;。但是Operator&gt;没有必要带一个类型X的参数，因为它也可以带一个类型Y的参数，只要Y可以隐式的转成X就可以了。</p>
<p>类似的，T也没有必要支持operator!=，因为operator!=带一个类型X的参数和一个类型Y的参数也能接受。只要T能转成X并且someNastyWidget的类型可以转换成Y，那么函数调用就是有效的。</p>
<p>（说句题外话，这个分析没有考虑将operator&amp;&amp;进行重载的可能性，这样就将上面的表达式的意思从一个连接词转换成了其它的意义迥然的东西。）</p>
<p>大多数人当第一次开始考虑这种隐式转换就头疼，你不需要吃阿司匹林。隐式接口只是简单的由一些有效表达式组成。表达式本身看起来复杂，但是加在上面的限制一般来说是简单直接的。例如，考虑下面的条件表达式，</p>
<pre><code>1 if (w.size() &gt; 10 &amp;&amp; w != someNastyWidget) ...
</code></pre><p>很难说要对函数size，operator&gt;,operator&amp;&amp;或者operator!=做什么限制，但是很容易辨认出需要对整个表达式做出的限制。If声明的条件部分必须是一个boolean表达式，所以不管涉及到什么类型，也不管w.size() &gt; 10 &amp;&amp; w != someNastyWidget产生什么，它必须同bool是兼容的。这是模板doProcessing强加在类型参数T上的隐式接口的一部分。剩下的doProcessing所需要的接口就是对拷贝构造函数的调用，还有swap对于类型T来说必须是有效的。</p>
<p>强加在模板参数上的隐式接口同强加在类对象上的显示接口一样真实，两者都是在编译阶段检查。你不能同一个类提供的显示接口相矛盾的方式使用一个类对象（不会编译通过），你也不能随便在一个模板中尝试使用一个对象，除非这个对象支持模板需要的隐式转换（否则也不能通过编译）</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><pre><code>类和模板都支持接口和多态。
对于类来说，接口是显示的，以函数签名为中心。多态发生在运行时，通过虚函数来实现。
对于模板参数来说，接口是隐式的，基于有效表达式。模板多态通过模板实例化和函数重载来实现，它发生在编译期。``
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-显示接口和运行时多态&quot;&gt;&lt;a href=&quot;#1-显示接口和运行时多态&quot; class=&quot;headerlink&quot; title=&quot;1. 显示接口和运行时多态&quot;&gt;&lt;/a&gt;1. 显示接口和运行时多态&lt;/h1&gt;&lt;p&gt;面向对象编程的世界围绕着显式接口和运行时多态。举个例子，考虑下面的类（无意义的类），&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1 class Widget {
 2 public:
 3 Widget();
 4 virtual ~Widget();
 5 
 6 virtual std::size_t size() const;
 7 virtual void normalize();
 8 
 9 void swap(Widget&amp;amp; other);  // see Item 25
10 
11 ... 
12 
13 };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;考虑下面的函数（同样没有意义），&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1 void doProcessing(Widget&amp;amp; w)
 2 
 3 {
 4 
 5 if (w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNastyWidget) {
 6 
 7 Widget temp(w);
 8 
 9 temp.normalize();
10 
11 temp.swap(w);
12 
13 }
14 
15 }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="effective c++" scheme="http://yoursite.com/categories/effective-c/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
