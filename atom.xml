<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HarlanC&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-26T00:42:27.972Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Harlan Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UNIX 文件I/O</title>
    <link href="http://yoursite.com/2017/05/25/APUE-UNIX%E6%96%87%E4%BB%B6IO/"/>
    <id>http://yoursite.com/2017/05/25/APUE-UNIX文件IO/</id>
    <published>2017-05-25T03:44:00.000Z</published>
    <updated>2017-05-26T00:42:27.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://files.cnblogs.com/files/harlanc/%E6%96%87%E4%BB%B6IO.bmp" alt=""></p>
<h2 id="3-1-文件描述符"><a href="#3-1-文件描述符" class="headerlink" title="3.1 文件描述符"></a>3.1 文件描述符</h2><p>对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读，写一个文件时，使用open或者creat返回的文件描述符标识该文件，并将其作为参数传递给read或者write。<br>我们把标准输入(0)，标准输出(1)和标准错误(2)文件描述符替换为符号常量STDIN_FINENO,STDOUT_FILENO,STDERR_FILENO,系统支持的最大文件描述符数量可以由以下方式获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/resource.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">     /*****************************</div><div class="line">     * print file descriptors for</div><div class="line">     * standard input</div><div class="line">     * standard output</div><div class="line">     * standard err</div><div class="line">     * ***************************/</div><div class="line">     printf(&quot;%d\n&quot;,STDIN_FILENO);</div><div class="line">     printf(&quot;%d\n&quot;,STDOUT_FILENO);</div><div class="line">     printf(&quot;%d\n&quot;,STDERR_FILENO);</div><div class="line">     //printf(&quot;%d\n&quot;,OPEN_MAX); OPEN_MAX is deprecated</div><div class="line">     /*************************************</div><div class="line">     * how to get the OPEN_MAX value</div><div class="line">     ************************************/</div><div class="line">     struct rlimit limit;</div><div class="line">     if(getrlimit(RLIMIT_NOFILE,&amp;limit)==-1)</div><div class="line">       perror(&quot;getrlimit&quot;);</div><div class="line">     printf(&quot;getrlimit=%d\n&quot;,(int)limit.rlim_cur);</div><div class="line">     </div><div class="line">     return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="3-2-open和openat"><a href="#3-2-open和openat" class="headerlink" title="3.2 open和openat"></a>3.2 open和openat</h2><p>使用open和openat可以打开或者创建一个文件，下面是使用open和openat的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#define RWRWRW  (S_IRUSR |S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;  </div><div class="line">    /*****************************************************************/</div><div class="line">    //int open(const char*path,int oflag,.../*mode_t mode*/);</div><div class="line">    //int openat(int fd,const char*path,int oflag,.../*mode_t mode*/)</div><div class="line">    /****************************************************************/</div><div class="line">    /*One of the following five flags must be specified:</div><div class="line">    //  O_RDONLY read only</div><div class="line">    //  O_WRONLY write only</div><div class="line">    //  O_RDWR  read and write</div><div class="line">    //   most implementations define O_RDONLY as 0,O_WRONLY as 1,</div><div class="line">    //   O_RDWR as 2.</div><div class="line">    //  O_EXEC execute-only</div><div class="line">    //  O_SEARCH  search-only\</div><div class="line">    ****************************************************************/</div><div class="line">    /*The following ones are optional:</div><div class="line">     *  O_APPEND</div><div class="line">     *  O_CLOEXEC</div><div class="line">     *  O_CREAT</div><div class="line">     *  O_DIRECTORY</div><div class="line">     *  O_EXEL</div><div class="line">     *  O_NOCTTY</div><div class="line">     *  O_NOFOLLOW</div><div class="line">     *  O_NONBLOCK</div><div class="line">     *  O_SYNC</div><div class="line">     *  O_TRUNC</div><div class="line">     *  O_TTY_INIT</div><div class="line">     *  O_DSYNC</div><div class="line">     *  O_RSYNC</div><div class="line">     * */</div><div class="line">     int fd = openat(0,&quot;/tmp/test.txt&quot;,O_WRONLY|O_CREAT,RWRWRW);//0 is ignored if path is absolute path.</div><div class="line">     close(fd);</div><div class="line">     int dir_fd = open(&quot;/tmp&quot;,O_RDONLY);</div><div class="line">     printf(&quot;%d\n&quot;,dir_fd);</div><div class="line">     fd = openat(dir_fd,&quot;test.txt&quot;,O_RDONLY);</div><div class="line">     printf(&quot;%d\n&quot;,fd);</div><div class="line">     </div><div class="line">     fd = open(&quot;/tmp/test.txt&quot;,O_RDWR);</div><div class="line">     printf(&quot;%d\n&quot;,fd);</div><div class="line">     int rv = write(fd,&quot;test&quot;,4);</div><div class="line">     printf(&quot;%d\n&quot;,rv);    </div><div class="line"></div><div class="line">     /*</div><div class="line">      *Test if a file exists</div><div class="line">      */</div><div class="line">     </div><div class="line">     fd = open(&quot;/tmp/test.txt&quot;,O_CREAT|O_EXCL);</div><div class="line">     printf(&quot;The file exists,so the open result is %d\n&quot;,fd);      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>fd参数把open和openat区分开，共有三种可能：</p>
<ul>
<li>path参数指定的是绝对路径名，在这种情况下，fd参数被忽略，openat就相当于open.</li>
<li>path参数指定的是相对路径名，fd参数指出了相对路径名在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取。</li>
<li>path参数指定了相对路径名，fd参数具有特殊值AT_FDCWD。在这种情况下，路径名在当前工作目录中获取，openat函数在操作上和open函数类似。</li>
</ul>
<h2 id="3-3-函数creat"><a href="#3-3-函数creat" class="headerlink" title="3.3 函数creat"></a>3.3 函数creat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#define RWRWRW  (S_IRUSR |S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)</div><div class="line">#define RRR  (S_IRUSR| S_IRGRP|S_IROTH)</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    /********************************************</div><div class="line">     * int creat(const char *path,mode_t mode);</div><div class="line">     * is equal to</div><div class="line">     * open(path,O_WRONLY|OCREAT|O_TRUNC,mode)</div><div class="line">     * *****************************************/</div><div class="line">    int fd = creat(&quot;/tmp/creat.txt&quot;,RRR);//-r--r--r-- 1 harlan harlan 0  5月 18 21:49 creat.txt.</div><div class="line">    printf(&quot;%d\n&quot;,fd);</div><div class="line">    fd = creat(&quot;/tmp/creatRW.txt&quot;,RWRWRW);//umask 0002 -rw-rw-r-- 1 harlan harlan 0  5月 18 21:51 creatRW.txt.</div><div class="line">    printf(&quot;%d\n&quot;,fd);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-函数close"><a href="#3-4-函数close" class="headerlink" title="3.4 函数close"></a>3.4 函数close</h2><p>关闭一个文件是释放该进程加在文件上的所有记录锁。当一个进程终止时，内核自动关闭它所有的打开文件。</p>
<h2 id="3-5-函数lseek"><a href="#3-5-函数lseek" class="headerlink" title="3.5 函数lseek"></a>3.5 函数lseek</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;                                                        </div><div class="line">#include &lt;fcntl.h&gt;                                                        </div><div class="line">int main(void)                                                            </div><div class="line">&#123;                                                                         </div><div class="line">    /*                                                                    </div><div class="line">     *off_t lseek(int fd,off_t offset,int whence);                        </div><div class="line">     * */                                                                 </div><div class="line">    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                </div><div class="line">    int len = lseek(fd,0,SEEK_END);                                       </div><div class="line">    printf(&quot;The file /etc/passwd &apos;s length is %d\n&quot;,len);                 </div><div class="line">    //back to the beginning of the file                                   </div><div class="line">    int zero = lseek(fd,0,SEEK_SET);                                      </div><div class="line">    printf(&quot;The offset of the beginning of the file is %d\n&quot;,zero);       </div><div class="line">    int mid = lseek(fd,len/2,SEEK_CUR);                                   </div><div class="line">    printf(&quot;Move to the middle of the file %d\n&quot;,mid);                    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于lseek函数中参数offset的解释与参数whence的值有关。<br>若whence是SEEK_SET，则将该文件的偏移量设置为距文件开始处offset个字节。<br>若whence是SEEK_CUR,则将该文件的偏移量设置为其当前值加offset，offset可为正或负。<br>若whence是SEEK_END，则将该文件的偏移量设置为文件长度加offset，offset可正可负。</p>
<h2 id="3-6-函数read和write"><a href="#3-6-函数read和write" class="headerlink" title="3.6 函数read和write"></a>3.6 函数read和write</h2><p>如果read成功，则返回读到的字节数。如已达到文件的尾端，则返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#define RRR  (S_IRUSR| S_IRGRP|S_IROTH)</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    /***************************************************</div><div class="line">     * POSIX.1</div><div class="line">     * ssize_t read(int fd,void *buf,size_t nbytes)</div><div class="line">     * ISO_C</div><div class="line">     * int read(int fd,char *buf,unsigned nbytes);</div><div class="line">     **************************************************/</div><div class="line">    int fd = creat(&quot;/tmp/read.txt&quot;,RRR);</div><div class="line">    int byteNumWrite = write(fd,&quot;abcdefg&quot;,7);</div><div class="line">    printf(&quot;The string \&quot;abcdefg\&quot; is write to read.txt,the real string length wrote to the file is %d\n&quot;,</div><div class="line">byteNumWrite);//result is 7</div><div class="line">    close(fd);</div><div class="line">    fd = open(&quot;/tmp/read.txt&quot;,O_RDONLY);</div><div class="line">    char *buf = (char*)malloc(sizeof(char)*8);</div><div class="line">    ssize_t byteNumRead = read(fd,buf,8);</div><div class="line">    printf(&quot;The bytes read from read.txt is %d\n&quot;,(int)byteNumRead);//print result is 7</div><div class="line">    close(fd);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-7-文件共享"><a href="#3-7-文件共享" class="headerlink" title="3.7 文件共享"></a>3.7 文件共享</h2><p>内核使用三种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。</p>
<ul>
<li>每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。于每个文件描述符相关联的是：<ol>
<li>文件描述符标志(close_on_exec);</li>
<li>指向一个文件表项的指针。</li>
</ol>
</li>
<li>内核为所有打开文件维持一张文件表。每个文件表项包含：<ol>
<li>文件状态标志；</li>
<li>当前文件偏移量；</li>
<li>指向该文件V节点表项的指针。</li>
</ol>
</li>
<li>每个打开文件（或设备）都有一个V节点（v-node）结构。</li>
</ul>
<p>见下图：<br><img src="http://files.cnblogs.com/files/harlanc/figure3.7.bmp" alt=""> </p>
<p>如果两个独立进程各自打开了同一文件，则有下面的关系图:<br><img src="http://files.cnblogs.com/files/harlanc/figure3-8.bmp" alt=""></p>
<hr>
<h2 id="3-8-原子操作"><a href="#3-8-原子操作" class="headerlink" title="3.8 原子操作"></a>3.8 原子操作</h2><p>pread是一个原子操作，它用来执行定位并执行I/O,pread相当于调用lseek后调用read,但pread与这种调用顺序有区别。</p>
<ul>
<li>调用pread时，无法中断其定位和读操作。</li>
<li>不更新当前文件偏移量。（见下面的例子）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;                                                               </div><div class="line">#include &lt;fcntl.h&gt;                                                                </div><div class="line">#include &lt;stdio.h&gt;                                                                </div><div class="line">#include &lt;stdlib.h&gt;                                                               </div><div class="line">#define RRR  (S_IRUSR| S_IRGRP|S_IROTH)                                           </div><div class="line">                                                                                  </div><div class="line">off_t getCurOffset(int fd)t                                                       </div><div class="line">&#123;                                                                                 </div><div class="line">    return lseek(fd,0,SEEK_CUR);                                                  </div><div class="line">&#125;                                                                                 </div><div class="line">                                                                                  </div><div class="line">void printCurOffset(int fd)*                                                      </div><div class="line">&#123;                                                                                 </div><div class="line">    printf(&quot;the current file offset is %d\n&quot;,(int)getCurOffset(fd));              </div><div class="line">&#125;                                                                                 </div><div class="line">                                                                                  </div><div class="line">int main(void)                                                                    </div><div class="line">&#123;                                                                                 </div><div class="line">    /*****************************************************************            </div><div class="line">     *ssize_t pread(int fd,void *buf,size_t nbytes,off_t offset);                 </div><div class="line">     *pread will not update the current file offset,see the following examples    </div><div class="line">     *ssize_t pwrite(int fd,const void * buf,size_t nbytes,off_t offset);         </div><div class="line">     *******************************************************************/         </div><div class="line">    int fd = creat(&quot;/tmp/pread.txt&quot;,RRR);                                         </div><div class="line">    int writeBytes = write(fd,&quot;abcdefghij&quot;,10);                                   </div><div class="line">    close(fd);                                                                    </div><div class="line">                                                                                  </div><div class="line">    fd = open(&quot;/tmp/pread.txt&quot;,O_RDONLY);                                         </div><div class="line">    printCurOffset(fd);                                                           </div><div class="line">    char *buf = (char*)malloc(5);                                                 </div><div class="line">    ssize_t readBytes = pread(fd,buf,4,2);                                        </div><div class="line">    buf[4]=&apos;\0&apos;;                                                                  </div><div class="line">    printf(&quot;Read %d bytes:%s\n&quot;,(int)readBytes,buf);                              </div><div class="line">    printCurOffset(fd);                                                           </div><div class="line">    return 0;                                                                     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-9-函数dup和dup2"><a href="#3-9-函数dup和dup2" class="headerlink" title="3.9 函数dup和dup2"></a>3.9 函数dup和dup2</h2><p>dup和dup2都用来复制一个现有的文件描述符。对于dup2，可以自己指定新描述符的值，如果新描述符的值已经打开，则现将其关闭。如果新旧描述符值相等，则直接返回旧描述符值。如果不等，新描述符的FD_CLOEXEC文件描述符标志就会被清除（见下例）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(int argc,char *argv[])</div><div class="line">&#123;</div><div class="line">    if(2!=argc)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;The parameter number is not correct!&quot;);</div><div class="line">    &#125;</div><div class="line">    //get the file descriptor</div><div class="line">    int fd = atoi(argv[1]);</div><div class="line">    char buf[100]=&#123;0&#125;;</div><div class="line">    int NumReadBytes = read(fd,buf,5);</div><div class="line">    printf(&quot;The number of byte %d: %s\n&quot;,NumReadBytes,buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码命名为read.c,执行下面的命令生成read可执行文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc read.c -o read</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">#include &lt;fcntl.h&gt;                                                                  </div><div class="line">#include &lt;unistd.h&gt;                                                                 </div><div class="line">#include &lt;sys/stat.h&gt;                                                               </div><div class="line">#include &lt;stdio.h&gt;                                                                  </div><div class="line">#define RRR  (S_IRUSR| S_IRGRP|S_IROTH)                                             </div><div class="line">#define RWRWRW  (S_IRUSR|S_IWUSR| S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)                  </div><div class="line">                                                                                    </div><div class="line">void printfdInfo(int fd)                                                            </div><div class="line">&#123;                                                                                   </div><div class="line">    printf(&quot;fd num %d\n&quot;,fd);                                                       </div><div class="line">    printf(&quot;get FL of /etc/passwd %d\n&quot;,fcntl(fd,F_GETFL));                         </div><div class="line">    printf(&quot;get FD of /etc/passwd %d\n&quot;,fcntl(fd,F_GETFD));                         </div><div class="line">&#125;                                                                                   </div><div class="line">                                                                                    </div><div class="line">void execRead(int fd)                                                               </div><div class="line">&#123;                                                                                   </div><div class="line">    char fdString[4]=&#123;0&#125;;                                                           </div><div class="line">    sprintf(fdString,&quot;%d&quot;,fd);                                                      </div><div class="line">                                                                                    </div><div class="line">    int pid = 0;                                                                    </div><div class="line">    int status = 0;                                                                 </div><div class="line">                                                                                    </div><div class="line">    if((pid=fork()) != 0)//father process                                           </div><div class="line">    &#123;                                                                               </div><div class="line">        //wait for child process finish                                             </div><div class="line">        waitpid(pid,&amp;status,0);                                                     </div><div class="line">    &#125;                                                                               </div><div class="line">    else//child process                                                             </div><div class="line">    &#123;                                                                               </div><div class="line">        if(execl(&quot;read&quot;,fdString,NULL)&lt;0)//fd is open in child process              </div><div class="line">            perror(&quot;issue read failed.&quot;);                                           </div><div class="line">    &#125;                                                                               </div><div class="line">&#125;                                                                                   </div><div class="line">                                                                                    </div><div class="line">void test_FD_CLOEXEC()                                                              </div><div class="line">&#123;                                                                                   </div><div class="line">    //open success                                                                  </div><div class="line">    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                          </div><div class="line">    printfdInfo(fd);//fd is 0                                                       </div><div class="line">                                                                                    </div><div class="line">    execRead(fd);//read success    </div><div class="line">    fcntl(fd,F_SETFD,FD_CLOEXEC);                                         </div><div class="line">    printfdInfo(fd);//fd is 1,the fd is closed in child process.          </div><div class="line">                                                                          </div><div class="line">    execRead(fd);//read failed                                            </div><div class="line">                                                                          </div><div class="line">    close(fd);                                                            </div><div class="line">&#125;                                                                         </div><div class="line">                                                                          </div><div class="line">void test_dup()                                                           </div><div class="line">&#123;                                                                         </div><div class="line">    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                </div><div class="line">    int dupfd = dup(fd);                                                  </div><div class="line">    //FD and FL are all the same.                                         </div><div class="line">    printfdInfo(fd);                                                      </div><div class="line">    printfdInfo(dupfd);                                                   </div><div class="line">&#125;                                                                         </div><div class="line">void test_dup2()                                                          </div><div class="line">&#123;                                                                         </div><div class="line">    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                </div><div class="line">    fcntl(fd,F_SETFD,FD_CLOEXEC);                                         </div><div class="line">    int newfd = dup2(fd,13);                                              </div><div class="line">    execRead(fd);//read failed,fd is closed.                              </div><div class="line">    execRead(newfd);//the FD_CLOEXEC is cleared.                          </div><div class="line">    close(fd);                                                            </div><div class="line">    close(newfd);                                                         </div><div class="line">&#125;                                                                         </div><div class="line">                                                                          </div><div class="line">int main(void)                                                            </div><div class="line">&#123;                                                                         </div><div class="line">    printf(&quot;test_FD_CLOEXEC.....................\n&quot;);                     </div><div class="line">    test_FD_CLOEXEC();                                                    </div><div class="line">    printf(&quot;test_dup.....................\n&quot;);                            </div><div class="line">    test_dup();                                                           </div><div class="line">    printf(&quot;test_dup2.....................\n&quot;);                           </div><div class="line">    test_dup2();                                                          </div><div class="line">    return 0;                                                             </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-10-函数fcntl"><a href="#3-10-函数fcntl" class="headerlink" title="3.10 函数fcntl"></a>3.10 函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性。fcntl函数有以下5种功能：</p>
<ol>
<li>复制一个已有的文件描述符（cmd=F_DUPFD）</li>
<li>获取/设置文件描述符标志（cmd=F_GETFD或者F_SETFD）</li>
<li>获取/设置文件状态标志（cmd=F_GETFL或者F_SETFL）</li>
<li>获取设置异步i/o所有权（cmd=F_GETOWN或者F_SETOWN）</li>
<li>或者/设置记录锁（cmd=F_GETLK,F_SETLK或F_SETLKW）</li>
</ol>
<p>下面是几个例子：</p>
<pre><code>#include &lt;fcntl.h&gt;                                                               
#include &lt;stdio.h&gt;                                                               
#include &lt;sys/stat.h&gt;                                                            
void printFD(int fd)                                                             
{                                                                                
    printf(&quot;The fd num is %d\n&quot;,fd);                                             
}                                                                                

void printFDFlags(int fd,int fdflags)                                            
{                                                                                
    printf(&quot;The file description flags of  %d is %d\n&quot;,fd,fdflags);              
}                                                                                

void printFLFlags(int fd,int flflags)                                            
{                                                                                
    printf(&quot;The file status flags of  %d is %d\n&quot;,fd,flflags);                   
}                                                                                


void F_DUPFD_fcntl()                                                             
{                                                                                
    printf(&quot;F_DUPFD_fcntl()..........\n&quot;);                                       
    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                       
    int newfd = fcntl(fd,F_DUPFD,0);//equal to dup(fd)                           
    printFD(fd);                                                                 
    printFD(newfd);                                                              
    close(fd);                                                                   
    close(newfd);                                                                
}                                                                                

/*void F_DUPFD_CLOEXEC_fcntl()                                                   
{                                                                                
    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                       
    int newfd = fcntl(fd,F_DUPFD_CLOEXEC,0);                                     
    int fdI = fcntl(fd,F_GETFD,0);                                               
    printFDI(fd,fdI);                                                            
    int newfdI = fcntl(newfd,F_GETFD,0);                                         
    printFDI(newfd,newfdI);                                                      

}*/                                                                              
void F_SET_FD_GET_FD_fcntl()                                                     
{     
    printf(&quot;F_SETFD_GETFD_fcntl()..........\n&quot;);                                   
    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                         
    int fdflag = fcntl(fd,F_GETFD,0);                                              
    printFDFlags(fd,fdflag);                                                       
    fcntl(fd,F_SETFD,1);                                                           
    fdflag = fcntl(fd,F_GETFD,0);                                                  
    printFDFlags(fd,fdflag);                                                       
}                                                                                  
/*********************************************************                         
* note  this command can change only the O_APPEND,                                 
* O_ASYNC, O_DIRECT, O_NOATIME, and O_NONBLOCK flags                               
*******************************************************/                           
#define RWRWRW  (S_IRUSR|S_IWUSR| S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)                 
void F_SETFL_GETFL_fcntl()                                                         
{                                                                                  
    printf(&quot;F_SETFL_GETFL_fcntl()..........\n&quot;);                                   
    int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);                                         
    int flflag = fcntl(fd,F_GETFL);                                                
    printFLFlags(fd,flflag);                                                       
    fcntl(fd,F_SETFL,O_APPEND);                                                    
    flflag = fcntl(fd,F_GETFL);                                                    
    printFLFlags(fd,flflag);                                                       
}                                                                                  
int main(void)                                                                     
{                                                                                  
    /**********************************************/                               
    /* int fcntl(int fd,int cmd,...*//* int arg*///)                               
    /**********************************************/                               
    F_DUPFD_fcntl();                                                               

    //F_DUPFD_CLOEXEC_fcntl();                                                     
    F_SET_FD_GET_FD_fcntl();                                                       
    F_SETFL_GETFL_fcntl();                                                         
    return 0;                                               

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://files.cnblogs.com/files/harlanc/%E6%96%87%E4%BB%B6IO.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-1-文件描述符&quot;&gt;&lt;a href=&quot;#3-1-文件描述符&quot; class=&quot;headerlink&quot; title=&quot;3.1 文件描述符&quot;&gt;&lt;/a&gt;3.1 文件描述符&lt;/h2&gt;&lt;p&gt;对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读，写一个文件时，使用open或者creat返回的文件描述符标识该文件，并将其作为参数传递给read或者write。&lt;br&gt;我们把标准输入(0)，标准输出(1)和标准错误(2)文件描述符替换为符号常量STDIN_FINENO,STDOUT_FILENO,STDERR_FILENO,系统支持的最大文件描述符数量可以由以下方式获取：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;sys/resource.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;errno.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main(void)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     /*****************************&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * print file descriptors for&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * standard input&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * standard output&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * standard err&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * ***************************/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     printf(&amp;quot;%d\n&amp;quot;,STDIN_FILENO);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     printf(&amp;quot;%d\n&amp;quot;,STDOUT_FILENO);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     printf(&amp;quot;%d\n&amp;quot;,STDERR_FILENO);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     //printf(&amp;quot;%d\n&amp;quot;,OPEN_MAX); OPEN_MAX is deprecated&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     /*************************************&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * how to get the OPEN_MAX value&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     ************************************/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     struct rlimit limit;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     if(getrlimit(RLIMIT_NOFILE,&amp;amp;limit)==-1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       perror(&amp;quot;getrlimit&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     printf(&amp;quot;getrlimit=%d\n&amp;quot;,(int)limit.rlim_cur);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux编程" scheme="http://yoursite.com/tags/linux%E7%BC%96%E7%A8%8B/"/>
    
      <category term="APUE" scheme="http://yoursite.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入和单元测试</title>
    <link href="http://yoursite.com/2017/05/19/2017-05-19_07_08_%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2017/05/19/2017-05-19_07_08_依赖注入和单元测试/</id>
    <published>2017-05-18T23:08:00.000Z</published>
    <updated>2017-05-20T12:20:11.443Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://harlancn.me/2017/05/10/2017-05-10_21_13_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9C%89%E6%AF%92/" title="上一篇" target="_blank" rel="external">上一篇</a>博文介绍了测试的相关概念，这篇主要说一下依赖注入以及如何在单元测试中使用。原文链接：<br><a href="http://www.javaranch.com/journal/200709/dependency-injection-unit-testing.html" target="_blank" rel="external">http://www.javaranch.com/journal/200709/dependency-injection-unit-testing.html</a><br>近些年来对于依赖注入（Dependency Injction）这个词大家已经应该很熟悉了。我们经常使用它因为这是一个非常好的面向对象概念。你可能也听说过Spring框架（Spring Framework）,就是所谓的依赖注入容器，在你的印象里面依赖注入和Spring是等同的。但这个想法是错误的，依赖注入是一个很简单的概念，它可以被应用到任何地方，除了依赖注入容器之外，它同样能够被应用到单元测试中。这篇文章我们讨论一下几点：</p>
<ul>
<li>什么是依赖注入</li>
<li>如何实现一个友好的依赖注入类</li>
<li>为什么依赖注入可以使单元测试更加简单</li>
</ul>
<p>Ladies and gentlemen,开动你的引擎！<br><a id="more"></a></p>
<h2 id="1-一辆简单的car"><a href="#1-一辆简单的car" class="headerlink" title="1. 一辆简单的car"></a>1. 一辆简单的car</h2><p><img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170518224926666-1842361008.jpg" alt=""></p>
<p>首先我们考虑一个简单的例子，这里我们使用engine 类和car 类。为了更加清楚的描述问题，我们将类和接口都置空。每辆car会有一个engine，我们想给car装备上著名的MooseEngine。</p>
<p>Engine类如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Engine</span> &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SlowEngine</span> <span class="title">implements</span> <span class="title">Engine</span> &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FastEngine</span> <span class="title">implements</span> <span class="title">Engine</span> &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MooseEngine</span> <span class="title">implements</span> <span class="title">Engine</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以得到一个car类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> &#123;</div><div class="line"><span class="keyword">private</span> MooseEngine engine;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一辆非常棒的汽车，但是即使有其他种类的引擎上市，我们也不能装备这些引擎了。我们说这里的car类和MooseEngine类是紧耦合的（tightly coupled）。虽然MooseEngine很棒，但是如果我们想把它换成别的引擎呢？</p>
<h2 id="2-接口编程"><a href="#2-接口编程" class="headerlink" title="2. 接口编程"></a>2. 接口编程</h2><p> 你可能已经注意到了MooseEngine实现了Engine接口。其它引擎也实现了同样的接口。我们可以想一想，当我们设计我们的Car类时，我们想让一辆“car”装备一个“engine”。所以我们重新实现一个Car类，这次我们使用Engine接口：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> &#123;</div><div class="line"><span class="keyword">private</span> Engine engine;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口编程是依赖注入中的一个很重要的概念。我听到了你的尖叫，“等一下，你在这里使用接口，具现类（<em>concrete class</em>）该怎么办？你在哪里设置（set）引擎？我想在我的汽车中装备MooseEngine”。我们可以按下面的方式来设置它：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> &#123;</div><div class="line"><span class="keyword">private</span> Engine engine = <span class="keyword">new</span> MooseEngine();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但这就是有用的么？它看上去和第一个例子没有多大区别。我们的car仍然同MooseEngine是紧耦合的。那么，我们该如何设置(set或者说注入(inject))我们的汽车引擎呢？</p>
<h2 id="3-依赖注入介绍"><a href="#3-依赖注入介绍" class="headerlink" title="3. 依赖注入介绍"></a>3. 依赖注入介绍</h2><p>就像依赖注入这个名字一样，依赖注入就是注入依赖，或者简单的说，设置不同实例之间的关系。一些人将它同好莱坞的一条规矩关联了起来,“不要给我打掉话，我打给你。”我更喜欢叫它“bugger”法则：“我不关心你是谁，按我说的做。”在我们的第一个例子中，Car依赖的是Engine的具现类MooseEngine。当一个类A依赖于另外一个类B的时候，类Ｂ的实现直接在类Ａ中设置，我们说Ａ紧耦合于B。第二个例子中，我们决定使用接口来代替 具现类MooseEngine，这样就使得Car类更加灵活。并且我们决定不去定义engine的具现类实现。换句话说，我们使Car类变为松耦合(loosely coupled)的了。Car不再依赖于任何引擎的具现类了。那么在哪里指定我们需要使用哪个引擎呢？依赖注入该登场了。我们不在Car类中设置具现化的Engine类，而是从外面注入。这又该如何实现呢？ </p>
<h3 id="3-1-使用构造函数来注入依赖"><a href="#3-1-使用构造函数来注入依赖" class="headerlink" title="3.1 使用构造函数来注入依赖"></a>3.1 使用构造函数来注入依赖</h3><p>设置依赖的一种方法是把依赖类的具体实现传递给构造函数。Car类将会变成下面这个样子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> &#123;</div><div class="line"><span class="keyword">private</span> Engine engine;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params">Engine engine</span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.engine = engine;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们就可以用任何种类的engine来创建Car了。例如，一个car使用MooseEngine，另外一个使用crappy SlowEngine:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">Car myGreatCar = <span class="keyword">new</span> Car(<span class="keyword">new</span> MooseEngine());</div><div class="line">Car hisCrappyCar = <span class="keyword">new</span> Car(<span class="keyword">new</span> SlowEngine());</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-使用setter来注入依赖"><a href="#3-2-使用setter来注入依赖" class="headerlink" title="3.2 使用setter来注入依赖"></a>3.2 使用setter来注入依赖</h3><p>另外一种设置依赖的普通方法就使用setter方法。当需要注入很多依赖的时候，建议使用setter方法而不是构造函数。我们的car类将会被实现成下面的样子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> &#123;</div><div class="line"><span class="keyword">private</span> Engine engine;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span>(<span class="params">Engine engine</span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.engine = engine;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它和基于构造函数的依赖注入非常类似，于是我们可以用下面的方法来实现上面同样的cars：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">Car myGreatCar = <span class="keyword">new</span> Car();</div><div class="line">myGreatCar.setEngine(<span class="keyword">new</span> MooseEngine());</div><div class="line">Car hisCrappyCar = <span class="keyword">new</span> Car();</div><div class="line">hisCrappyCar.setEngine(<span class="keyword">new</span> SlowEngine());</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-在单元测试中使用依赖注入"><a href="#4-在单元测试中使用依赖注入" class="headerlink" title="4. 在单元测试中使用依赖注入"></a>4. 在单元测试中使用依赖注入</h2><p><img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170518225528775-2016525207.jpg" alt=""></p>
<p>如果你将Car类的第一个例子同使用setter依赖注入的例子进行比较，你可能认为后者使用了额外的步骤来实现Car类的依赖注入。这没错，你必须实现一个setter方法。但是当你在做单元测试的时候，你会感觉到这些额外的工作都是值得的。如果你对单元测试不熟悉，推荐你看一下这个帖子<a href="http://www.cnblogs.com/harlanc/p/6838155.html" target="_blank" rel="external">单元测试有毒</a> 。我们的Car的例子太简单了，并没有把依赖注入对单元测试的重要性体现的很好。因此我们不再使用这个例子，我们使用前面已经讲述过的关于篝火故事的例子，特别是在<a href="http://www.cnblogs.com/harlanc/p/6838155.html#_label4" target="_blank" rel="external">在单元测试中使用mock</a>中的部分。我们有一个servlet类，通过使用远端EJB来在农场中”注册”动物：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmServlet</span> <span class="title">extends</span> <span class="title">ActionServlet</span> &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span>(<span class="params"> ServletData servletData </span>) throws Exception </span>&#123;</div><div class="line">String species = servletData.getParameter(<span class="string">"species"</span>);</div><div class="line">String buildingID = servletData.getParameter(<span class="string">"buildingID"</span>);</div><div class="line"><span class="keyword">if</span> ( Str.usable( species ) &amp;&amp; Str.usable( buildingID ) ) &#123;</div><div class="line">FarmEJBRemote remote = FarmEJBUtil.getHome().create();</div><div class="line">                       remote.addAnimal( species , buildingID );</div><div class="line">               &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你已经注意到了FarmServlet被紧耦合到了FarmEJBRemote实例中，通过调用“FarmEJBUtil.getHome().create()”来取回实例值。这么做会非常难做单元测试。当作单元测试的时候，我们不想使用任何数据库。我们也不想访问EJB服务器。因为这不仅会使单元测试很难进行而且会使其变慢。所以为了能够顺利的为FarmServlet类做单元测试，最好使其变成松耦合的。为了清除FarmServlet和FarmEJBRemote之间的紧依赖关系，我们可以使用基于setter的依赖注入：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmServlet</span> <span class="title">extends</span> <span class="title">ActionServlet</span> &#123;</div><div class="line"><span class="keyword">private</span> FarmEJBRemote remote;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemote</span>(<span class="params">FarmEJBRemote remote</span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.remote = remote;</div><div class="line">        &#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span>(<span class="params"> ServletData servletData </span>) throws Exception </span>&#123;</div><div class="line">String species = servletData.getParameter(<span class="string">"species"</span>);</div><div class="line">String buildingID = servletData.getParameter(<span class="string">"buildingID"</span>);</div><div class="line"><span class="keyword">if</span> ( Str.usable( species ) &amp;&amp; Str.usable( buildingID ) ) &#123;</div><div class="line">                       remote.addAnimal( species , buildingID );</div><div class="line">               &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在真实的部署包中，我们确保通过调用“FarmEJBUtil.getHome().create()”而创建的一个FarmServlet远端成员实例会被注入。在我们的单元测试中，我们使用一个虚拟的mock类来模拟FarmEJBRemote。换句话说，我们通过使用mock类来实现FarmEJBRemote:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">MockFarmEJBRemote</span> <span class="title">implements</span> <span class="title">FarmEJBRemote</span> &#123;</div><div class="line"><span class="keyword">private</span> String species = <span class="literal">null</span>;</div><div class="line"><span class="keyword">private</span> String buildingID = <span class="literal">null</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> nbCalls = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimal</span>(<span class="params"> String species , String buildingID </span>)</span></div><div class="line">        &#123;</div><div class="line"><span class="keyword">this</span>.species = species ;</div><div class="line"><span class="keyword">this</span>.buildingID = buildingID ;</div><div class="line"><span class="keyword">this</span>.nbCalls++;</div><div class="line">        &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSpecies</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> species;</div><div class="line">        &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBuildingID</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> buildingID;</div><div class="line">        &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNbCalls</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> nbCalls;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestFarmServlet</span> <span class="title">extends</span> <span class="title">TestCase</span> &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddAnimal</span>(<span class="params"></span>) throws Exception </span>&#123;</div><div class="line"><span class="comment">// Our mock acting like a FarmEJBRemote</span></div><div class="line">MockFarmEJBRemote mockRemote = <span class="keyword">new</span> MockFarmEJBRemote();</div><div class="line"><span class="comment">// Our servlet. We set our mock to its remote dependency</span></div><div class="line">FarmServlet servlet = <span class="keyword">new</span> FarmServlet();</div><div class="line">               servlet.setRemote(mockRemote);</div><div class="line"><span class="comment">// just another mock acting like a ServletData</span></div><div class="line">MockServletData mockServletData = <span class="keyword">new</span> MockServletData(); </div><div class="line">mockServletData.getParameter_returns.put(<span class="string">"species"</span>,<span class="string">"dog"</span>);</div><div class="line">mockServletData.getParameter_returns.put(<span class="string">"buildingID"</span>,<span class="string">"27"</span>);</div><div class="line">               servlet.doAction( mockServletData );</div><div class="line">assertEquals( <span class="number">1</span> , mockRemote.getNbCalls() );</div><div class="line">assertEquals( <span class="string">"dog"</span> , mockRemote.getSpecies() );</div><div class="line">assertEquals( <span class="number">27</span> , mockRemote.getBuildingID() );</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样很容易就能测试FarmServlet了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul>
<li>使用接口而非具现类来表现依赖。</li>
<li>避免在类中隐式的设置（set）一个依赖的<strong>具体实现</strong>。</li>
<li>依赖的具体实现有很多种方法，包括基于构造函数的依赖注入和基于setter的依赖注入</li>
<li>依赖注入使单元测试变的非常灵活。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://harlancn.me/2017/05/10/2017-05-10_21_13_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9C%89%E6%AF%92/&quot; title=&quot;上一篇&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt;博文介绍了测试的相关概念，这篇主要说一下依赖注入以及如何在单元测试中使用。原文链接：&lt;br&gt;&lt;a href=&quot;http://www.javaranch.com/journal/200709/dependency-injection-unit-testing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.javaranch.com/journal/200709/dependency-injection-unit-testing.html&lt;/a&gt;&lt;br&gt;近些年来对于依赖注入（Dependency Injction）这个词大家已经应该很熟悉了。我们经常使用它因为这是一个非常好的面向对象概念。你可能也听说过Spring框架（Spring Framework）,就是所谓的依赖注入容器，在你的印象里面依赖注入和Spring是等同的。但这个想法是错误的，依赖注入是一个很简单的概念，它可以被应用到任何地方，除了依赖注入容器之外，它同样能够被应用到单元测试中。这篇文章我们讨论一下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是依赖注入&lt;/li&gt;
&lt;li&gt;如何实现一个友好的依赖注入类&lt;/li&gt;
&lt;li&gt;为什么依赖注入可以使单元测试更加简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ladies and gentlemen,开动你的引擎！&lt;br&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="单元测试" scheme="http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单元测试有毒</title>
    <link href="http://yoursite.com/2017/05/10/2017-05-10_21_13_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9C%89%E6%AF%92/"/>
    <id>http://yoursite.com/2017/05/10/2017-05-10_21_13_单元测试有毒/</id>
    <published>2017-05-10T13:13:00.000Z</published>
    <updated>2017-05-20T10:40:57.941Z</updated>
    
    <content type="html"><![CDATA[<p>最近想对我们的单元测试做一下总结，楼主在日常工作中写了不少单元测试，但有些概念和用法并没有刨根问题的去追寻，研究。于是把一些不清晰的概念输入到google中来寻找答案，发现了几个不错的帖子，从中学到了东西，也发现了问题，于是忍不住又翻译了一把，和大家分享，如有错误，敬请指正。</p>
<p>我们所做的产品测试包括了下文所说的软件测试词汇表中的大部分，也就是“单元测试”，组件测试，系统测试，集成测试，压力测试和验收测试。开发团队成员做的<br><a id="more"></a><br>者参与的是“单元测试”，集成测试。这里的单元测试我加了引号是因为看完下面的文章，我发现我们所做的单元测试并不是严格意义上的单元测试，叫功能测试比较恰当。下文所说的功能测试遇到的问题在我们的实际项目中也遇到了。希望日后有机会改进。</p>
<p>另外这篇帖子的标题叫做evil unit testing，这里的evil是有害的意思，但是通读这篇博客，并没有讲单元测试是有害的，可能作者的意思是把功能测试当作单元测试的想法是有毒的吧。</p>
<p>好了，原文链接：</p>
<p><a href="http://www.javaranch.com/unit-testing.jsp" target="_blank" rel="external">http://www.javaranch.com/unit-testing.jsp</a></p>
<h2 id="1-你做的是单元测试么？"><a href="#1-你做的是单元测试么？" class="headerlink" title="1. 你做的是单元测试么？"></a>1. 你做的是单元测试么？</h2><p>我看到过至少6个公司因为他们有“单元测试(unit test)”而满脸自豪。而我们看到的是这种“单元测试”结果会是一个麻烦。其他人讨论单元测试有多么伟大，但是它确实变得让人痛苦不堪。这种测试需要45分钟才能跑完，还有你对代码只做了一点改动，但却破坏了7个测试用例”。</p>
<p>这些家伙用的是一堆功能测试（functional test）。他们掉入了一个流行的思维陷阱，认为只要是使用Junit来运行的测试用例，就必须是单元测试。你只需要一点点词汇量，90%的问题就都能解决。</p>
<h2 id="2-软件测试词汇表"><a href="#2-软件测试词汇表" class="headerlink" title="2. 软件测试词汇表"></a>2. 软件测试词汇表</h2><p><img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170510210526113-1292119186.png" alt=""></p>
<ul>
<li><strong>单元测试（unit test**</strong>）**：</li>
</ul>
<p>可测试代码的最小的一部分。通常是一个单一的方法，不会使用其它方法或者类。非常快！上千个单元测试能够在10秒以内跑完！单元测试永远不会使用：</p>
<ol>
<li>数据库</li>
<li>一个app服务器（或者任何类型的服务器）</li>
<li>文件/网络 I/O或者文件系统</li>
<li>另外的应用</li>
<li>控制台（System.out,system.err等等）</li>
<li>日志</li>
<li>大多数其他类（但不包括DTO‘s，String,Integer,mock和一些其他的类）</li>
</ol>
<p>单元测试几乎总是回归测试套件（regression suite）的一部分。</p>
<ul>
<li><strong>回归测试套件（Regression Suite**</strong>）**:</li>
</ul>
<p>能够立刻被运行的测试用例的集合。一个例子就是放在一个特定文件夹中的能够被Junit运行的所有测试用例。一个开发人员能够在一天中把一个<strong>单元测试回归套件</strong>运行20次或者他们可能一个月跑两次<strong>功能测试回归套件</strong>。</p>
<ul>
<li><strong>功能测试（Functional Test**</strong>）**:</li>
</ul>
<p>比一个单元要大，比一个完整的组件测试要小。通常为工作在一起的的几个方法/函数/类。上百的测试用例允许运行几个小时。大部分功能测试是功能测试回归套件的一部分。通常由Junit来运行。</p>
<ul>
<li><strong>集成测试（Integration Test**</strong>）**:</li>
</ul>
<p>测试两个或者更多的组件一起工作的情况。有时候是回归套件的一部分。</p>
<ul>
<li><strong>组件测试（Component Test**</strong>）**:</li>
</ul>
<p>运行一个组件。经常由QA，经理，XP客户等等来执行。这种类别的测试不是回归套件的一部分，它不由Junit来执行。</p>
<ul>
<li><strong>组件验收测试（Component Acceptance Test C.A.T.**</strong>）**:</li>
</ul>
<p>作为正常流程的一部分，它是在众多人面前运行的一个组件测试。由大家共同决定这个组件是不是满足需求标准。</p>
<ul>
<li><strong>系统测试（system Test**</strong>）**：</li>
</ul>
<p>所有的组件在一起运行。</p>
<ul>
<li><strong>系统验收测试（System Acceptance Test S.A.T.**</strong>）**:</li>
</ul>
<p>作为正常流程的一部分，它是在众多人面前运行的一个系统测试，由大家来共同决定这个系统是不是满足需求标准。</p>
<ul>
<li><strong>压力测试（Stress Tests**</strong>）**:</li>
</ul>
<p>另外一个程序加载一个组件，一些组件或者整个系统。我曾经看到过把一些小的压力测试放到回归功能测试中来进行——这是测试并发代码的一个很聪明的做法。</p>
<ul>
<li><strong>Mock</strong>:</li>
</ul>
<p>在单元测试或者功能测试中使用的一些代码，通过使用这些代码来确保你要测试的代码不会去使用其它的产品代码（production code）。一个mock类覆盖了一个产品类中的所有public方法，它们用来插入到尝试使用产品类的地方。有时候一个mock类用来实现一个接口，它替换了用来实现同样接口的产品代码。</p>
<ul>
<li><strong>Shunt</strong>:</li>
</ul>
<p>有点像继承（extends）产品代码的mock类，只是它的意图不是覆盖所有的方法，而只是覆盖足够的代码，所以你能够测试一些产品方法，同时mock剩余的产品方法。如果你想测试一个可能会使用I/O的类它会变得尤为有用，你的shunt能够重写I/O方法同时来测试非I/O方法。</p>
<h2 id="3-使用太多功能测试（functional-test）会有麻烦"><a href="#3-使用太多功能测试（functional-test）会有麻烦" class="headerlink" title="3. 使用太多功能测试（functional test）会有麻烦"></a>3. 使用太多功能测试（functional test）会有麻烦</h2><p>不要误解我的意思。功能测试有很大的价值。我认为一个测试良好的app将会有一个功能测试的回归套件和一个非回归功能测试的集合。通常情况下对于一磅产品代码，我都想看到两磅单元测试代码和两盎司（注：1磅=16盎司）功能测试代码。但是在太多的项目中我看到的现象是没有一丁点单元测试，却有一磅功能测试。</p>
<p>下面的两幅图表明了一些类的使用情况。用一些功能测试来测试这些类一块工作的情况。修复一个类的bug会破坏许多功能测试。。。</p>
<p> <img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170510210548910-246415569.png" alt=""></p>
<p>上面的情况我看到过多次。其中的一个例子是一个很小的改动破坏了47个测试用例。我们通过开会来决定这个bug是不是要被留在代码中。最后决定我们要留足够的时间来fix所有的case。几个月过去了，事情依然糟糕。。</p>
<p>解决方法是使用单元测试来代替功能测试：</p>
<p> <img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170510210558660-16247845.png" alt=""></p>
<p>结果是这个工程变的更加灵活。</p>
<h2 id="4-功能测试认知纠错"><a href="#4-功能测试认知纠错" class="headerlink" title="4. 功能测试认知纠错"></a>4. 功能测试认知纠错</h2><p>“<strong>通过只编写功能测试用例，我可以写更少的测试代码，同时测试更多的功能代码！</strong>”这是真的！但是这会以你的工程变得更加脆弱为代价。另外，如果不使用单元测试，你的应用有些地方很难被测试。同时达到最好的<strong>覆盖率和灵活性</strong>是使用功能测试和单元测试的组合，其中单元测试的比重要大，功能测试的比重要小。</p>
<p>“<strong>我的业务逻辑是让所有的类一块工作，所以只测试一个方法是没有意义的。</strong>”我建议你单独测试所有的方法。同时我也并不建议你不使用功能测试，它们也是有价值的。</p>
<p>“<strong>我不介意我的单元测试组件会花费几分钟来运行</strong>”但是你的团队中的其他人介意么？你的team lead介意么？你的manager呢？如果它花费几分钟而不是几秒钟，你还会在一天的时间把整个测试套件运行多次么？在什么情况下人们根本不会运行测试？</p>
<h2 id="5-单元测试mock基础"><a href="#5-单元测试mock基础" class="headerlink" title="5. 单元测试mock基础"></a>5. 单元测试mock基础</h2><p>下面是单元测试的一个简单例子，测试各种情况却不依赖其他方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLongitude</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44w"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44W"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44 w"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44 W"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44     w"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"-111.44w"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"-111.44W"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"-111.44 w"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"-111.44 W"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"-111.44"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44-"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44 -"</span> ) );</div><div class="line"></div><div class="line">        assertEquals( <span class="string">"-111.44"</span> , Normalize.longitude( <span class="string">"111.44west"</span> ) );</div><div class="line"></div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当然，任何人都能为上面这种情况做单元测试。但是大部分业务逻辑都使用了其它业务逻辑：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmServlet</span> <span class="title">extends</span> <span class="title">ActionServlet</span></div><div class="line">  &#123; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span>(<span class="params"> ServletData servletData </span>) throws Exception</span></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            String species = servletData.getParameter(<span class="string">"species"</span>);</div><div class="line"></div><div class="line">            String buildingID = servletData.getParameter(<span class="string">"buildingID"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ( Str.usable( species ) &amp;&amp; Str.usable( buildingID ) )</div><div class="line"></div><div class="line">            &#123;</div><div class="line"></div><div class="line">                FarmEJBRemote remote = FarmEJBUtil.getHome().create();</div><div class="line"></div><div class="line">                remote.addAnimal( species , buildingID );</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; </div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里不仅仅调用了其他业务逻辑，还调用了应用服务器！可能还会访问网络！上千次的调用可能会花费不少于10秒的时间。另外对EJB的修改可能会破坏我对这个方法的测试！所以我们需要引入一个mock对象。</p>
<p>首先是创建mock。如果FarmEJBRemote是一个类，我将会继承（extend）它并且重写(override)它所有的方法。但是既然它是一个接口，我会编写一个新类并实现（implement）所有方法:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MockRemote</span> <span class="title">implements</span> <span class="title">FarmEJBRemote</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        String addAnimal_species = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        String addAnimal_buildingID = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> addAnimal_calls = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimal</span>(<span class="params"> String species , String buildingID </span>)</span></div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            addAnimal_species = species ;</div><div class="line"></div><div class="line">            addAnimal_buildingID = buildingID ;</div><div class="line"></div><div class="line">            addAnimal_calls++;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个类什么都没做，只是携带了单元测试和需要被测试代码之间要交互的数据。</p>
<p>这个类会让你感觉不舒服么？应该是这样。在我刚接触它的时候有两件事情把我弄糊涂了：类的属性不是private的，并且命名上有下划线。如果你需要mock java.sql.connection。总共有40个方法！ 为每个方法的各个参数，返回值和计数都实现Getters和setters？嗯…稍微想一下…我们把属性声明为private是为了封装，把事情是如何做的封装在内部，于是日后我们就可以修改我们的业务逻辑代码而不用破坏决定要进入我们的内脏的其他代码（也就是要调用我们的业务逻辑的代码）。但这对于mock来说并不适用，不是么？根据定义，mock没有任何业务逻辑。进一步来说，它没有任何东西不是从其他地方拷贝过来的。所有的mock对象都能100%在build阶段生成！..所以虽然有时候我仍然觉的这么实现Mock有一点恶心，但是最后我会重拾自信，这是最好的方法了。只是闻起来会让你有些不舒服，但是效果比使用其它方法好多了。</p>
<p>现在我需要使用mock代码来替代调用应用服务器的部分。我对需要使用mock的地方做了高亮：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmServlet</span> <span class="title">extends</span> <span class="title">ActionServlet</span></div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span>(<span class="params"> ServletData servletData </span>) throws Exception</span></div><div class="line"></div><div class="line">      &#123;</div><div class="line"></div><div class="line">          String species = servletData.getParameter(<span class="string">"species"</span>);</div><div class="line"></div><div class="line">          String buildingID = servletData.getParameter(<span class="string">"buildingID"</span>);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> ( Str.usable( species ) &amp;&amp; Str.usable( buildingID ) )</div><div class="line"></div><div class="line">          &#123;</div><div class="line"></div><div class="line">              FarmEJBRemote remote = FarmEJBUtil.getHome().create();</div><div class="line"></div><div class="line">              remote.addAnimal( species , buildingID );</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 首先，让我们把这句代码从其他猛兽中分离出来：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmServlet</span> <span class="title">extends</span> <span class="title">ActionServlet</span></div><div class="line"></div><div class="line">   &#123;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">private</span> FarmEJBRemote <span class="title">getRemote</span>(<span class="params"></span>)  </span></div><div class="line">       &#123; </div><div class="line">           <span class="keyword">return</span> FarmEJBUtil.getHome().create(); </div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span>(<span class="params"> ServletData servletData </span>) throws Exception</span></div><div class="line"></div><div class="line">       &#123;</div><div class="line"></div><div class="line">           String species = servletData.getParameter(<span class="string">"species"</span>);</div><div class="line"></div><div class="line">           String buildingID = servletData.getParameter(<span class="string">"buildingID"</span>);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> ( Str.usable( species ) &amp;&amp; Str.usable( buildingID ) )</div><div class="line"></div><div class="line">           &#123;</div><div class="line"></div><div class="line">               FarmEJBRemote remote = getRemote();</div><div class="line"></div><div class="line">               remote.addAnimal( species , buildingID );</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这有一点痛..我将会继承我的产品类然后重写getRemote()，于是我可以把mock代码混入到这个操作中了。我需要做一点点改动：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmServlet</span> <span class="title">extends</span> <span class="title">ActionServlet</span></div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">      <span class="function">FarmEJBRemote <span class="title">getRemote</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">      &#123;</div><div class="line"></div><div class="line">          <span class="keyword">return</span> FarmEJBUtil.getHome().create();</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span>(<span class="params"> ServletData servletData </span>) throws Exception</span></div><div class="line"></div><div class="line">      &#123;</div><div class="line"></div><div class="line">          String species = servletData.getParameter(<span class="string">"species"</span>);</div><div class="line"></div><div class="line">          String buildingID = servletData.getParameter(<span class="string">"buildingID"</span>);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> ( Str.usable( species ) &amp;&amp; Str.usable( buildingID ) )</div><div class="line"></div><div class="line">          &#123;</div><div class="line"></div><div class="line">              FarmEJBRemote remote = getRemote();</div><div class="line"></div><div class="line">              remote.addAnimal( species , buildingID );</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 如果你是一个好的面向对象工程师，你现在应该疯了！破坏单元测试代码中的封装性是很不舒服的，但是破坏产品代码封装性的事情就不要做了！长篇大论的解释有可能帮助事态平息，我的观点是：在你的产品代码中，对类的第一次封装要永远保持警惕…但是，有时候，你可能考虑用价值20美元的可测试性来和价值1美元的封装性来做交易。为了让你减轻一点痛苦，你可以加一个注释：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmServlet</span> <span class="title">extends</span> <span class="title">ActionServlet</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="comment">//exposed for unit testing purposes only!</span></div><div class="line"></div><div class="line">        <span class="function">FarmEJBRemote <span class="title">getRemote</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> FarmEJBUtil.getHome().create();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span>(<span class="params"> ServletData servletData </span>) throws Exception</span></div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            String species = servletData.getParameter(<span class="string">"species"</span>);</div><div class="line"></div><div class="line">            String buildingID = servletData.getParameter(<span class="string">"buildingID"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ( Str.usable( species ) &amp;&amp; Str.usable( buildingID ) )</div><div class="line"></div><div class="line">            &#123;</div><div class="line"></div><div class="line">                FarmEJBRemote remote = getRemote();</div><div class="line"></div><div class="line">                remote.addAnimal( species , buildingID );</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> 现在我可以实现一个类来返回mock值了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">FarmServletShunt</span> <span class="title">extends</span> <span class="title">FarmServlet</span></div><div class="line"></div><div class="line">   &#123; </div><div class="line"></div><div class="line">       FarmEJBRemote getRemote_return = <span class="literal">null</span>;</div><div class="line"></div><div class="line">       <span class="function">FarmEJBRemote <span class="title">getRemote</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">       &#123;</div><div class="line"></div><div class="line">           <span class="keyword">return</span> getRemote_return;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 注意一下怪异的名字：“shunt”。我不确定它是什么意思，但我认为这个词语来自电子工程/工艺，它指用一段电线来临时组装一个完整的电路。一开始听起来这个想法很愚蠢，但是过后我就慢慢习惯了。</p>
<p>一个shunt有点像mock，一个没有重写所有方法的mock。用这种方法，你可以mock一些方法，然后测试其他的方法。一个单元测试可以由几个shunts来完成，它们重写了相同的类，每个shunt测试了类的不同部分。Shunt通常情况下为嵌套类。</p>
<p>终场表演的时候到了！看一下单元测试代码！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestFarmServlet</span> <span class="title">extends</span> <span class="title">TestCase</span></div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">FarmServletShunt</span> <span class="title">extends</span> <span class="title">FarmServlet</span></div><div class="line"></div><div class="line">      &#123;</div><div class="line"></div><div class="line">          FarmEJBRemote getRemote_return = <span class="literal">null</span>;</div><div class="line"></div><div class="line">          <span class="function">FarmEJBRemote <span class="title">getRemote</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">          &#123;</div><div class="line"></div><div class="line">              <span class="keyword">return</span> getRemote_return;</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddAnimal</span>(<span class="params"></span>) throws Exception</span></div><div class="line"></div><div class="line">      &#123;</div><div class="line"></div><div class="line">          MockRemote mockRemote = <span class="keyword">new</span> MockRemote();</div><div class="line"></div><div class="line">          FarmServletShunt shunt = <span class="keyword">new</span> FarmServletShunt();</div><div class="line"></div><div class="line">          shunt.getRemote_return = mockRemote();</div><div class="line"></div><div class="line">          <span class="comment">// just another mock to make</span></div><div class="line"></div><div class="line">          MockServletData mockServletData = <span class="keyword">new</span> MockServletData(); </div><div class="line"></div><div class="line">          mockServletData.getParameter_returns.put(<span class="string">"species"</span>,<span class="string">"dog"</span>);</div><div class="line"></div><div class="line">          mockServletData.getParameter_returns.put(<span class="string">"buildingID"</span>,<span class="string">"27"</span>);</div><div class="line"></div><div class="line">          shunt.doAction( mockServletData );</div><div class="line"></div><div class="line">          assertEquals( <span class="number">1</span> , mockRemote.addAnimal_calls );</div><div class="line"></div><div class="line">          assertEquals( <span class="string">"dog"</span> , mockRemote.addAnimal_species );</div><div class="line"></div><div class="line">          assertEquals( <span class="number">27</span> , mockRemote.addAnimal_buildingID );</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>基本的测试框架我们就展示完了。下面我要和大家分享一个和单元测试有关的概念——依赖注入，也是我们的单元测试中要到的，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想对我们的单元测试做一下总结，楼主在日常工作中写了不少单元测试，但有些概念和用法并没有刨根问题的去追寻，研究。于是把一些不清晰的概念输入到google中来寻找答案，发现了几个不错的帖子，从中学到了东西，也发现了问题，于是忍不住又翻译了一把，和大家分享，如有错误，敬请指正。&lt;/p&gt;
&lt;p&gt;我们所做的产品测试包括了下文所说的软件测试词汇表中的大部分，也就是“单元测试”，组件测试，系统测试，集成测试，压力测试和验收测试。开发团队成员做的&lt;br&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="单元测试" scheme="http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>UNIX 系统概述</title>
    <link href="http://yoursite.com/2017/05/07/APUE-UNIX_%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/05/07/APUE-UNIX_系统概述/</id>
    <published>2017-05-07T03:44:00.000Z</published>
    <updated>2017-05-20T10:40:57.905Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170507114106679-1710680497.png" alt=""></p>
<h2 id="1-UNIX体系结构（UNIX-Architecture）"><a href="#1-UNIX体系结构（UNIX-Architecture）" class="headerlink" title="1. UNIX体系结构（UNIX Architecture）"></a>1. UNIX体系结构（UNIX Architecture）</h2><p>调用内核的接口叫做系统调用（system call,图1.1中的阴影部分），普通函数库是建立在系统调用接口的基础之上。应用（application）可以同时使用函数库或者<br><a id="more"></a><br>统调用。Shell是一种特殊的应用，它为运行其他应用提供接口。总的来说，一个操作系统由内核和所有其他的软件组成，这些软件包括系统实用程序，应用，shell,普通的函数库等等。</p>
<p> <img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170507114150226-1366000057.png" alt=""></p>
<h2 id="2-登录（Logging-In）"><a href="#2-登录（Logging-In）" class="headerlink" title="2. 登录（Logging In）"></a>2. 登录（Logging In）</h2><h3 id="2-1-登录名"><a href="#2-1-登录名" class="headerlink" title="2.1 登录名"></a>2.1 登录名</h3><p>系统在password文件中寻找登录名，通常为文件/etc/passwd。每个用户由7部分组成：登录名：加密密码：用户ID：用户组ID：注释字段：home文件夹：shell程序</p>
<p> <img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170507114214414-170354510.png" alt=""></p>
<p>所有现代的系统都将加密密码移到了另外一个文件中。</p>
<h3 id="2-2-Shell"><a href="#2-2-Shell" class="headerlink" title="2.2 Shell"></a>2.2 Shell</h3><p>一个shell是一个命令行解释器，它读取用户输入并执行命令。用户输入通常从终端中读入，有时候也从文件读入（叫做shell脚本）。我们在图1.2中对使用的shell进行总结：</p>
<p> <img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170507114225507-474544823.png" alt=""></p>
<p>具体执行哪个shell由passwd文件中最后一个字段指定。</p>
<h2 id="3-文件和文件夹"><a href="#3-文件和文件夹" class="headerlink" title="3. 文件和文件夹"></a>3. 文件和文件夹</h2><h3 id="3-1-文件系统"><a href="#3-1-文件系统" class="headerlink" title="3.1 文件系统"></a>3.1 文件系统</h3><p>UNIX文件系统是文件和文件夹的一个分层布置。文件夹也是一个文件，它包含了文件夹入口。我们可以将每个文件夹入口想象成一个文件名和描述文件属性的结构体的组合。文件的属性包括<strong>文件类型（文件，文件夹），文件大小，文件拥有者，文件的访问级别（其他用户是不是可以访问这个文件），还有文件的最后修改时间</strong>。我们使用stat和fstat函数来返回包含所有文件属性信息的结构体。</p>
<h3 id="3-2-文件名"><a href="#3-2-文件名" class="headerlink" title="3.2 文件名"></a>3.2 文件名</h3><p>只有两个字符不能出现在文件名中，反斜杠“/”和null字符。因为反斜杠用于分隔路径中的文件名，null字符用于终止路径名。</p>
<h2 id="4-输入和输出"><a href="#4-输入和输出" class="headerlink" title="4. 输入和输出"></a>4. 输入和输出</h2><h3 id="4-1-文件描述符"><a href="#4-1-文件描述符" class="headerlink" title="4.1 文件描述符"></a>4.1 文件描述符</h3><p>文件描述符是一个非负整数，内核用它来标识进程访问的文件。</p>
<h3 id="4-2-标准输入，标准输出，标准错误"><a href="#4-2-标准输入，标准输出，标准错误" class="headerlink" title="4.2 标准输入，标准输出，标准错误"></a>4.2 标准输入，标准输出，标准错误</h3><p>按照惯例，当一个新的程序运行时，所有的shell都会打开三个描述符：标准输入，标准输出和标准错误。如果没有任何特殊操作，这三个描述符都会被连接到终端。大多数shell都提供了将三个描述符重定向到文件的功能。</p>
<h3 id="4-3-无缓冲I-O"><a href="#4-3-无缓冲I-O" class="headerlink" title="4.3 无缓冲I/O"></a>4.3 无缓冲I/O</h3><p>无缓冲I/O由函数open，read,write,lseek和close提供。这些函数同文件描述符一块工作。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include "apue.h"</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">char</span> buf[BUFFSIZE];</div><div class="line"><span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</div><div class="line"><span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</div><div class="line">err_sys(<span class="string">"write error"</span>);</div><div class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">err_sys(<span class="string">"read error"</span>);</div><div class="line">exit(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-4-标准I-O"><a href="#4-4-标准I-O" class="headerlink" title="4.4 标准I/O"></a>4.4 标准I/O</h3><p>标准I/O函数为不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需担心如何选取最佳的缓冲区大小。</p>
<p>我们最熟悉的标准I/O函数是printf。</p>
<p>用标准I/O将标准输入复制到标准输出：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include "apue.h"</span></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> c;</div><div class="line"><span class="keyword">while</span> ((c = getc(stdin)) != EOF)</div><div class="line"><span class="keyword">if</span> (putc(c, stdout) == EOF)</div><div class="line">err_sys(<span class="string">"output error"</span>);</div><div class="line"><span class="keyword">if</span> (ferror(stdin))</div><div class="line">err_sys(<span class="string">"input error"</span>);</div><div class="line">exit(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-程序和进程"><a href="#5-程序和进程" class="headerlink" title="5. 程序和进程"></a>5. 程序和进程</h2><h3 id="5-1-程序"><a href="#5-1-程序" class="headerlink" title="5.1 程序"></a>5.1 程序</h3><p>程序是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数，将程序读入内存，并执行程序。</p>
<h3 id="5-2-进程和进程ID"><a href="#5-2-进程和进程ID" class="headerlink" title="5.2 进程和进程ID"></a>5.2 进程和进程ID</h3><p> 程序的执行实例被成为进程(process)。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID。进程ID为非负整数。</p>
<h3 id="5-3-进程控制"><a href="#5-3-进程控制" class="headerlink" title="5.3 进程控制"></a>5.3 进程控制</h3><p>有三个用于进程控制的主要函数：fork,exec和waitpid(exec有七种变体，但经常把它们统称为exec函数)</p>
<h3 id="5-4-线程和线程ID"><a href="#5-4-线程和线程ID" class="headerlink" title="5.4 线程和线程ID"></a>5.4 线程和线程ID</h3><p>多个控制线程可以使得某些问题解决起来更加容易，并能充分利用多处理器系统的并行行为。</p>
<p>一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性。因为他们要访问同一存储区，因此各线程在访问共享数据时需要采取同步错误以避免不一致性。</p>
<p>线程也用ID标识，一个进程中的线程ID在另外一个进程中没有意义。</p>
<h2 id="6-出错处理"><a href="#6-出错处理" class="headerlink" title="6. 出错处理"></a>6. 出错处理</h2><p>当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值。有些函数对于出错使用另外一种约定而不是返回负值。例如大多数返回对象指针的函数在出错时会返回一个null指针。</p>
<p>Linux支持多线程存取errno：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *_ _errno_location(<span class="keyword">void</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> errno (*_ _errno_location())</span></div></pre></td></tr></table></figure>
<p>对于errno应当注意两条规则。第一条是：如果没有出错，其值不会被例程清除。第二条是：任何函数都不会将errno值设置为0.</p>
<h3 id="6-1-出错恢复"><a href="#6-1-出错恢复" class="headerlink" title="6.1 出错恢复"></a>6.1 出错恢复</h3><p>可将在<errno.h>中定义的各种出错分成两类：致命性的和非致命性的。致命性的错误无法恢复。只能打印日志。对于非致命性的错误，有时可以较为妥善的进行处理。</errno.h></p>
<h2 id="7-用户标识"><a href="#7-用户标识" class="headerlink" title="7. 用户标识"></a>7. 用户标识</h2><h3 id="7-1-用户ID"><a href="#7-1-用户ID" class="headerlink" title="7.1 用户ID"></a>7.1 用户ID</h3><p>口令文件登录项中的用户ID是一个数值，它向系统标识各个不同的用户。</p>
<p>用户ID为0的用户为根用户（root）或超级用户（superuser）。在口令文件中，通常有一个登录项，其登录名为root，我们称这种用户的特权为超级用户特权。超级用户对系统具有自由的支配权。</p>
<h3 id="7-2-组ID"><a href="#7-2-组ID" class="headerlink" title="7.2 组ID"></a>7.2 组ID</h3><p>口令文件登录项也包括用户的组ID，它是一个数值。在口令文件中有多个登录项具有相同的组ID。组被用于将若干用户集合到项目或部门中去。这种机制允许同组的各个成员之间共享资源（如文件）。</p>
<p>组文件通常是/etc/group。</p>
<h2 id="8-信号"><a href="#8-信号" class="headerlink" title="8. 信号"></a>8. 信号</h2><p>信号用于通知进程发生了某种情况。进程有三种处理信号的方式。</p>
<ol>
<li>忽略信号。</li>
<li>按系统默认方式处理。对于除数为0，系统默认方式是终止该进程。</li>
<li>提供一个函数，信号发生时调用该函数，这被称为捕捉该信号。</li>
</ol>
<h2 id="9-时间值"><a href="#9-时间值" class="headerlink" title="9. 时间值"></a>9. 时间值</h2><p>历史上UNIX系统使用过两种不同的时间值。</p>
<ol>
<li>日历时间。这个值是UTC时间（1970年1月1日 00:00:00）这个特定时间以来所经过的描述累计值。系统基本数据类型time_t用来保存这种时间值。</li>
<li>进程时间。也被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以始终滴答计算。系统基本数据类型clock_t保存这种时间值。</li>
</ol>
<p>当度量一个进程的执行时间时，UNIX系统为一个进程维护了三个进程时间值：</p>
<ul>
<li>时钟时间，它是进程运行的时间总量，其值与系统中同时运行的进程数有关。</li>
<li>用户CPU时间；它是执行用户指令所用的时间量。</li>
<li>系统CPU时间。它是该进程执行内核程序所经历的时间。</li>
</ul>
<p>可以用time命令来获取上述三个时间值。</p>
<h2 id="10-系统调用和库函数"><a href="#10-系统调用和库函数" class="headerlink" title="10. 系统调用和库函数"></a>10. 系统调用和库函数</h2><p>所有操作系统都提供多种服务的入口点，由此程序向内核请求服务。各版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称作系统调用。</p>
<p>库函数可能会调用一个或者多个内核的系统调用，但是它们并不是内核的入口点。</p>
<p>应用程序既可以调用库函数也可以调用内核函数。</p>
<p> <img src="http://oq8nryefp.bkt.clouddn.com/blog_830862-20170507114240601-921231859.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/blog_830862-20170507114106679-1710680497.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-UNIX体系结构（UNIX-Architecture）&quot;&gt;&lt;a href=&quot;#1-UNIX体系结构（UNIX-Architecture）&quot; class=&quot;headerlink&quot; title=&quot;1. UNIX体系结构（UNIX Architecture）&quot;&gt;&lt;/a&gt;1. UNIX体系结构（UNIX Architecture）&lt;/h2&gt;&lt;p&gt;调用内核的接口叫做系统调用（system call,图1.1中的阴影部分），普通函数库是建立在系统调用接口的基础之上。应用（application）可以同时使用函数库或者&lt;br&gt;
    
    </summary>
    
    
      <category term="linux编程" scheme="http://yoursite.com/tags/linux%E7%BC%96%E7%A8%8B/"/>
    
      <category term="APUE" scheme="http://yoursite.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>谈一下我们是如何开展code review的</title>
    <link href="http://yoursite.com/2017/04/27/2017-04-27_08_14_%E8%B0%88%E4%B8%80%E4%B8%8B%E6%88%91%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95code_review%E7%9A%84/"/>
    <id>http://yoursite.com/2017/04/27/2017-04-27_08_14_谈一下我们是如何开展code_review的/</id>
    <published>2017-04-27T00:14:00.000Z</published>
    <updated>2017-05-20T12:19:05.345Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，代码审查是软件开发过程中十分重要的环节，楼主结合自己的实际工作经验，和大家分享一下在实际工作中代码审查是如何开展的，笔者水平有限，若有错误和纰漏，还请大家指正。</p>
<h2 id="代码审查的阻力"><a href="#代码审查的阻力" class="headerlink" title="代码审查的阻力"></a>代码审查的阻力</h2><p>我想不通公司不同部门对代码审查这项工作的重视程度还是不一样的，对于代码审查的阻力总结了以下几点：</p>
<ul>
<li>国内的整体环境，国内的公司，尤其是互联网公司，讲究速度致上，软件开发的迭代周期周期短，速度快，因为竞争太大，开发的产品要求快速上线，对代码审查不是很重视，先上线，出了问题再解决。</li>
<li>公司的规模，大公司重视流程，把代码审查作为软件开发中的重要一环，甚至计入考核，不管什么一旦成为制度，开展起来就相对容易了。小公司则不然，尤其是刚起步的，可能觉的代码审查没有必要。</li>
<li>和你的领导有关系，就和上面说的，代码审查如果没有形成制度，如果你的领导是技术出身，明白代码审查的重要性，那么会要求你去做。如果是来自别的领域，可能认识不到它的重要性，觉的代码审查是浪费时间（就和代码重构一个道理）。</li>
<li>个人原因，尤其是刚刚进入公司的员工，大学的软件工程课里面好像是没有介绍代码审查的，就是有，没有实际经验，也体会不到它的重要性，笔者刚入职时就是这么认为的。<a id="more"></a>
<h2 id="代码审查的重要性"><a href="#代码审查的重要性" class="headerlink" title="代码审查的重要性"></a>代码审查的重要性</h2></li>
</ul>
<p>说了代码审查工作的开展遇到的阻力，下面说一下为什么代码审查是重要的。</p>
<ul>
<li>代码审查是保证代码质量的重要手段。软件缺陷可能隐藏在各个地方，测试是发现缺陷的重要方法，但专业的测试人员更多的可能是黑盒测试，他们不去关注代码内部的逻辑，只去关注代码实现的功能，有人说测试代码中的逻辑需要开发人员进行单元测试，一方面，单元测试覆盖率基本上不可能达到100%，另一方面，毕竟是单元测试，测试场景简单，有些复杂的场景有可能会测不到。各种测试完成后，如果还有缺陷，那只能让客户充当我们的“终极测试”了。抱怨会接踵而来，客户满意度会越来越低。所以，我们要想出一切可以使用的方法来进一步提高代码质量的方法，还有代码审查么，测试发现不了的问题，通过代码审查也许你能够发现。</li>
<li>代码审查是熟悉软件架构，了解软件业务逻辑的好方法。学习代码是需要切入点的，一个上百万行代码的系统，从哪里开始着手，只能一个模块一个模块，一个组件一个组件的来熟悉，掌握。实现一个比较大的功能，你应该不会是唯一的开发人员，从系统架构师输出的系统设计，然后到各个团队中技术Lead输出的component级别的设计，到开始实现时，应该会把功能分为不同的模块有不同的开发人员协同实现。这是个学习的机会，不要只局限于自己这部分，为了了解这个大的功能，甚至和这个功能相关的其他已经实现的功能，你同样需要关注其他人的工作。有目的的看代码和漫无目的的浏览效果是不一样的，你已经对新功能有所了解，审查代码之前，你认为代码会怎么写，别人哪里和你想的不一样，旧功能和新功能是如何相互影响的等等，心里怀着问题，你的学习速度会更快，记得更加深刻。</li>
<li>代码审查是你提高自己的好方法。前提是team中有经验丰富的开发人员的存在。也就是大牛，不要错过让他看你代码的机会，不要害怕他会为你写的代码挑出一大堆问题，有人说你自己写的代码就像自己的孩子，见不得别人说半点不字，不要固执，要内心平静的，客观的去看待你所写的代码，发现并解决问题才能提高你自己。也不要错过去review大牛代码的机会，看看大牛写出来的代码是怎样的，你可以取其精华。</li>
<li>代码审查是需要功力的。网上有帖子说程序员的资深与否和工作年限没有必然联系，你是5年工作经验还是一个经验用了5年，这需要你去刻意练习，刚开始reveiew代码的时候你可能不习惯，也可能很痛苦，面对的一屏幕的代码不知如何下眼。但有一句话，如果你觉的内心很舒服，你就是在原地踏步。觉的痛苦说明你是在爬坡，刻意的去联系自己的大脑吧，今天你看一页代码可能用了一个小时，没有发现问题，但是坚持一个月甚至三个月之后，你看一眼就能够发现代码中的缺陷，恭喜你，你的功力加深了。</li>
</ul>
<h2 id="我们是如何开展代码审查的"><a href="#我们是如何开展代码审查的" class="headerlink" title="我们是如何开展代码审查的"></a>我们是如何开展代码审查的</h2><p>好了。罗嗦了半天。下面开始说一下在楼主参与的项目中是如果开展code review的。</p>
<p>第一家公司，是一家国内的大公司，就不说名字了，我所在的部门开发的产品众多，换项目很频繁，我参与的有3,4个吧，开发流程不规范，部门老大没有对代码审查有硬性要求。但带我的老师，也是项目经理（但是主要做技术，所以也可以说是技术经理）是一个非常热衷于技术的人，应该说明白代码review的重要性，我们敏捷团队有4个开发，每次写完代码后，都会进行team review。把代码投到大屏幕上，然后老师带我们去review代码。印象深刻的一次是一个同事着急回家过年，草草把代码就提交走人了，被师傅挑出来很多问题。换了项目和项目经理之后，代码review就不了了之了。</p>
<p>第二家公司，是一个外企，有几十年的历史了，开发流程算是比较规范了，而且分工明确。在这家公司我们的大老板（也就是技术经理的上司）对代码review是有要求的，下面详细说明我们的代码审查是如何一步一步演进的。</p>
<ul>
<li>第一阶段   team review + TFVC</li>
</ul>
<p>先简单介绍下我们的版本控制工具：微软的TFVC，代码的branch是按如下图创建的，有一个main branch每个scrum team一个branch，出release之前把各个team的branch merge回main,最后出release branch，release branch上修复的bug也要最终回main。                                      </p>
<p><img src="http://images2015.cnblogs.com/blog/830862/201704/830862-20170427081119397-1333155289.png" alt=""> </p>
<p>开始的时候我们是没有peer review的，每两周开一次team review。一个主持人，负责预定会议室，操作visual studio查看最近两周提交的changeset，一个记录员，负责记录发现的问题，相关功能的开发人员负责讲解和解答疑问。最后记录员将review结果记录到wiki中并发送到整个开发部门。</p>
<ul>
<li><p>第二阶段 自律TFVC + peer review + team review</p>
<p>记不太清是从哪个visual studio版本开始支持code review了，好像是VS2012。在提交之前每个开发人员需要将代码提交给至少一个人进行review，然后生成一个code review的work item。你需要将这个work item链接到你的changeset中才能check in代码，不然我们公司自定义的policy会发出警告。这些警告是可以被忽略的，然后也能强制提交。前面说过部分老大对code review是很重视的，如何才能检查peer review的结果呢？对，将这些code review的work item数据进行查询，将没有链接work item的changeset过滤出来，然后将结果显示。技术经理和老大一眼就能看到谁没有遵守这个流程。尽管这么做了，开始执行的时候还是有不少的人出现在查询结果中。</p>
</li>
</ul>
<p>说一下自律的问题，公司添加这个查询review结果的措施是手段，只是在某种程度上保证了流程，但目的是什么？目的是需要收到review请求的成员认认真真的review代码，而不是随便的走一下流程就OK。如果你认识到review的重要性，你可能会用心一点吧。</p>
<p>我们的team review 会议依然在进行，和peer review的区别就是peer review只给一个人或者少数的人进行review，而team review 是在整个scrum team间进行。</p>
<ul>
<li>第三阶段 GIT + peer review + team review</li>
</ul>
<p>我们的公司虽然历史悠久，但对一些流程的工具和技术还是极力推崇的。大家都知道GIT是非常流行的版本控制工具，visual studio 2012也开始支持GIT，我们也一步一步的 将source code移到了TFS-GIT中。</p>
<p>和TFVC相比，GIT的branch是非常轻量级的，你可以很容易并且快速的创建一个branch。所以我们现在可以将branch进行细分了。TFVC和GIT的代码提交也不一样，TFVC是集中式的，最全的代码放在server上，你需要一个branch的code时要将其check out到本地。每次提交都是把代码从local一次性merge到server，如果出现conflicts,你需要在本地处理然后check in。GIT是分布式的，每个人clone的时候都会把所有分支download到本地，代码提交是通过pull request来进行的，也就是通过branch之间的merge来进行，这一点刚从TFVC转到GIT的时候很难理解。这样就得为每个人创建一个临时branch，注意这个branch在本地和server端同时存在，我们用这个branch开发自己的代码并用这个branch进行merge code。这里的pull request就相当于TFVC中的code review，TFVC你还可以偷懒忽略code review的work item，在这里就是强制性的了，没有pull request，别人不会approve你的代码，你根本就没有方法将你的代码merge到feature branch中。</p>
<p>还有team review会议也是照常进行的。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，代码审查是软件开发过程中十分重要的环节，楼主结合自己的实际工作经验，和大家分享一下在实际工作中代码审查是如何开展的，笔者水平有限，若有错误和纰漏，还请大家指正。&lt;/p&gt;
&lt;h2 id=&quot;代码审查的阻力&quot;&gt;&lt;a href=&quot;#代码审查的阻力&quot; class=&quot;headerlink&quot; title=&quot;代码审查的阻力&quot;&gt;&lt;/a&gt;代码审查的阻力&lt;/h2&gt;&lt;p&gt;我想不通公司不同部门对代码审查这项工作的重视程度还是不一样的，对于代码审查的阻力总结了以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;国内的整体环境，国内的公司，尤其是互联网公司，讲究速度致上，软件开发的迭代周期周期短，速度快，因为竞争太大，开发的产品要求快速上线，对代码审查不是很重视，先上线，出了问题再解决。&lt;/li&gt;
&lt;li&gt;公司的规模，大公司重视流程，把代码审查作为软件开发中的重要一环，甚至计入考核，不管什么一旦成为制度，开展起来就相对容易了。小公司则不然，尤其是刚起步的，可能觉的代码审查没有必要。&lt;/li&gt;
&lt;li&gt;和你的领导有关系，就和上面说的，代码审查如果没有形成制度，如果你的领导是技术出身，明白代码审查的重要性，那么会要求你去做。如果是来自别的领域，可能认识不到它的重要性，觉的代码审查是浪费时间（就和代码重构一个道理）。&lt;/li&gt;
&lt;li&gt;个人原因，尤其是刚刚进入公司的员工，大学的软件工程课里面好像是没有介绍代码审查的，就是有，没有实际经验，也体会不到它的重要性，笔者刚入职时就是这么认为的。
    
    </summary>
    
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>effective c++ 思维导图</title>
    <link href="http://yoursite.com/2017/04/25/2017-04-25_07_46_effective_c++_%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/04/25/2017-04-25_07_46_effective_c++_思维导图/</id>
    <published>2017-04-24T23:46:00.000Z</published>
    <updated>2017-05-20T10:40:57.790Z</updated>
    
    <content type="html"><![CDATA[<p>历时两个多月的时间，终于把effective c++又复习了一遍，比较慢，看的是英文版，之前看的时候做过一些笔记，但不够详细，这次笔者是从头到尾的翻译了一遍，加了一些标题，先记录到word里面，然后发布到博客园上。这么做是为了方便查阅，复习C++，同时练习英文，希望这些帖子也能够对大家有所帮助。</p>
<p>有人回复说有些过时了，的确，但大部分还都<br><a id="more"></a><br>effective的,可以看scott meyers关于这个问题的的回复:</p>
<p><a href="http://stackoverflow.com/questions/17866735/is-effective-c-still-effective" title="Is effective C++ still effective?" target="_blank" rel="external">is effective c++ still effective?</a></p>
<p>精读一本经典书，每次都有新的发现。</p>
<p>笔者水平有限，肯定有很多错误或者说不明白的地方，希望大家能够指正。</p>
<p>将书的章节以思维导图的形式展示出来能够一目了然，也可以将这些章节联系起来，增加理解，现在有很多思维导图软件，但博客园只能插入图片，不能把链接也放入其中，所以只能用博客园的图表功能画一个“思维导表”出来了。</p>
<table border="0"><br><tbody><br><tr><br><td rowspan="55"><strong>Effective C++</strong></td><br><td rowspan="4"><strong>让你自己适应C++</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6371997.html" target="_blank" rel="external">Item 1 将c++视为一个语言联邦</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6376536.html" target="_blank" rel="external">Item 2 尽量使用const,枚举(enums),内联(inlines),不要使用宏定义(define)</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6384546.html" target="_blank" rel="external">Item 3 在任何可能的时候使用 const</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6389927.html" target="_blank" rel="external">Item 4 确保对象被使用前进行初始化</a></td><br></tr><br><tr><br><td rowspan="8"><strong>构造函数，析构函数和赋值操作符</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6390731.html" target="_blank" rel="external">Item 5 了解c++默认生成并调用的函数</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6392436.html" target="_blank" rel="external">Item 6 如果你不想使用编译器自动生成的函数，你需要明确拒绝</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6395052.html" target="_blank" rel="external">Item 7 在多态基类中将析构函数声明为虚析构函数</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6396072.html" target="_blank" rel="external">Item 8 不要让异常(exceptions)离开析构函数</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6399740.html" target="_blank" rel="external">Item 9 绝不要在构造函数或者析构函数中调用虚函数</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6403918.html" target="_blank" rel="external">Item 10 让赋值运算符返回指向*this的引用</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6403929.html" target="_blank" rel="external">Item 11 在operator=中处理自我赋值</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6408205.html" target="_blank" rel="external">Item 12 拷贝对象的所有部分</a></td><br></tr><br><tr><br><td rowspan="13"><strong>设计和声明</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6412222.html" target="_blank" rel="external">Item 13 用对象来管理资源</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6414789.html" target="_blank" rel="external">Item 14 对资源管理类的拷贝行为要谨慎</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6418038.html" target="_blank" rel="external">Item 15 在资源管理类中提供对原生(raw)资源的访问</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6422351.html" target="_blank" rel="external">Item 16 成对使用new和delete时要用相同的形式</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6427236.html" target="_blank" rel="external">Item 17 使用单独语句将new出来的对象放入智能指针</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6431766.html" target="_blank" rel="external">Item 18 使接口容易被正确使用，不容易被误用</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6436742.html" target="_blank" rel="external">Item 19 像设计类型（type）一样设计类</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6440868.html" target="_blank" rel="external">Item 20 优先使用按const-引用传递（by-reference-to-const）而不是按值传递(by value)</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6445461.html" target="_blank" rel="external">Item 21 当你必须返回一个对象的时候，不要尝试返回引用</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6471815.html" target="_blank" rel="external">Item 22 将数据成员声明成private</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6477213.html" target="_blank" rel="external">Item 23 宁可使用非成员非友元函数函数也不使用成员函数</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6482417.html" target="_blank" rel="external">Item 24 如果函数的所有参数都需要类型转换，将其声明成非成员函数</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6492738.html" target="_blank" rel="external">Item 25 实现一个不抛出异常的swap</a> </td><br></tr><br><tr><br><td rowspan="6"><strong>实现</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6498143.html" target="_blank" rel="external">Item 26 尽量推迟变量的定义</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6500658.html" target="_blank" rel="external">Item 27 尽量少使用转型（casting）</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6512595.html" target="_blank" rel="external">Item 28 不要返回指向对象内部数据(internals)的句柄（handles）</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6516877.html" target="_blank" rel="external">Item 29 为异常安全的代码而努力</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6523201.html" target="_blank" rel="external">Item 30 理解内联的里里外外 (大师入场啦)</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6538258.html" target="_blank" rel="external">Item 31 把文件之间的编译依赖降到最低</a></td><br></tr><br><tr><br><td rowspan="9"><strong>继承和面向对象设计</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6551155.html" target="_blank" rel="external">Item 32 确保public继承建立“is-a”模型</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6556371.html" target="_blank" rel="external">Item 33 避免隐藏继承而来的名字</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6591997.html" target="_blank" rel="external">Item 34 区分接口继承和实现继承</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6607535.html" target="_blank" rel="external">Item 35 考虑虚函数的替代者</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6613194.html" target="_blank" rel="external">Item 36 永远不要重新定义继承而来的非虚函数</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6617834.html" target="_blank" rel="external">Item 37 永远不要重新定义继承而来的函数默认参数值</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6628670.html" target="_blank" rel="external">Item 38 通过组合(composition)为 “has-a”或者“is-implemented-in-terms-of”建模</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6636917.html" target="_blank" rel="external">Item 39 明智而谨慎的使用private继承</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6641852.html" target="_blank" rel="external">Item 40 明智而谨慎的使用多继承</a></td><br></tr><br><tr><br><td rowspan="9"><strong>模板和泛型编程</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6649086.html" target="_blank" rel="external">Item 41 理解隐式接口和编译期多态</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6661228.html" target="_blank" rel="external">Item 42 理解typename的两种涵义</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6665825.html" target="_blank" rel="external">Item 43 了解如何访问模板化基类中的名字</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6680216.html" target="_blank" rel="external">Item 44 将与模板参数无关的代码抽离出来</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6687391.html" target="_blank" rel="external">Item 45 使用成员函数模板来接受“所有兼容类型”</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6691879.html" target="_blank" rel="external">Item 46 如果想进行类型转换，在模板内部定义非成员函数</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6702242.html" target="_blank" rel="external">Item 47 使用traits class表示类型信息</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6714004.html" target="_blank" rel="external">Item 48 了解模板元编程</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6721163.html" target="_blank" rel="external">Item 49 理解new-handler的行为</a></td><br></tr><br><tr><br><td rowspan="3"><strong>定制new和delete</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6731455.html" target="_blank" rel="external">Item 50 了解何时替换new和delete 是有意义的</a> </td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6741713.html" target="_blank" rel="external">Item 51 实现new和delete的时候要遵守约定</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6747528.html" target="_blank" rel="external">Item 52 如果你实现了placement new,你也要实现placement delete</a></td><br></tr><br><tr><br><td rowspan="3"><strong>杂项</strong></td><br><td><a href="http://www.cnblogs.com/harlanc/p/6748759.html" target="_blank" rel="external">Item 53 关注编译器发出的警告</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6753366.html" target="_blank" rel="external">Item 54 让你自己熟悉包括TR1在内的标准库</a></td><br></tr><br><tr><br><td><a href="http://www.cnblogs.com/harlanc/p/6760055.html" target="_blank" rel="external">Item 55 让你自己熟悉Boost</a></td><br></tr><br></tbody><br></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;历时两个多月的时间，终于把effective c++又复习了一遍，比较慢，看的是英文版，之前看的时候做过一些笔记，但不够详细，这次笔者是从头到尾的翻译了一遍，加了一些标题，先记录到word里面，然后发布到博客园上。这么做是为了方便查阅，复习C++，同时练习英文，希望这些帖子也能够对大家有所帮助。&lt;/p&gt;
&lt;p&gt;有人回复说有些过时了，的确，但大部分还都&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 55 让你自己熟悉Boost</title>
    <link href="http://yoursite.com/2017/04/25/2017-04-25_07_43_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_55_%E8%AE%A9%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89Boost/"/>
    <id>http://yoursite.com/2017/04/25/2017-04-25_07_43_读书笔记_effective_c++_Item_55_让你自己熟悉Boost/</id>
    <published>2017-04-24T23:43:00.000Z</published>
    <updated>2017-05-20T10:40:57.704Z</updated>
    
    <content type="html"><![CDATA[<p>你正在寻找一个高质量的，开源的，与平台和编译器无关的程序库的集合？看一下Boost吧。想加入一个由雄心勃勃的，充满天赋的正致力于最高水平的程序库设计和实现工作的C++程序员们组成的团体么？看一下Boost吧。想了解C++将来可能会是什么样子的？看一下Boost吧。</p>
<p>Boost是一个C++开发人员组<br><a id="more"></a><br>的团体，也是供免费下载的C++程序库的集合。网址是<a href="http://boost.org/" target="_blank" rel="external">http://boost.org</a>。</p>
<h2 id="1-Boost的两大优势"><a href="#1-Boost的两大优势" class="headerlink" title="1. Boost的两大优势"></a>1. Boost的两大优势</h2><p>当然，有许多C++组织和网站，但是Boost有两点是其它组织不能与之媲美的。首先，它和C++标注委员会有着紧密的关系，并且对C++标准委员会有影响力。Boost是由C++标准委员会成员创立的，所以Boost和委员会成员之间有很大的重叠。此外，Boost的其中一个目标是为能够加入标准C++的功能提供一个实验场地。这种关系的一个结果就是由TR1引入到C++中的14个新的程序库中，有多于2/3的程序库是基于Boost的工作成果。</p>
<h2 id="2-Boost库的收录流程"><a href="#2-Boost库的收录流程" class="headerlink" title="2. Boost库的收录流程"></a>2. Boost库的收录流程</h2><p>Boost的第二个特殊的特征就是接受程序库的过程。它是在同行评审的基础之上进行的。如果你想向Boost贡献一个程序库，你先向Boost开发人员发送邮件，让他们评估程序库的重要性，然后开始对你工作进行初步的审查。这就开始了一个循环流程，网站将其总结为“讨论，精炼，重发。重复这个流程直到委员会满意为止。”</p>
<p>最后，你决定你的程序库已经准备好正常的提交了。审查经理确认你的程序库满足了Boost的最低需求。例如，必须在至少两个编译器上编译通过（为了确保可移植性），你也必须确保这个程序库在可接受的license下能够被使用（例如，程序库必须允许在商业和非商业的使用中是免费的。）然后Boost委员会就能获得你提交的程序库了，他们会进行官方的审查。在审查期间，志愿者会仔细检查你的程序库材料（例如，源码，设计文档，使用说明文档等等），并且会考虑如下问题：</p>
<ul>
<li>设计和实现有多好？</li>
<li>在不同编译器和操作系统上是可移植的么？</li>
<li>程序库对于受众群体——也就是使用这个程序库处理问题的人们——是否有用？</li>
<li>文档是否清晰，完整，精确？</li>
</ul>
<p>这些注释会发送到Boost邮件列表中，所以审查人员和其他人能够看到，并可以对其它人的评论做出反馈。在审查的最后，审查经理决定你的程序库是否被接受，有条件的接受或者被拒绝。</p>
<p>同行评审可以将实现的不好的程序库排除在外，也同样能够帮助程序库的作者，教他们如何对工业强度的，跨平台的程序库进行设计，实现和撰写文档。许多程序库在被声明其有价值并被接受之前，需要不止一次的官方评审。</p>
<p>Boost包含了大量的程序库，更多的是在大家贡献的基础上进行添加的。一些程序库也会时不时的被移除掉，因为这些功能被更新的程序库取代了，它们提供了更棒的功能或者更好的设计（例如，更加灵活或者更加高效。）</p>
<h2 id="3-Boost库有大有小"><a href="#3-Boost库有大有小" class="headerlink" title="3. Boost库有大有小"></a>3. Boost库有大有小</h2><p>Boost程序库在大小和范围上有很大不同。一个极端是程序库只在概念上需要几行代码（但是如果支持错误处理和增加可移植性会需要更长的代码。）有一个这样的程序库叫做Conversion,它提供了更加安全或者说更加方便的cast操作。例如，它的numeric_cast函数，如果从一个数值类型转换到另外一个数值类型的时候导致内存溢出或者类似的问题，异常就会抛出；lexical_cast使得把支持operator&lt;&lt;的任何类型转换成string成为可能，这对诊断和记录日志是非常有帮助的。另外一个极端是程序库提供了非常广泛的功能，整本书都用来介绍它们。这样的程序库包含Boost Graph Library(支持使用任意的图表结构来进行编程)，还有Boost MPL Library(“元编程库”)。</p>
<h2 id="4-Boost库的分类"><a href="#4-Boost库的分类" class="headerlink" title="4. Boost库的分类"></a>4. Boost库的分类</h2><p>Boost程序库处理了一系列的主题，它们被分成一些种类。这些种类包括：</p>
<ul>
<li>字符串和文本处理，包括类型安全的能够像printf一样进行格式化，正则表达式（这是在TR1中提供的类似的功能的基础）tokenizing和解析。</li>
<li>容器，包括固定大小的数组，它有一个类似STL的接口（见<a href="http://www.cnblogs.com/harlanc/p/6753366.html" title="Item 54" target="_blank" rel="external">Item 54</a>），容量可变的bitset和多维数组。</li>
<li>函数对象和高级编程，包括被当作TR1中功能基础的一些程序库。一个有趣的程序库是Lambda程序库，使得创建函数对象非常简单，你甚至不太可能意识到你在做什么：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">using namespace boost::lambda;       // make boost::lambda</div><div class="line">// functionality visible</div><div class="line"></div><div class="line">std::vector&lt;int&gt; v;</div><div class="line">...</div><div class="line">std::for_each(v.begin(), v.end(),         // for each element x in</div><div class="line"></div><div class="line">std::cout &lt;&lt; _1 * 2 + 10 &lt;&lt; "\n"); // v, print x*2+10;</div><div class="line">// “_1” is the Lambda</div><div class="line">// library’s placeholder</div><div class="line">// for the current element</div></pre></td></tr></table></figure>
<ul>
<li>泛型编程，包含了大量的traits class。（见 <a href="http://www.cnblogs.com/harlanc/p/6702242.html" title="Item 47" target="_blank" rel="external">Item<br>47</a>）</li>
<li>模板元编程（见<a href="http://www.cnblogs.com/harlanc/p/6714004.html" title="Item 48" target="_blank" rel="external">Item 48</a>），包括为编译时断言提供的程序库，还有Boost MPL 程序库。MPL支持编译时实体的像STL一样的数据结构，例如types:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// create a list-like compile-time container of three types (float,</div><div class="line">// double, and long double) and call the container “floats”</div><div class="line">typedef boost::mpl::list&lt;float, double, long double&gt; floats;</div><div class="line">// create a new compile-time list of types consisting of the types in</div><div class="line">// “floats” plus “int” inserted at the front; call the new container “types”</div><div class="line">typedef boost::mpl::push_front&lt;floats, int&gt;::type types;</div></pre></td></tr></table></figure>
<p>这种类型的容器（被人熟知的是typelist，虽然它们也可以基于一个mpl::vector或者mpl::list）为一系列强大和重要的TMP应用打开了大门。</p>
<ul>
<li>数学和数字，包括为有理数提供的库；八元数和四元数；最大公约数和最小公倍数的计算；还有随机数（虽然这是另外一个影响TR1中的相关功能的库。）</li>
<li>正确性和测试，包括为形式化隐式模板接口提供的程序库（<a href="http://www.cnblogs.com/harlanc/p/6649086.html" title="Item 41" target="_blank" rel="external">Item 41</a>）和使测试先行更加容易的程序库。</li>
<li>数据结构，包括为类型安全的union提供的程序库，还有实现了TR1中相对应功能的tuple库。</li>
<li>内存，包括为高性能的固定大小的内存分配器提供的Pool库（见<a href="http://www.cnblogs.com/harlanc/p/6731455.html" title="Item 50" target="_blank" rel="external">Item<br>50</a>）；一些列的智能指针（<a href="http://www.cnblogs.com/harlanc/p/6412222.html" title="Item 13" target="_blank" rel="external">Item<br>13</a>），包括但不限于TR1中的智能指针。一个这样的非TR1智能指针为scoped_array，一个像auto_ptr一样的为动态分配数组提供的智能指针；<a href="http://www.cnblogs.com/harlanc/p/6680216.html" title="Item 44" target="_blank" rel="external">Item<br>44</a>提供了一个实例。</li>
<li>杂项，包括为CRC校验提供的库，日期和时间操作的库，在文件系统上移动的库。</li>
</ul>
<p>记住，这只是Boost中的一部分程序库。并没有把所有的都列出来。</p>
<p>Boost提供的库可以做很多事情，但是不能做所有事情。例如，没有为GUI开发提供的库，也没有同数据库进行通信的库。至少现在没有。但是当你读到这本书的时候可能就有了。了解它们的唯一方式就是核实。我建议你现在就做：<a href="http://boost.org/" target="_blank" rel="external">http://boost.org</a>。即使你没有发现你想要的，你肯定能够发现一些有趣的东西。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul>
<li>Boost是一个社区和网站，它为开发人员提供了免费的，开源的，经过同行评审的C++程序库。Boost对C++标准有影响力。</li>
<li>Boost提供了许多TR1组件的实现，但也提供了许多其它的程序库。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你正在寻找一个高质量的，开源的，与平台和编译器无关的程序库的集合？看一下Boost吧。想加入一个由雄心勃勃的，充满天赋的正致力于最高水平的程序库设计和实现工作的C++程序员们组成的团体么？看一下Boost吧。想了解C++将来可能会是什么样子的？看一下Boost吧。&lt;/p&gt;
&lt;p&gt;Boost是一个C++开发人员组&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 54 让你自己熟悉包括TR1在内的标准库</title>
    <link href="http://yoursite.com/2017/04/23/2017-04-23_18_21_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_54_%E8%AE%A9%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%ACTR1%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>http://yoursite.com/2017/04/23/2017-04-23_18_21_读书笔记_effective_c++_Item_54_让你自己熟悉包括TR1在内的标准库/</id>
    <published>2017-04-23T10:21:00.000Z</published>
    <updated>2017-05-20T10:40:57.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-0x的历史渊源"><a href="#1-C-0x的历史渊源" class="headerlink" title="1. C++0x的历史渊源"></a>1. C++0x的历史渊源</h2><p>C++标准——也就是定义语言的文档和程序库——在1998被批准。在2003年，一个小的“修复bug”版本被发布。然而标准委员会仍然在继续他们的工作，一个“2.0版本”的C++标准预计在2009年被发布（虽然所有的工作很有可能在2007年底被完成）。直到<br><a id="more"></a><br>在，发布下一版C++的预计年份还没有被确定，这就解释了为什么人们把下一版C++叫做“C++0x”——C++的200x年版本。</p>
<p>C++0x可能会包含一些有趣的新的语言特性，但是大多数新C++功能将会以标准库附加物的形式被发布。我们已经知道了一些新的库功能将会是什么，因为它们已经在文档TR1(来自C++库工作组的Technical Report 1)中被指定了。在C++0x被官方正式发布之前，标准委员会保有对TR1的功能进行修改的权利，但是不太可能有大的修改。TR1预示了一个新的C++ release的开始——我们可能将其叫做标准C++ 1.1.如果你不熟悉TR1的功能，你不能被称作一个effective C++程序员，因为TR1中的功能对于各个种类的库和应用来说都是一种福利。</p>
<h2 id="2-C-98标准库中都有什么？"><a href="#2-C-98标准库中都有什么？" class="headerlink" title="2. C++98标准库中都有什么？"></a>2. C++98标准库中都有什么？</h2><p>在考察什么是TR1之前，回顾一下C++98版本标准库中的主要部分是很有价值的：</p>
<ul>
<li><strong>标准模版库（STL）</strong>，包含容器（vector,string,,map等等）；迭代器，算法（find,sort，transform等等）；函数对象（less,greater等等）；还有不同的容器和函数对象适配器（stack,priority_queue,mem_fun,not1等）</li>
<li><strong>Iostreams</strong>,包括对用户自定义buffering的支持，国际化IO，和预定义对象cin,cout,cerr和clog.</li>
<li><strong>支持国际化</strong>，包括多区域的能力(multipue active locales)。像类型wchar_t（通常是16bits/char）和wstring（wchar_t组成的string）能够促进同Unicode一块工作。</li>
<li><strong>支持对数值的处理</strong>，包括复杂数（complex）模板和纯数数组（valarray）。</li>
<li><strong>异常继承体系</strong>，包括基类异常，派生类logic_error和runtime_error，还有继承自这些类的其他类。</li>
<li><strong>C89的标准库</strong>。在1989 C标准库中的所有东西同样被放入了C++。</li>
</ul>
<p>如果你对上面的任何条款不熟悉，我建议你抽出足够的时间来看一些c++参考读物。</p>
<h2 id="3-TR1中都包含什么？"><a href="#3-TR1中都包含什么？" class="headerlink" title="3. TR1中都包含什么？"></a>3. TR1中都包含什么？</h2><p>TR1提出了14个新的组件（也就是程序库功能片段（pieces））。所有都被放入std命名空间中，更精确的说，是在内嵌命名空间tr1中。TR1组件 shared_ptr的全称因此就为std::tr1::shared_ptr。在这本书中，当讨论标准库的组件时，我通常会省略std::，但是我总是会为TR1组件加上前缀tr1::。</p>
<p>本书举例说明TR1中的一些组件：</p>
<ul>
<li><strong>智能指针 tr1::shared_ptr**</strong>和tr1::weak_ptr<strong>。Tr1::shared_ptr的行为表现就像内建指针一样，但是它们追踪了有多少个tr1::shared_ptr指针指向一个对象。这被叫做</strong>引用计数**。当最后的指针被销毁（也就是对象的引用计数变为0的时候），对象自动被delete。这在非环状数据结构中用于防止资源泄漏很好，但如果两个或者多个对象包含tr1::shared_ptr，这样一个环就形成了，这个循环可能相互持有对方对象的引用计数，而且都大于0——即使当所有的环的外部指针被销毁了（也就是当作为一个整体的对象组不能被使用了）。这时候就得使用tr1::weak_ptr，tr1::weak_ptr被设计为在非环状tr1::shared_base数据结构中的cycle-inducing 指针。Tr1::weak_ptr中没有引用计数。当指向对象的最后一个shared_ptr被销毁时，对象就会被delete，即使tr1::weak_ptr仍然指向这个对象。然而这样的指针会被自动被标记为失效。</li>
</ul>
<p>Tr1::shared_ptr可能是TR1中最被广泛使用的对象。我在这本书中也使用了多次，包括在<a href="http://www.cnblogs.com/harlanc/p/6412222.html" title="Item 13" target="_blank" rel="external">Item 13</a>中，在这个条款中我解释了为什么它如此重要。（这本书没有weak_ptr的使用）</p>
<ul>
<li><strong>Tr1::function</strong>，使用它可以表示任意可调用实体（例如，任何函数或者函数对象），只要这些实体的签名同目标签名是一致的。如果我们想使用它来注册一个回调函数，这个函数用int作为参数并且返回值为string。我们可以这么做：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerCallback</span>(<span class="params">std::<span class="keyword">string</span> func(<span class="keyword">int</span></span>))</span>;   <span class="comment">// param type is a function</span></div><div class="line"><span class="comment">// taking an int and</span></div><div class="line"><span class="comment">// returning a string</span></div></pre></td></tr></table></figure>
<p>参数名字 func是可选的，所以registerCallback可以被声明为如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerCallback</span>(<span class="params">std::<span class="keyword">string</span> (<span class="keyword">int</span></span>))</span>;   <span class="comment">// same as above; param</span></div><div class="line"><span class="comment">// name is omitted</span></div></pre></td></tr></table></figure>
<p>注意在这里“std::string(int)”为函数签名。Tr1:;function可以使registerCallback更加灵活，它可以接受任何可调用实体作为它的参数，这个调用实体使用int或者可以转换为Int的任何东西作为参数，返回值可以为一个string或者可以转换为string的任何东西。Tr1::function使用目标函数签名作为模板参数：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerCallback</span>(<span class="params">std::tr1::function&lt;std::<span class="keyword">string</span> (<span class="keyword">int</span></span>)&gt; func)</span>;</div><div class="line"><span class="comment">// the param “func” will</span></div><div class="line"><span class="comment">// take any callable entity</span></div><div class="line"><span class="comment">// with a sig consistent</span></div><div class="line"><span class="comment">// with “std::string (int)”</span></div></pre></td></tr></table></figure>
<p>这种灵活性非常有用，我已经在<a href="http://www.cnblogs.com/harlanc/p/6607535.html" title="Item 35" target="_blank" rel="external">Item 35</a>中展示过了。</p>
<ul>
<li><strong>Tr1::bind</strong>,它能做STL绑定器bind1st和bind2nd能做的所有事情，甚至更多。不像pre-TR1中的binders，tr1::bind可以工作在const和非const成员函数中；可以使用按引用传递的参数；可以在没有其他函数帮助的情况下处理函数指针，所以在调用tr1::bind之前就没有必要同ptr_fun,mem_fun或者mem_fun_ref掺杂在一起了。简单说，tr1::bind是第二代绑定工具，它要远远好于第一代。我已经在Item 35中进行了举例。</li>
</ul>
<p>我将剩下的TR1组件分成两部分。第一部分提供了相当独立的功能：</p>
<ul>
<li><strong>Hash table</strong> 被用来实现set，multiset，map和multimap。每个新的容器都将模拟与pre-TR1相对应部分的接口。对于TR1中的hash table，最让人感到意外的是它们的名字：tr1::unordered_set,tr1::unordered_multiset，tr1::unordered_map和tr1::unordered_multimap。这些名字强调了它的内容不会像set，multiset或者multimap一样，TR1中hash-based的容器中的元素顺序是无序的。</li>
<li><strong>正则表达式</strong>，包括在字符串上进行的基于正则表达式的搜索和替换功能，还有从一个匹配字符串到另一个匹配字符串的迭代等等。</li>
<li><strong>Tuple</strong>,它是对已经在标准库中存在的pair模板的泛化。相比于Pair对象会持有两个对象，tr1::tuple对象能够持有任意数量的对象。</li>
<li><strong>Tr1::array</strong>,本质上来说是一个“STL化的“数组，也就是一个支持像begin和end这样的成员函数的数组。Tr1::array的大小在编译期被固定；对象不使用动态内存。</li>
<li><strong>Tr1::mem_fn</strong>，为成员函数指针进行适配的在句法上的一个统一的方式。就像tr1::bind把C++98的bind1st和bind2nd的功能包含进来并对其进行扩展，tr1::mem_fn把C++98中的mem_fun和mem_fun_ref的功能包含进来并对其进行了扩展。</li>
<li><strong>Tr1::reference_wrapper</strong>，这是一个功能使得引用的行为表现就像对象一样。这使得创建一个行为表现就如同持有引用的容器成为可能（事实上，容器只能包含对象或者指针。）</li>
<li><strong>随机数生成器</strong>（Random number generation）功能要比从C标准库中继承而来的随机函数更加优秀。</li>
<li><strong>数学特殊函数</strong>（Mathematical special function），包括拉盖尔多项式，贝塞尔函数，完全椭圆积分（complete elliptic integrals）等等。</li>
<li><strong>C99兼容性扩展</strong>，为了将许多新的C99程序库的功能引入到C++中而设计的函数集合与模板。</li>
</ul>
<p>TR1组件的第二个集合由<strong>为更加复杂的模板编程技术</strong>提供的支撑技术所组成，包括模板元编程（<a href="http://www.cnblogs.com/harlanc/p/6714004.html" title="Item 48" target="_blank" rel="external">Item 48</a>）:</p>
<ul>
<li><strong>类型特性</strong>（Type traits）,提供了一系列trait类（见<a href="http://www.cnblogs.com/harlanc/p/6702242.html" title="Item 47" target="_blank" rel="external">Item 47</a>）来为类型提供编译时信息。给定一个类型T，TR1的类型特性能够揭示T是否是一个内建类型，能否提供虚析构函数，是否是一个empty class(<a href="http://www.cnblogs.com/harlanc/p/6636917.html" title="Item 39" target="_blank" rel="external">Item 39</a>),是否可以隐式的转换为其它类型U，等等。TR1中的type traits同样也能够为一个类型揭示合适的对齐问题（alignment），这就为实现自定义内存分配函数的程序员提供了重要信息（<a href="http://www.cnblogs.com/harlanc/p/6731455.html" title="Item 50" target="_blank" rel="external">Item 50</a>）。</li>
<li><strong>Tr1::result_of</strong>,一个用来推导函数返回类型的模板。当实现模板的时候，能够引用从函数（模板）调用中返回回来的对象类型很重要，但是返回类型可以以复杂的方式来依赖函数的参数。在TR1中很多地方都使用到了Tr1::result_of。</li>
</ul>
<p>虽然TR1中的一些功能（尤其是tr1::bind和tr1::mem_fn）只是将pre-TR1的一些组件纳入其中，但TR1只是标准库的额外添加物。没有TR1组件是对现存组件的替换，所以使用pre-TR1构建的遗留代码仍然有效。</p>
<h2 id="4-从哪里找到TR1实现"><a href="#4-从哪里找到TR1实现" class="headerlink" title="4. 从哪里找到TR1实现"></a>4. 从哪里找到TR1实现</h2><p>TR1本身只是一个文档。为了使用它指定的功能，你需要访问实现这些功能的代码。这些代码最后将会同编译器捆绑在一块发布，但是我写这本书是在2005年，如果在你的标准库实现中寻找TR1组件，可能会有一些遗漏。幸运的是，可以从其他地方进行搜寻：TR1 的14个组件中的10个是基于可以免费获得的Boost库（见Item 55）来实现的，所以如果你想了解和TR1类似（TR1-like）的功能，这会是一个很好的资源。这里我说“TR1-like”，因为虽然很多TR1功能是基于Boost库的，有一些地方Boost功能还没有同TR1规格完全匹配。很有可能但你读到这本书的时候，不仅对于从Boost 库进化而来的TR1组件，Boost中有了与其一致的实现，而且它同时提供了没有基于Boost的其余4个TR1组件的实现。</p>
<p>如果作为权宜之计你想使用Boost中的类似TR1的库，直到编译器同TR1实现一同被发布，你可能会使用一个命名空间的技俩。所有的Boost组件是在命名空间boost中，但是TR1组件将会在命名空间std::tr1中。你可以告诉编译器，把对std::tr1的引用当作对boost的引用来处理。像下面这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">namespace std &#123;</div><div class="line">namespace tr1 = ::boost; // namespace std::tr1 is an alias</div><div class="line">&#125; // for namespace boost</div></pre></td></tr></table></figure>
<p>从技术上来说，这会让你进入未定义行为的领域，因为正如在<a href="http://www.cnblogs.com/harlanc/p/6492738.html" title="Item 25" target="_blank" rel="external">Item 25</a>中解释的，不允许向std命名空间中添加任何东西。在实际情况下，看上去你不会遇到任何麻烦。当你的编译器提供了它们自己的TR1实现的时候，所有你需要做的就是移除上面的命名空间别名；引用std::tr1的代码仍然是有效的。</p>
<p>可能没有基于Boost库实现的TR1中的最重要的部分就是hash table了，但是hash  tables已经存在很多年了，它们以hash_set,hash_multiset,hasp_map和hash_multimap命名。有可能你的编译器自带的库中已经包含这些模板了。如果没有，使用你最喜欢的搜索引擎去搜一下这些名字，因为你肯定能够找到一些源代码，无论是商业的还是免费的。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul>
<li>主要的标准C++库的功能包括STL，iostream和locales。C89标准库也被包含在内。</li>
<li>TR1中添加了对智能指针的支持，广义的函数指针（tr1::function），hash-based 容器，正则表达式和10个其他的组件。</li>
<li>TR1本身只是一个说明书。为了使用TR1，你需要一份实现。TR1组件实现的一份源码来自于Boost.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-C-0x的历史渊源&quot;&gt;&lt;a href=&quot;#1-C-0x的历史渊源&quot; class=&quot;headerlink&quot; title=&quot;1. C++0x的历史渊源&quot;&gt;&lt;/a&gt;1. C++0x的历史渊源&lt;/h2&gt;&lt;p&gt;C++标准——也就是定义语言的文档和程序库——在1998被批准。在2003年，一个小的“修复bug”版本被发布。然而标准委员会仍然在继续他们的工作，一个“2.0版本”的C++标准预计在2009年被发布（虽然所有的工作很有可能在2007年底被完成）。直到&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 53 关注编译器发出的警告</title>
    <link href="http://yoursite.com/2017/04/22/2017-04-22_18_55_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_53_%E5%85%B3%E6%B3%A8%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%91%E5%87%BA%E7%9A%84%E8%AD%A6%E5%91%8A/"/>
    <id>http://yoursite.com/2017/04/22/2017-04-22_18_55_读书笔记_effective_c++_Item_53_关注编译器发出的警告/</id>
    <published>2017-04-22T10:55:00.000Z</published>
    <updated>2017-05-20T10:40:57.589Z</updated>
    
    <content type="html"><![CDATA[<p>许多程序员常常忽略编译器发出的警告。毕竟，如果问题很严重，它才将会变成一个error，不是么?相对来说，这个想法可能在其它语言是无害的，但是在C++中，我敢打赌编译器的实现者对于对接下来会发生什么比你有更好的理解。例如，下面的错误是每个人都时不时会犯的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">B</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> <span class="title">D</span>: <span class="title">public</span> <span class="title">B</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="params"></span>)</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="1-你对警告的理解可能是错的"><a href="#1-你对警告的理解可能是错的" class="headerlink" title="1. 你对警告的理解可能是错的"></a>1. 你对警告的理解可能是错的</h2><p>你的想法是用D::f重新定义虚函数B::f，但是这里有一个错误：在B中，f是const成员函数，但是在D中，f没有被声明为const。我知道的一个编译器会发出如下警告：</p>
<p>warning: D::f() hides virtual B::f()</p>
<p>太多没有经验的程序员把上面的信息理解为，“当然是D::f把B::f隐藏起来了——这也是它想做的！”但这个理解是错误的。这个编译器正尝试告诉你在B中声明的f没有在D中被重新声明；相反，它被完全隐藏起来了（Item 33中描述了为什么会是这样）。忽略这个编译器警告几乎肯定会导致错误的行为，接下来你会花费大量的时间进行调试来发现编译器已经发现的问题。</p>
<h2 id="2-忽略警告之前确保你已经理解其意义"><a href="#2-忽略警告之前确保你已经理解其意义" class="headerlink" title="2. 忽略警告之前确保你已经理解其意义"></a>2. 忽略警告之前确保你已经理解其意义</h2><p>在你对特定编译器的警告信息有了一些经验之后，你就会理解不同的信息意味着什么（通常情况下实际的意义和表面上看起来相比会有很大不同。）虽然写出没有编译器警告（即使在最高级别警告下）的程序会是更好的实践，一旦你有了经验，你可能就会选择忽略许多警告。无论如何，在你忽略一个警告之前，确保你已经完全理解了编译器在向你传达什么信息，这很重要。</p>
<h2 id="3-警告信息因编译器而异"><a href="#3-警告信息因编译器而异" class="headerlink" title="3. 警告信息因编译器而异"></a>3. 警告信息因编译器而异</h2><p>警告信息和编译器是相关的，所以粗心对待你的代码，而依靠编译器来指出你的错误并不可取。例如，前面提到的函数隐藏的代码，换一个编译器可能没有任何回应。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul>
<li>认真对待编译器警告，在编译器支持的最大警告级别下努力写出没有警告的程序。</li>
<li>不要依赖于编译器警告，因为不同的编译器警告会为不同的事情发出警告。将程序移植到一个新的编译器上可能会消除之前你依赖的警告信息。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多程序员常常忽略编译器发出的警告。毕竟，如果问题很严重，它才将会变成一个error，不是么?相对来说，这个想法可能在其它语言是无害的，但是在C++中，我敢打赌编译器的实现者对于对接下来会发生什么比你有更好的理解。例如，下面的错误是每个人都时不时会犯的：&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;D&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 52 如果你实现了placement new,你也要实现placement delete</title>
    <link href="http://yoursite.com/2017/04/22/2017-04-22_12_59_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_52_%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%BA%86placement_new,%E4%BD%A0%E4%B9%9F%E8%A6%81%E5%AE%9E%E7%8E%B0placement_delete/"/>
    <id>http://yoursite.com/2017/04/22/2017-04-22_12_59_读书笔记_effective_c++_Item_52_如果你实现了placement_new,你也要实现placement_delete/</id>
    <published>2017-04-22T04:59:00.000Z</published>
    <updated>2017-05-20T10:40:57.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-调用普通版本的operator-new抛出异常会发生什么？"><a href="#1-调用普通版本的operator-new抛出异常会发生什么？" class="headerlink" title="1. 调用普通版本的operator new抛出异常会发生什么？"></a>1. 调用普通版本的operator new抛出异常会发生什么？</h2><p>Placement new和placement delete不是C++动物园中最常遇到的猛兽，所以你不用担心你对它们不熟悉。当你像下面这样实现一个new表达式的时候，<br><a id="more"></a><br>忆一下<a href="http://www.cnblogs.com/harlanc/p/6422351.html" title="Item 16" target="_blank" rel="external">Item 16</a>和<a href="http://www.cnblogs.com/harlanc/p/6427236.html" title="Item 17" target="_blank" rel="external">Item 17</a>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Widget *pw = <span class="keyword">new</span> Widget;</div></pre></td></tr></table></figure>
<p>两个函数会被调用：一个是调用operator new来分配内存，第二个是Widget的默认构造函数。</p>
<p>假设第一个调用成功了，但是调用第二个函数抛出了异常。在这种情况下，对步骤一中执行的内存分配必须进行回滚。否则就会发生内存泄漏。客户端代码不能释放内存，因为如果Widget构造函数抛出了异常，pw永远不会赋值。客户端就没有办法得到指向需要释放内存的指针。对步骤一进行回滚的责任就落在了C++运行时系统身上。</p>
<p>运行时系统很高兴去调用与步骤1中调用的operator new版本相对应的operator delete，但是只有在它知道哪个operator delete（可能有许多）是合适的被调用函数的情况下才能做到。如果你正在处理的new和delete版本有着正常的签名，那么这不是一个问题，因为正常的operator new，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t</span>) <span class="title">throw</span>(<span class="params">std::bad_alloc</span>)</span>;</div></pre></td></tr></table></figure>
<p>对应着正常的operator delete:</p>
<div><br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>(<span class="params"><span class="keyword">void</span> *rawMemory</span>) <span class="title">throw</span>(<span class="params"></span>)</span>;     <span class="comment">// normal signature</span></div><div class="line"><span class="comment">// at global scope</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>(<span class="params"><span class="keyword">void</span> *rawMemory, std::size_t size</span>) <span class="title">throw</span>(<span class="params"></span>)</span>;   <span class="comment">// typical normal signature at class  scope        </span></div></pre></td></tr></table></figure><br><br>## 2. 调用自定义operator new抛出异常会发生什么？<br><br>### 2.1 一个有问题的例子<br><br>如果你正在使用普通形式的new和delete,运行时系统能够找到new对应版本的delete来执行回滚操作。然而，如果你开始声明非普通版本的new——也就是生成一个带参数的版本，“哪个delete才是new对应的版本”这个问题就出现了。<br><br>例如，假设你实现了一个类特定版本的operator new，它需要指定一个ostream来为内存分配信息进行记录，你同样实现了一个普通的类特定版本的operator delete:<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t size,</span></span></div><div class="line"></div><div class="line">                                                         // non-normal</div><div class="line">std::ostream&amp; logStream)                    <span class="comment">// form of new</span></div><div class="line"><span class="title">throw</span>(<span class="params">std::bad_alloc</span>);</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>(<span class="params"><span class="keyword">void</span> *pMemory, // normal class</span></span></div><div class="line">std::size_t size) <span class="title">throw</span>(<span class="params"></span>); <span class="comment">// specific form</span></div><div class="line"><span class="comment">// of delete</span></div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>### 2.2 对相关术语的说明<br><br>这个设计是有问题的，但是在我们讨论原因之前，我们需要对相关术语进行说明。<br><br>当一个operator new函数带了额外的参数（除了必须要带的size_t参数）的时候，我们知道这是new的placement版本。上面的operator new就是这样一个placement版本。一个尤为有用的placement new是带有一个指针参数，指定对象应该在哪里被构建。它会像下面这个样子：<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t, <span class="keyword">void</span> *pMemory</span>) <span class="title">throw</span>(<span class="params"></span>)</span>; <span class="comment">// “placement</span></div><div class="line"><span class="comment">// new”</span></div></pre></td></tr></table></figure><br><br>这个版本的new是C++标准库的一部分，只要你#inlucde <new>就能够访问它。它也用来在vector的未被使用的空间中创建对象。它还是最早的placement new。事实上，这也是这个函数的命名依据：在特定位置上的new。这就意味着“placement new”被重载了。大多情况下当人们谈到placement new的时候，它们讨论的是这个特定的函数，也即是带有一个void <em>额外参数的operator new。少数情况下，它们讨论的是带有额外参数的任意版本的operator new。程序的上下文往往会清除这种模棱两可，但是明白普通术语“placement new”意味着带额外参数的任意new版本是很重要的事，因为“placement delete”(我们一会会碰到)直接派生自它。<br><br>### 2.3 如何解决问题<br><br>现在让我们回到对Widget 类的声明上来，我在前面说过这个设计是有问题的。难点在于这个类会发生微妙的内存泄漏。考虑下面的客户代码，在动态创建一个Widget的时候它将内存分配信息记录到cerr中：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Widget *pw = new (std::cerr) Widget; // call operator new, passing cerr as</div><div class="line">// the ostream; this leaks memory</div><div class="line">// if the Widget constructor throws</div></pre></td></tr></table></figure><br><br>还是上次的问题，当内存分配成功了，但是Widget构造函数抛出了异常，运行时系统有责任将operator new执行的分配工作进行回滚。然而，运行时系统不能够真正明白被调用的operator new版本是如何工作的，所以它不能够自己进行回滚操作。相反，<strong>运行时系统会寻找一个**</strong>operator delete<strong><strong>，它和</strong></strong>operator new<strong>**带有相同数量和类型的额外参数</strong>，如果找到了，那么这个就是它要调用的版本。在上面的例子中，operator new带有一个额外的参数ostream&amp;,所以对应的operator delete就是：<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>(<span class="params"><span class="keyword">void</span>*, std::ostream&amp;</span>) <span class="title">throw</span>(<span class="params"></span>)</span>;</div></pre></td></tr></table></figure><br><br>同new的placement 版本进行对比，带有额外参数的operator delete版本被叫做placement delete。在这种情况下，Widget没有声明operator delete的placement 版本，所以运行时系统不知道如何对placement new的操作进行回滚。因此它不会做任何事情。在这个例子中，如果Widget构造函数抛出异常之后没有operator delete会被调用！<br><br>规则很简单：<strong>如果一个带了额外的参数**</strong>operator new <strong><strong>没有与之相匹配的带有相同额外参数的</strong></strong>operator delete<strong><strong>版本，如果</strong></strong>new<strong><strong>的内存分配操作需要被回滚那么没有</strong></strong>operator delete<strong>**会被调用</strong>。为了消除上面代码的内存泄漏，Widget需要声明一个与记录日志的placement new版本相对应的placement delete：<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">...            </div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t size, std::ostream&amp; logStream</span>)</span></div><div class="line"><span class="title">throw</span>(<span class="params">std::bad_alloc</span>);</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>(<span class="params"><span class="keyword">void</span> *pMemory</span>) <span class="title">throw</span>(<span class="params"></span>)</span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>(<span class="params"><span class="keyword">void</span> *pMemory, std::ostream&amp; logStream</span>)</span></div><div class="line"><span class="title">throw</span>(<span class="params"></span>);</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>有了这个改动，在下面的语句中，如果异常从Widget构造函数中抛出来：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Widget *pw = new (std::cerr) Widget; // as before, but no leak this time</div></pre></td></tr></table></figure><br><br>对应的placement delete会被自动被调用，这就让Widget确保没有内存被泄漏。<br><br>## 3. 调用delete会发生什么？<br><br>然而，考虑如果没有异常被抛出的时候会发生什么，我们会在客户端代码中进行delete:<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delete pw; <span class="comment">// invokes the normal</span></div><div class="line"><span class="comment">// operator delete</span></div></pre></td></tr></table></figure><br><br>正如注释所说明的，这会调用普通的operator delete，而不是placement 版本。Placement delete只有在构造函数中调用与之相匹配的placement new时抛出异常的时候才会被触发。对一个指针使用delete（就像上面的pw一样）永远不会调用delete的placement版本。<br><br>这就意味着为了对new的placement 版本造成的内存泄漏问题进行先发制人，你必须同时提供operator delete的普通版本（在构造期间没有异常抛出的时候调用），以及和placement new带有相同额外参数的placement版本（抛出异常时调用）。做到这一点，在内存泄漏的微妙问题上你就永远不需要在辗转反侧难以入睡了。<br><br>## 4. 注意名字隐藏问题<br><br>顺便说一下，因为成员函数名字会隐藏外围作用域中的相同的名字（见<a href="http://www.cnblogs.com/harlanc/p/6556371.html" title="Item 33" target="_blank" rel="external">Item 33</a>）,你需要小心避免类特定的new版本把客户需要的其他版本隐藏掉（包括普通版本）。例如如果你有一个基类只声明了一个operator new的placement 版本，客户将会发现它们不能再使用new的普通版本了：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Base &#123;</div><div class="line">public:</div><div class="line">...</div><div class="line">static void* operator new(std::size_t size, // this new hides</div><div class="line">std::ostream&amp; logStream) // the normal</div><div class="line">throw(std::bad_alloc); // global forms</div><div class="line">...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Base *pb = new Base;                  // error! the normal form of</div><div class="line">// operator new is hidden</div><div class="line"></div><div class="line">Base *pb = new (std::cerr) Base; // fine, calls Base’s</div><div class="line">// placement new</div></pre></td></tr></table></figure><br><br>类似的，派生类中的operator new会同时把operator new的全局版本和继承版本隐藏掉：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Derived: public Base &#123;         // inherits from Base above</div><div class="line"></div><div class="line">public:</div><div class="line">...</div><div class="line">static void* operator new(std::size_t size) // redeclares the normal</div><div class="line">throw(std::bad_alloc); // form of new</div><div class="line">...</div><div class="line">&#125;;</div><div class="line">Derived *pd = new (std::clog) Derived; // error! Base’s placement</div><div class="line">// new is hidden</div><div class="line">Derived *pd = new Derived; // fine, calls Derived’s</div><div class="line">// operator new</div></pre></td></tr></table></figure><br><br><a href="http://www.cnblogs.com/harlanc/p/6556371.html" title="Item 33" target="_blank" rel="external">Item 33</a>中非常详细的讨论了这种类型的名字隐藏，但是为了实现内存分配函数，你需要记住的是默认情况下，C++在全局范围内提供了如下版本的operator new:<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t</span>) <span class="title">throw</span>(<span class="params">std::bad_alloc</span>)</span>;          <span class="comment">// normal new</span></div><div class="line"></div><div class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t, <span class="keyword">void</span>*</span>) <span class="title">throw</span>(<span class="params"></span>)</span>;    <span class="comment">// placement new</span></div><div class="line"></div><div class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t,                             // nothrow new —</span></span></div><div class="line"><span class="keyword">const</span> std::nothrow_t&amp;) <span class="title">throw</span>(<span class="params"></span>); <span class="comment">// see[ Item 49](http://www.cnblogs.com/harlanc/p/6721163.html "Item 49")</span></div></pre></td></tr></table></figure><br><br>如果你在类中声明了任何operator new，你就会隐藏这些标准版本。除非你的意图是防止客户使用这些版本，否则除了任何你所创建的自定义operator new版本之外，确保这些标准版本能够被客户所用。对每个你所提供的operator new，确保同时提供相对应的operator delete。如果你想让这些函数的行为同普通函数一样，让你的类特定版本调用全局版本就可以了。<br><br>实现这个目的的一种简单的方法是创建一个包含所有new 和delete版本的基类：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class StandardNewDeleteForms &#123;</div><div class="line">public:</div><div class="line">// normal new/delete</div><div class="line">static void* operator new(std::size_t size) throw(std::bad_alloc)</div><div class="line">&#123; return ::operator new(size); &#125;</div><div class="line">static void operator delete(void *pMemory) throw()</div><div class="line">&#123; ::operator delete(pMemory); &#125;</div><div class="line"></div><div class="line">// placement new/delete</div><div class="line">static void* operator new(std::size_t size, void *ptr) throw()</div><div class="line">&#123; return ::operator new(size, ptr); &#125;</div><div class="line">static void operator delete(void *pMemory, void *ptr) throw()</div><div class="line">&#123; return ::operator delete(pMemory, ptr); &#125;</div><div class="line">// nothrow new/delete</div><div class="line">static void* operator new(std::size_t size, const std::nothrow_t&amp; nt) throw()</div><div class="line">&#123; return ::operator new(size, nt); &#125;</div><div class="line">static void operator delete(void *pMemory, const std::nothrow_t&amp;) throw()</div><div class="line">&#123; ::operator delete(pMemory); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>客户如果想在自定义版本的基础上增加标准版本，只需要继承这个基类然后使用using声明就可以(<a href="http://www.cnblogs.com/harlanc/p/6556371.html" title="Item 33" target="_blank" rel="external">Item 33</a>）获得标准版本：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Widget: public StandardNewDeleteForms &#123;       // inherit std forms</div><div class="line"></div><div class="line">public:                                                               </div><div class="line"></div><div class="line">using StandardNewDeleteForms::operator new; // make those</div><div class="line"></div><div class="line">using StandardNewDeleteForms::operator delete;    // forms visible</div><div class="line"></div><div class="line">static void* operator new(std::size_t size,        // add a custom</div><div class="line"></div><div class="line">std::ostream&amp; logStream) // placement new</div><div class="line">throw(std::bad_alloc);</div><div class="line">static void operator delete(void *pMemory, // add the corres</div><div class="line">std::ostream&amp; logStream) // ponding place</div><div class="line">throw(); // ment delete</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>## 5. 总结

</em>   当你实现operator new的placement版本的时候，确保实现与之相对应的operator delete placement版本。如果你不进行实现，有的程序会发生微妙的，间歇性的内存泄漏。<br>*   当你声明new和delete的placement版本的时候，确保不要无意间隐藏这些函数的普通版本。</new></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-调用普通版本的operator-new抛出异常会发生什么？&quot;&gt;&lt;a href=&quot;#1-调用普通版本的operator-new抛出异常会发生什么？&quot; class=&quot;headerlink&quot; title=&quot;1. 调用普通版本的operator new抛出异常会发生什么？&quot;&gt;&lt;/a&gt;1. 调用普通版本的operator new抛出异常会发生什么？&lt;/h2&gt;&lt;p&gt;Placement new和placement delete不是C++动物园中最常遇到的猛兽，所以你不用担心你对它们不熟悉。当你像下面这样实现一个new表达式的时候，&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 51 实现new和delete的时候要遵守约定</title>
    <link href="http://yoursite.com/2017/04/21/2017-04-21_08_01_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_51_%E5%AE%9E%E7%8E%B0new%E5%92%8Cdelete%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E9%81%B5%E5%AE%88%E7%BA%A6%E5%AE%9A/"/>
    <id>http://yoursite.com/2017/04/21/2017-04-21_08_01_读书笔记_effective_c++_Item_51_实现new和delete的时候要遵守约定/</id>
    <published>2017-04-21T00:01:00.000Z</published>
    <updated>2017-05-20T10:40:57.440Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/harlanc/p/6731455.html" title="Item 50" target="_blank" rel="external">Item 50</a>中解释了在什么情况下你可能想实现自己版本的operator new和operator delete，但是没有解释当你实现的时候需要遵守的约定。遵守这些规则<br><a id="more"></a><br>不是很困难，但是它们其中有一些并不直观，所以知道这些规则是什么很重要。</p>
<h2 id="1-定义operator-new的约定"><a href="#1-定义operator-new的约定" class="headerlink" title="1. 定义operator new的约定"></a>1. 定义operator new的约定</h2><h3 id="1-1-约定列举"><a href="#1-1-约定列举" class="headerlink" title="1.1 约定列举"></a>1.1 约定列举</h3><p>我们以operator new开始。实现一个一致的operator new需要有<strong>正确的返回值</strong>，在没有足够内存的时候<strong>调用**</strong>new-handling<strong>**函数</strong>（见<a href="http://www.cnblogs.com/harlanc/p/6721163.html" title="Item 49" target="_blank" rel="external">Item 49</a>）,并且做好准备<strong>处理没有内存可分配的情况</strong>。你也想避免无端的隐藏“正常”版本的new，但这是一个类接口的问题而不是实现需求问题；它会在Item 52中进行处理。</p>
<p>Operator new的返回值部分很简单，因为operator new事实上会尝试多次分配内存，在内次分配失败之后都会调用new-handling函数。这里的假设是new-handling函数可能会做一些事情来释放一些内存。只有在指向new-handling函数的指针为null的情况下，operator new才会抛出异常。</p>
<p>好奇的是，C++即使在请求0个byte的时候也需要operator new返回一个合法的指针。（这个听上去很奇怪的要求简化了语言中的某些事情。）这就是基本情况，一个非成员operator new的伪代码会是像下面这个样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void* operator new(std::size_t size) throw(std::bad_alloc)</div><div class="line">&#123; // your operator new might</div><div class="line"></div><div class="line">using namespace std;             // take additional params</div><div class="line"></div><div class="line">if (size == 0) &#123;          // handle 0-byte requests</div><div class="line"></div><div class="line">size = 1; // by treating them as</div><div class="line">&#125; // 1-byte requests</div><div class="line">while (true) &#123;</div><div class="line">attempt to allocate size bytes;</div><div class="line"></div><div class="line">if (the allocation was successful)</div><div class="line">return (a pointer to the memory);</div><div class="line">// allocation was unsuccessful; find out what the</div><div class="line">// current new-handling function is (see below)</div><div class="line">new_handler globalHandler = set_new_handler(0);</div><div class="line">set_new_handler(globalHandler);</div><div class="line">if (globalHandler) (*globalHandler)();</div><div class="line">else throw std::bad_alloc();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把请求0个byte当作请求1一个byte来进行处理的诡计看上去让人厌恶，但这是简单的实现并且合法，而且能够工作，无论如何，你对0个byte的请求会有多频繁呢？</p>
<p>对于伪代码中将new-handling函数指针设为null，然后迅速的将其复原的地方，你可能看上去比较怀疑。不幸的是，没有其他方法直接获得new-handling函数的指针，所以你必须调用set_new_handler来发现这个函数是什么。看上去粗糙但却是有效的，起码对于单线程来说是有效的。在多线程环境中，你可能需要某种类型的锁来安全的操作new-handling函数背后的（全局）数据结构。</p>
<p>在<a href="http://www.cnblogs.com/harlanc/p/6721163.html" title="Item 49" target="_blank" rel="external">Item 49</a>中讨论过了，在operator new中包含一个无限循环，上面的代码中将其展示了出来；“while(true)”就 表示一个无限循环。跳出循环的唯一方法是成功的分配内存或者让new-handling函数做到Item 49中描述的事情中的其中一件：<strong>有更多的内存可供分配，安装一个不同的**</strong>new-handler<strong><strong>，卸载</strong></strong>new-handler<strong><strong>，抛出一个异常，这个异常要么继承自</strong></strong>bad_alloc<strong>**要么源于失败返回</strong>。现在你应该清楚为什么new-handler必须做到这些事情中的一件的了，如果做不到，operator new中的循环永远不会终止。</p>
<h3 id="1-2-由继承导致的问题"><a href="#1-2-由继承导致的问题" class="headerlink" title="1.2 由继承导致的问题"></a>1.2 由继承导致的问题</h3><p>许多人没有意识到operator new成员函数是要被派生类继承的。这可能会导致一些有趣的并发症。在上面的operator new的伪代码中，注意函数尝试分配size个bytes。这再合理不过了，因为这是传递到函数中的参数。然而，正如<a href="http://www.cnblogs.com/harlanc/p/6731455.html" title="Item 50" target="_blank" rel="external">Item 50</a>中解释的，实现一个自定义内存管理器的最一般的原因就是为<strong>特定类的对象</strong>进行内存分配优化，而不是为类或者它的任何派生类。也即是，我们为类X提供了一个operaor new，这个函数的行为是为大小正好为sizeof(X)的对象进行调整，即不大也不小。然而由于继承的存在，可能发生通过调用基类中的operator new来为派生类对象分配内存：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Base</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t size</span>) <span class="title">throw</span>(<span class="params">std::bad_alloc</span>)</span>;</div><div class="line">...</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> <span class="title">Derived</span>: <span class="title">public</span> <span class="title">Base</span> <span class="comment">// Derived doesn’t declare</span></div><div class="line">&#123; ... &#125;; <span class="comment">// operator new</span></div><div class="line"></div><div class="line">Derived *p = <span class="keyword">new</span> Derived;                             <span class="comment">// calls Base::operator new!</span></div></pre></td></tr></table></figure>
<p>如果基类中的operator new设计没有处理这种情况，处理它的最好的方法将对“错误”数量内存的请求丢弃掉，而是转而使用标准operator new来处理,就像下面这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void* Base::operator new(std::size_t size) throw(std::bad_alloc)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">if (size != sizeof(Base)) // if size is “wrong,”</div><div class="line">return ::operator new(size); // have standard operator</div><div class="line">// new handle the request</div><div class="line">... // otherwise handle</div><div class="line">// the request here</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“等一下”我听见你大叫，“你忘记检查病态但是可能发生的情况，也就是size为0的情况了！”事实上，我没有忘记。测试仍然在那里，只不过是将测试并入size同sizeof(size)的测试之中了。C++用神秘的方式进行工作，其中之一的方式就是规定所有独立对象的大小不能为0（见<a href="http://www.cnblogs.com/harlanc/p/6636917.html" title="Item 39" target="_blank" rel="external">Item 39</a>）。根据定义，sizeof(Base)永远不会为0，所以如果size为0，内存请求将由::operator new来处理，它会以一种合理的方式来处理这个请求。</p>
<h3 id="1-3-定义operator-new-的约定"><a href="#1-3-定义operator-new-的约定" class="headerlink" title="1.3 定义operator new[]的约定"></a>1.3 定义operator new[]的约定</h3><p>如果你想在一个类中控制数组的内存分配，你需要实现operator new的数组形式，operator new[]。（这个函数通常被叫做“array new”，因为很难确定“operator new[]”该如何发音）。如果你决定实现operator new[],记住所有你正在做的是分配一大块原生内存——你不能对不存在于数组中的对象做任何事情。事实上，你甚至不能确定数组将会有多少对象。<strong>首先</strong>，你不会知道每个对象有多大。毕竟，很有可能通过继承来调用基类的operator new[]去为派生类对象数组分配内存，派生类对象通常比基类对象要大。因此，你不能假设在Base::operator new[]内部被放入数组的对象的大小为sizeof(Base)，这就意味着你不能假设数组中对象的数量为(请求的字节数)/sizeof(Base)。<strong>第二</strong>，传递给operator new[]的参数size_t有可能比填入对象的内存更多，因为正如<a href="http://www.cnblogs.com/harlanc/p/6422351.html" title="Item 16" target="_blank" rel="external">Item 16</a>中解释的，动态分配的数组有可能包含额外的空间来存放数组元素的数量。</p>
<h2 id="2-定义operator-delete的约定"><a href="#2-定义operator-delete的约定" class="headerlink" title="2. 定义operator delete的约定"></a>2. 定义operator delete的约定</h2><p>当实现operator new的时候需要遵守的约定就这么多。对于operator delete,事情更加简单。所有你需要记住的是<strong>C++总是保证delete null指针是安全的</strong>，所以你需要遵守这个规定。下面是实现非成员 operator delete的伪代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>(<span class="params"><span class="keyword">void</span> *rawMemory</span>) <span class="title">throw</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// do nothing if the null</span></div><div class="line"><span class="comment">// pointer is being deleted</span></div><div class="line">deallocate the memory pointed to <span class="keyword">by</span> rawMemory;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的成员函数版本也是简单的，但是你需要确保检查正在被delete的对象的size。假设你的属于类的operator new将对错误数量内存的请求转发给了::operator new，你同样得将对“错误大小”的delete请求转发给::operator delete:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Base &#123; // same as before, but now</div><div class="line">public: // operator delete is declared</div><div class="line">static void* operator new(std::size_t size) throw(std::bad_alloc);</div><div class="line">static void operator delete(void *rawMemory, std::size_t size) throw();</div><div class="line">...</div><div class="line">&#125;;</div><div class="line">void Base::operator delete(void *rawMemory, std::size_t size) throw()</div><div class="line">&#123;</div><div class="line"></div><div class="line">if (rawMemory == 0) return; // check for null pointer</div><div class="line"></div><div class="line">if (size != sizeof(Base)) &#123; // if size is “wrong,”</div><div class="line"></div><div class="line">::operator delete(rawMemory); // have standard operator</div><div class="line"></div><div class="line">return;                                                                           // delete handle the request</div><div class="line"></div><div class="line">&#125;                                                                                    </div><div class="line"></div><div class="line">deallocate the memory pointed to by rawMemory;      </div><div class="line"></div><div class="line">return;                                                                          </div><div class="line"></div><div class="line">&#125;        </div></pre></td></tr></table></figure>
<p> 有趣的是，如果要被delete的对象派生自于一个没有虚析构函数的基类，那么传递给operator delete的size_t值有可能是不正确的。这就有了足够的理由来把你的基类中的析构函数声明为虚函数，但是<a href="http://www.cnblogs.com/harlanc/p/6395052.html" title="Item 7" target="_blank" rel="external">Item 7</a>中描述了第二个可能更好的原因。现在你需要注意的是如果你在基类中忽略了虚析构函数，operator delete函数的工作就有可能不正确。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul>
<li>operator new应该包含一个无限循环来尝试分配内存，如果不能满足对内存的请求应该调用new-handler,应该处理对0个byte的请求。类的特定版本应该处理比预期更大的内存块的请求。</li>
<li>operator delete中传递的指针如果是null，应该什么都不做。类特定版本需要处理比预期要大的内存块。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/harlanc/p/6731455.html&quot; title=&quot;Item 50&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Item 50&lt;/a&gt;中解释了在什么情况下你可能想实现自己版本的operator new和operator delete，但是没有解释当你实现的时候需要遵守的约定。遵守这些规则&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 50 了解何时替换new和delete 是有意义的</title>
    <link href="http://yoursite.com/2017/04/19/2017-04-19_08_00_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_50_%E4%BA%86%E8%A7%A3%E4%BD%95%E6%97%B6%E6%9B%BF%E6%8D%A2new%E5%92%8Cdelete_%E6%98%AF%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84/"/>
    <id>http://yoursite.com/2017/04/19/2017-04-19_08_00_读书笔记_effective_c++_Item_50_了解何时替换new和delete_是有意义的/</id>
    <published>2017-04-19T00:00:00.000Z</published>
    <updated>2017-05-20T10:40:57.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义new和delete的三个常见原因"><a href="#1-自定义new和delete的三个常见原因" class="headerlink" title="1. 自定义new和delete的三个常见原因"></a>1. 自定义new和delete的三个常见原因</h2><p>我们先回顾一下基本原理。为什么人们一开始就想去替换编译器提供的operator new和operator delete版本？有三个最常见的原因：</p>
<ul>
<li>为了检测内存使用错误。不能成功delete new出来的内存会<a id="more"></a>
成内存泄漏。在new出来的内存上使用多于一次的delete会产生未定义行为。如果operator new持有一份内存分配的列表，并且operator delete从列表中移除地址，那么就很容易侦测出这种使用错误。类似的，不同种类的编程错误能够导致数据右越界（overrun）（越过分配内存块的结尾写数据）或者左越界(underrun)（在分配内存块的开始之前写数据）。自定义的operator new能够分配额外的内存块，所以在客户申请内存前后就有空间存放已知的字节模式（“签名signatures”）。Operato delete能够检查签名是否发生了变化，如果变了，那么在分配内存块的生命周期中，越界（overrun orunderrun）就有可能会发生,operator delete会记录这个事实，并且将违规指针的值记录下来。</li>
<li>为了提高效率。编译器提供的operator new和operator delete的版本是供大众使用的。它们必须能被长时间运行的程序所用（例如 web server），也能被执行时间小于1秒的程序所使用。它们必须要处理对大内存块，小内存块以及大小混合内存块的请求。它们必须要适应不同的内存分配模式，从为持续运行的程序提供内存块的动态分配到为大量短暂存在对象提供的常量大小的内存块分配和释放。它们必须考虑内存碎片问题，如果不做内存碎片的检查，最后有可能发生内存充足却因为分布在不同的小内存块中而导致内存请求失败的问题。</li>
</ul>
<p>考虑以上在内存管理上的不同要求，编译器版本的operator new和operator delete为你提供一个大众化内存分配策略就不足为奇了。它们能够为每个人都工作  的很好，但是对于这些人来说都不是最优的。如果你对程序的动态内存运用模式有一个很好的理解，你就会发现使用自定义版本的operator new和operator delete会胜过默认版本。“胜过”的意思就是它们运行的更快——有时速度提升是数量级的,它们使用的内存会更少——最高能减少50%的内存。对于一些应用来说，能够很容易的替换默认operator new和operator delete版本，却能够收获很大的性能提升。</p>
<ul>
<li>为了收集内存使用的统计信息。在沿着自定义new和delete这条小路前进之前，对你的软件是如何使用动态分配内存的相关信息进行收集是很精明的。内存分配块的大小是如何分布的？内存块的生命周期是如何分布的？内存的分配和释放是使用FIFO（先进先出）的顺序，还是使用LIFO（后进先出）的顺序？或者有时候更加趋近于随机的顺序？内存使用的模式是不时地发生变化的么？例如，你的软件在不同的执行阶段是不是有不同的内存分配和释放模式？一次能够使用的动态分配内存的最大容量是多少？自定义版本的operator new和operator delete使得收集这些信息变得容易。</li>
</ul>
<h2 id="2-自定义operator-new中的对齐问题"><a href="#2-自定义operator-new中的对齐问题" class="headerlink" title="2. 自定义operator new中的对齐问题"></a>2. 自定义operator new中的对齐问题</h2><p>从概念上来说，实现一个自定义operator new是非常容易的。例如，我们快速的实现一个全局operator new，它能够很容易的检测内存越界。它也有很多小的错误，但是我们一会再去为它们担心。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> signature = <span class="number">0xDEADBEEF</span>;</div><div class="line"></div><div class="line">typedef unsigned <span class="keyword">char</span> Byte;</div><div class="line"><span class="comment">// this code has several flaws — see below</span></div><div class="line"><span class="keyword">void</span>* <span class="function"><span class="keyword">operator</span> <span class="title">new</span>(<span class="params">std::size_t size</span>) <span class="title">throw</span>(<span class="params">std::bad_alloc</span>)</span></div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</div><div class="line">size_t realSize = size + <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);             <span class="comment">// increase size of request so 2</span></div><div class="line"><span class="comment">// signatures will also fit inside</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> *pMem = malloc(realSize);   <span class="comment">// call malloc to get the actual</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> bad_alloc();                                                          <span class="comment">// memory</span></div><div class="line"></div><div class="line"><span class="comment">// write signature into first and last parts of the memory              </span></div><div class="line"></div><div class="line">*(static_cast&lt;<span class="keyword">int</span>*&gt;(pMem)) = signature;                                        </div><div class="line"></div><div class="line">*(reinterpret_cast&lt;<span class="keyword">int</span>*&gt;(static_cast&lt;Byte*&gt;(pMem)+realSize-<span class="keyword">sizeof</span>(<span class="keyword">int</span>))) =          </div><div class="line"></div><div class="line">signature;                                                                                       </div><div class="line"></div><div class="line"><span class="comment">// return a pointer to the memory just past the first signature       </span></div><div class="line"></div><div class="line"><span class="keyword">return</span> static_cast&lt;Byte*&gt;(pMem) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>);                             </div><div class="line"></div><div class="line">&#125;      </div></pre></td></tr></table></figure>
<p>这个operator new的大多数毛病是因为它不符合C++惯例。例如，Item 51中解释了所有的operator new都应该包含一个反复调用new-handling函数的循环，但是这个函数里没有。然而，因为在Item51中会有解释，在这里我们将其忽略。我现在想关注一个更加微妙的问题：<strong>对齐（**</strong>alignment<strong>**）</strong>。</p>
<p>对于许多计算机架构来说，在内存中替换特定类型的数据时，需要在特定种类的地址上进行。例如，一种架构可能需要指针定义的开始地址为4的整数倍（也就是4字节对齐的）或者定义double的开始地址必须为8的整数倍（也就是8字节对齐的）。不遵守这个约束条件在运行时就会导致硬件异常。其他架构可能更加宽松，也即是如果满足对齐会有更好的性能。例如，在英特尔X86架构中double可以被对齐在任何字节边界上，但是如果它们是8字节对齐的，访问它们的速度会大大加快。</p>
<p>Operator new和对齐（alignment）是相关的，因为C++需要所有operator new返回的指针都能够被恰当的对齐，malloc工作在同样的需求下，所以让operator new返回从malloc得到的指针是安全的。然而，在上面的operator new中，我们没有返回从malloc得到的指针，我们返回的是从malloc得到的指针加上int大小的偏移量。这就在安全上没有保证了！如果客户通过调用operator new来为double获取足够的内存（或者如果我们实现了operator new[]，为double数组申请内存），并且我们工作在int为4字节大小但是double需要8字节对齐的机器上，我们可能返回一个没有恰当的对齐的指针。这可能会导致程序崩溃。或者它只会导致程序运行更加缓慢。不管哪种结果，都不是我们想要的。</p>
<h2 id="3-通常情况你无需自定义new和delete"><a href="#3-通常情况你无需自定义new和delete" class="headerlink" title="3. 通常情况你无需自定义new和delete"></a>3. 通常情况你无需自定义new和delete</h2><p>因为像对齐（alignment）这样的细节问题的存在，程序员在专心完成其他任务的时候将这些细节问题忽略会导致各种问题的抛出，这就能够将专业级别的内存管理器区分出来。实现一个能够工作的内存管理器是非常容易的。实现一个工作良好的就非常难了。作为通用规则，我建议你不要尝试，除非有必要。</p>
<h3 id="3-1-使用默认版本和商业产品"><a href="#3-1-使用默认版本和商业产品" class="headerlink" title="3.1 使用默认版本和商业产品"></a>3.1 使用默认版本和商业产品</h3><p>在许多情况下，你不必这么做。在一些编译器的内存管理函数中有控制调试和记录日志功能的开关。快速瞥一眼你的编译器文档可能就能消除你自己来实现New和delete的想法。在许多平台中，商业产品能够替换编译器自带的内存管理函数。它们的增强的功能和改善的性能能够使你受益，你所需要做的就是重新链接（前提是你必须买下这个产品。）</p>
<h3 id="3-2-使用开源内存管理器"><a href="#3-2-使用开源内存管理器" class="headerlink" title="3.2 使用开源内存管理器"></a>3.2 使用开源内存管理器</h3><p>另外一个选择是开源的内存管理器。在许多平台上都能找到这样的管理器，所以你可以下载和尝试。其中一个开源的内存分配器是来自Boost的Pool库（Item 55）。这个Pool库提供的内存分配器对自定义内存管理很有帮助：也就是在有大量的小对象需要分配的时候。许多C++书籍中，包含本书的早期版本，展示出了高性能小对象内存分配器的源码，但他们通常都会忽略一些细节，像可移植性，对于对齐的考虑，线程安全等等。真正的库提供的源码都是更加健壮的。即使你自己决定去实现你自己的new和delete，看一下这些开源的版本能够让你对容易忽略的细节有了深刻洞察力，而这些细节就将“基本工作”和“真正工作”区分开来。（鉴于对齐是这样一个细节，因此注意一下TR1是很有价值的，其中包含了对特定类型对齐的支持。）</p>
<h2 id="4-使用自定义版本new和delete的意义总结"><a href="#4-使用自定义版本new和delete的意义总结" class="headerlink" title="4. 使用自定义版本new和delete的意义总结"></a>4. 使用自定义版本new和delete的意义总结</h2><p>这个条款的论题是让你知道在什么情况下对默认版本的new和delete进行替换是有意义的，无论是在全局范围内替换还是在类的范围内替换。我们现在做一个总结。</p>
<ul>
<li>检测内存使用错误。</li>
<li>收集使用动态分配内存的统计信息。</li>
<li>提高内存分配和释放的速度。为大众提供的分配器通常情况下比自定义版本要慢的多，特别是在自定义版本是专门为特定类型对象所设计的情况下。类特定的分配器是固定大小分配器的一个实例应用，例如在Boost的Pool库中提供的分配器。如果你的应用是单线程的，但是你的编译器默认版本是线程安全的，你可以通过实现线程不安全的分配器来获得可观的速度提升。当然，在下决定要提升operator new和operator delete的速度之前，研究一下你的程序来确定这些函数真的是瓶颈所在。</li>
<li>减少默认内存管理的空间开销。大众内存管理器通常情况下不仅慢，而且使用更多的内存。因为它们会为每个内存分配块引入一些额外的开销。为小对象创建的分配器从根本上消除了这些开销。</li>
<li>能够补偿在默认分配器中的次优对齐。正如我先前提到的，在X86架构的机器上访问double，在8字节对齐的情况下速度是最快的。但是一些编译器中的operator new不能够保证对于动态分配的double是8字节对齐的。在这种情况中，用能够保证8字节对齐的版本替换默认版本可以很大程度的提高性能。</li>
<li>将相关对象集中起来。如果你知道一些特定的数据结构通常情况下会被放在一起被使用，当在这些数据上进行工作时你想让页错误出现的频率最小化，为这些数据结构创建一个单独的堆就有意义了，这样它们就能够聚集在尽可能少的页中。替换new和delete的默认版本可以达到这种聚集。</li>
<li>可以获得非常规的行为。有时候你想让operator new和delete能够做一些编译器版本不能做的事。例如，你可能想在共享内存中进行内存分配和释放，但是你只有一个C API来进行内存管理。实现自定义版本的new 和delete（可能是placement 版本——见Item 52）允许你为C API穿上C++的外衣。另外一个例子，你可以自己实现一个operator delete来为释放的内存填充数据0以达到增强应用数据安全性的目的。</li>
</ul>
<h2 id="5-本条款总结"><a href="#5-本条款总结" class="headerlink" title="5. 本条款总结"></a>5. 本条款总结</h2><p>有许多正当的理由来自定义new 和delete，包括提高性能，调试堆应用错误和收集堆使用信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-自定义new和delete的三个常见原因&quot;&gt;&lt;a href=&quot;#1-自定义new和delete的三个常见原因&quot; class=&quot;headerlink&quot; title=&quot;1. 自定义new和delete的三个常见原因&quot;&gt;&lt;/a&gt;1. 自定义new和delete的三个常见原因&lt;/h2&gt;&lt;p&gt;我们先回顾一下基本原理。为什么人们一开始就想去替换编译器提供的operator new和operator delete版本？有三个最常见的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了检测内存使用错误。不能成功delete new出来的内存会
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 49 理解new-handler的行为</title>
    <link href="http://yoursite.com/2017/04/17/2017-04-17_08_01_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_49_%E7%90%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA/"/>
    <id>http://yoursite.com/2017/04/17/2017-04-17_08_01_读书笔记_effective_c++_Item_49_理解new-handler的行为/</id>
    <published>2017-04-17T00:01:00.000Z</published>
    <updated>2017-05-20T10:40:57.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-new-handler介绍"><a href="#1-new-handler介绍" class="headerlink" title="1. new-handler介绍"></a>1. new-handler介绍</h2><p>当操作符new不能满足内存分配请求的时候，它就会抛出异常。很久之前，它会返回一个null指针，一些旧的编译器仍然会这么做。你仍然会看到这种旧行为，但是我会把关于它的讨论推迟到本条款结束的时候。</p>
<h3 id="1-1-调用set-new-handle"><a href="#1-1-调用set-new-handle" class="headerlink" title="1.1 调用set_new_handle"></a>1.1 调用set_new_handle</h3><a id="more"></a>
<p>来指定全局new-handler</p>
<p>在operator new由于不能满足内存分配要求而抛出异常之前，它会调用一个客户指定的叫做new-handler的错误处理函数。（这也不是完全正确的。Operator new的真正行为更加复杂。详细内容在Item 51中描述。）为了指定内存溢出处理（out-of-memory-handling）函数，客户可以调用set_new_handler函数，这个标准库函数被声明在<new>中：</new></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">std</span> &#123;</div><div class="line"><span class="function">typedef <span class="title">void</span> (<span class="params">*new_handler</span>)(<span class="params"></span>)</span>;</div><div class="line"><span class="function">new_handler <span class="title">set_new_handler</span>(<span class="params">new_handler p</span>) <span class="title">throw</span>(<span class="params"></span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如你所看到的，new_handler是一个函数指针的typedef，这个函数没有参数没有返回值，set_new_handler是一个参数和返回值都为new_handler的函数。（函数set_new_handler声明结束处的”throw()”是一个异常指定（exception<br>specification）。从本质上来说它的意思是说这个函数不会抛出任何异常，然而事实更加有意思。详细内容见<a href="http://www.cnblogs.com/harlanc/p/6516877.html" title="Item 29" target="_blank" rel="external">Item 29</a>。）</p>
<p>set_new_handler的参数是指向函数的指针，operator new会在请求的内存无法分配的情况下调用这个函数。Set_new_handler的返回值也是指向函数的指针，返回的是在调用set_new_handler之前调用的new_handler函数（也就是在new_handler被替换之前的函数）。</p>
<p>你可以像下面这样使用set_new_handler：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// function to call if operator new can’t allocate enough memory</div><div class="line">void outOfMem()</div><div class="line">&#123;</div><div class="line">std::cerr &lt;&lt; "Unable to satisfy request for memory\n";</div><div class="line">std::abort();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">std::set_new_handler(outOfMem);</div><div class="line">int *pBigDataArray = new int[100000000L];</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果operaotr new无法为100,000,000个整数分配内存，就会调用outOfMem，也就是输出一个error信息之后程序终止（abort）。（顺便说一下，考虑在向cerr中写入error信息期间如果必须动态的分配内存会发生什么。。）</p>
<h3 id="1-2-如何设计一个良好的new-handler函数"><a href="#1-2-如何设计一个良好的new-handler函数" class="headerlink" title="1.2 如何设计一个良好的new-handler函数"></a>1.2 如何设计一个良好的new-handler函数</h3><p>当operator new不能满足一个内存请求的时候，它会反复调用new-handler函数直到它发现有足够的内存可以分配了。引起这些函数被反复调用的代码在Item 51中可以找到，但是这种高级别的描述信息足够让我们得出结论：一个设计良好的new-handler函数必须能够做到如下几点。</p>
<ul>
<li>提供更多的可被使用的内存。这可以保证下次在operator new内部尝试分配内存时能够成功。实现这个策略的一种方法是在程序的开始阶段分配一大块内存，然后在第一次调用new-handler的时候释放它。</li>
<li>安装一个不同的new-handler。如果当前的new-handler不能够为你提供更多的内存，可能另外一个new-handler可以。如果是这样，可以在当前的new-handler的位置上安装另外一个new-handler（通过调用set_new_handler）。下次operator new调用new-handler函数的时候，它会调用最近安装的。（这个主题的一个变种是一个使用new_handler来修改它自己的行为，所以在下次触发这个函数的时候，它就会做一些不同的事情。达到这个目的的一个方法是让new_handler修改影响new-handler行为的static数据,命名空间数据或者全局数据。）</li>
<li>卸载new-handler，也就是为set_new_handler传递null指针。如果没有安装new-handler，operator  new在内存分配失败的时候会抛出异常。</li>
<li>没有返回值，调用abort或者exit。</li>
</ul>
<p>这些选择让你在实现new-handler的时候有相当大的灵活性。</p>
<h2 id="2-为特定类指定new-handler"><a href="#2-为特定类指定new-handler" class="headerlink" title="2. 为特定类指定new-handler"></a>2. 为特定类指定new-handler</h2><p>有时候你想用不同方式来处理内存分配失败，这依赖于需要分配内存的对象所属的类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">X</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outOfMemory</span>(<span class="params"></span>)</span>;</div><div class="line">...</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> <span class="title">Y</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outOfMemory</span>(<span class="params"></span>)</span>;</div><div class="line">...</div><div class="line">&#125;;</div><div class="line">X* p1 = <span class="keyword">new</span> X; <span class="comment">// if allocation is unsuccessful,</span></div><div class="line"><span class="comment">// call X::outOfMemory</span></div><div class="line">Y* p2 = <span class="keyword">new</span> Y; <span class="comment">// if allocation is unsuccessful,</span></div><div class="line"><span class="comment">// call Y::outOfMemory</span></div></pre></td></tr></table></figure>
<p>C++没有为类提供指定的new-handlers，但也不需要。你可以自己实现这种行为。你可以使每个类提供自己版本的set_new_handler和operator new。类中的set_new_handler允许客户为类提供new_handler（就像标准的set_new_handler允许客户指定全局的new-handler一样）。类的operator new确保为类对象分配内存时，会使用其指定的new-handler来替代全局new-handler。</p>
<h3 id="2-1-在类中声明static-new-handler成员"><a href="#2-1-在类中声明static-new-handler成员" class="headerlink" title="2.1 在类中声明static new_handler成员"></a>2.1 在类中声明static new_handler成员</h3><p>假设你想对Widget类对象的内存分配失败做一下处理。当operator new不能为Widget对象分配足够的内存的时候你必须跟踪一下函数调用过程，所以你要声明一个类型为new_handler的static成员，来指向这个类的new-handler函数。Widget将会是下面这个样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Widget &#123;</div><div class="line">public:</div><div class="line">static std::new_handler set_new_handler(std::new_handler p) throw();</div><div class="line">static void* operator new(std::size_t size) throw(std::bad_alloc);</div><div class="line">private:</div><div class="line">static std::new_handler currentHandler;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>静态类成员必须在类外部定义（除非他们是const整型，见<a href="http://www.cnblogs.com/harlanc/p/6376536.html" title="Item 2" target="_blank" rel="external">Item 2</a>）,所以：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::new_handler Widget::currentHandler = 0; // init to null in the class</div><div class="line">// impl. File</div></pre></td></tr></table></figure>
<p>Widget中的set_new_handler函数会把传递进去的指针（所指向的new-handler函数）保存起来，并且会返回调用set_new_handler之前所保存的指针。这也是标准版本set_new_handler的做法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">std::new_handler Widget::set_new_handler(std::new_handler p) throw()</div><div class="line">&#123;</div><div class="line">std::new_handler oldHandler = currentHandler;</div><div class="line">currentHandler = p;</div><div class="line">return oldHandler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-重新定义operator-new"><a href="#2-2-重新定义operator-new" class="headerlink" title="2.2 重新定义operator new"></a>2.2 重新定义operator new</h3><p>最后，Widget的operator new将会做下面的事情：</p>
<ol>
<li>调用标准set_new_handler，参数为Widget的错误处理函数。这就将Widget的new-handler安装成为了全局的new-handler。</li>
<li>调用全局的operator new来执行实际的内存分配。如果分配失败，全局的operator new会触发Widget的new-handler，因为这个函数已经被安装为全局new-handler。如果全局的operator new最终不能分配内存，它会抛出bad_alloc异常。在这种情况下，Widget的operator new必须恢复原来的全局new-handler，然后传播异常。为了确保源new-handler总是能被恢复，Widget将全局new-handler作为资源来处理，遵循<a href="http://www.cnblogs.com/harlanc/p/6412222.html" title="Item 13" target="_blank" rel="external">Item 13</a>的建议，使用资源管理对象来防止资源泄漏。</li>
<li>如果全局operator new能够为Widget对象分配足够的内存。Widget的operator new就会返回指向被分配内存的指针。管理全局new-handler的对象的析构函数会自动恢复调用Widget的operator new之前的new-handler。</li>
</ol>
<p>这里我们以资源处理（resource-handling）类开始，只包含基本的RAII处理操作，包括在构造时获取资源和在在析构时释放资源（Item 13）:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class NewHandlerHolder &#123;</div><div class="line">public:</div><div class="line">explicit NewHandlerHolder(std::new_handler nh) // acquire current</div><div class="line">: handler(nh) &#123;&#125; // new-handler</div><div class="line"></div><div class="line">~NewHandlerHolder()                             // release it</div><div class="line"></div><div class="line">&#123; std::set_new_handler(handler); &#125;           </div><div class="line"></div><div class="line">private:                                                    </div><div class="line"></div><div class="line">std::new_handler handler;                             // remember it</div><div class="line"></div><div class="line">NewHandlerHolder(const NewHandlerHolder&amp;);      // prevent copying</div><div class="line"></div><div class="line">NewHandlerHolder&amp;                                   // ([see Item 14](http://www.cnblogs.com/harlanc/p/6414789.html "Item 14"))</div><div class="line"></div><div class="line">operator=(const NewHandlerHolder&amp;);     </div><div class="line"></div><div class="line">&#125;;         </div></pre></td></tr></table></figure>
<p> 这会使得Widget的operator new的实现非常简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void* Widget::operator new(std::size_t size) throw(std::bad_alloc)</div><div class="line">&#123;</div><div class="line">NewHandlerHolder // install Widget’s</div><div class="line">h(std::set_new_handler(currentHandler)); // new-handler</div><div class="line"></div><div class="line">return ::operator new(size);        // allocate memory</div><div class="line">// or throw</div><div class="line"></div><div class="line">&#125;                                                  // restore global</div><div class="line">// new-handler</div><div class="line"></div><div class="line">void outOfMem();                                 // decl. of func. to call if mem. alloc.</div><div class="line">// for Widget objects fails</div><div class="line"></div><div class="line">Widget::set_new_handler(outOfMem); // set outOfMem as Widget’s</div><div class="line">// new-handling function</div><div class="line"></div><div class="line">Widget *pw1 = new Widget;                 // if memory allocation</div><div class="line">// fails, call outOfMem</div><div class="line"></div><div class="line">std::string *ps = new std::string;           // if memory allocation fails,</div><div class="line">// call the global new-handling</div><div class="line">// function (if there is one)</div><div class="line"></div><div class="line">Widget::set_new_handler(0);                // set the Widget-specific</div><div class="line">// new-handling function to</div><div class="line">// nothing (i.e., null)</div><div class="line"></div><div class="line">Widget *pw2 = new Widget;                 // if mem. alloc. fails, throw an</div><div class="line">// exception immediately. (There is</div><div class="line">// no new- handling function for</div><div class="line">// class Widget.)</div></pre></td></tr></table></figure>
<h3 id="2-3-将NewHandlerHolder转换为模板"><a href="#2-3-将NewHandlerHolder转换为模板" class="headerlink" title="2.3 将NewHandlerHolder转换为模板"></a>2.3 将NewHandlerHolder转换为模板</h3><p>不管在什么类中，实现的这个主题的代码都是一样的，所以我们可以为其设一个合理的目标，就是代码能够在其他地方重用。达到这个目标的一个简单方法是创建一个“混合风格（mixin-style）”的基类，也就是设计一个基类，允许派生类继承单一特定的能力——在这个例子中，这种能力就是为类指定new-handler。然后将基类变为一个模板，于是你可以为每个继承类获得一份不同的类数据的拷贝。</p>
<p>这个设计的基类部分<strong>使得派生类能够继承它们都需要的**</strong>set_new_handler和operator new函数<strong>，同时设计的模板部分</strong>确保每个继承类获得一个不同的<strong>**currentHandler数据成员</strong>。说起来有些复杂，但是代码看上去很熟悉。事实上，唯一真正不一样的是现在任何类都能够获得这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt; // “mixin-style” base class for</div><div class="line">class NewHandlerSupport &#123; // class-specific set_new_handler</div><div class="line">public: // support</div><div class="line">static std::new_handler set_new_handler(std::new_handler p) throw();</div><div class="line">static void* operator new(std::size_t size) throw(std::bad_alloc);</div><div class="line">... // other versions of op. new —</div><div class="line">// see Item 52</div><div class="line">private:</div><div class="line">static std::new_handler currentHandler;</div><div class="line">&#125;;</div><div class="line">template&lt;typename T&gt;</div><div class="line">std::new_handler</div><div class="line">NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()</div><div class="line">&#123;</div><div class="line">std::new_handler oldHandler = currentHandler;</div><div class="line">currentHandler = p;</div><div class="line">return oldHandler;</div><div class="line">&#125;</div><div class="line">template&lt;typename T&gt;</div><div class="line">void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size)</div><div class="line">throw(std::bad_alloc)</div><div class="line">&#123;</div><div class="line">NewHandlerHolder h(std::set_new_handler(currentHandler));</div><div class="line">return ::operator new(size);</div><div class="line">&#125;</div><div class="line">// this initializes each currentHandler to null</div><div class="line">template&lt;typename T&gt;</div><div class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;</div></pre></td></tr></table></figure>
<p>有了这个类模板之后，向Widget中添加set_new_handler支持就变得容易了：Widget只需要继承自NewHandlerSupport<widget>。（这可能看上去比较独特，接下来我会进行详细的解释。）</widget></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Widget: public NewHandlerSupport&lt;Widget&gt; &#123;</div><div class="line">... // as before, but without declarations for</div><div class="line"></div><div class="line">&#125;;                             // set_new_handler or operator new</div></pre></td></tr></table></figure>
<p>这是Widget提供一个特定的set_new_handler需要做的所有事情。</p>
<p>但是对于Widget继承自NewHandlerSupport<widget>，你可能还是有些不安。如果是这样，当你注意到NewHandlerSupport模板永远不会使用类型参数T之后你的不安可能会加剧。你没有必要这样。对于每个继承自NewHandlerSupport的类来说，我们所有需要的是一份不同的NewHandlerSupport的拷贝——特别是静态数据成员currentHandler的不同拷贝。模板机制自身会为每个T自动生成currentHandler的一份拷贝，NewHandlerSupport使用这个T来进行实例化。</widget></p>
<p>对于Widget继承自一个使用Widget作为类型参数的模板基类来说，如果这个概念让你感觉眩晕，不要感觉不好。每个人看到开始看到它的时候都会有这种感觉。但是，它是非常有用的技术，它有一个名字，这个名字如果这个概念一样，第一次看到它的人没有人会感觉它很自然，它叫做怪异的循环模板模式（curiously<br>recurring template pattern CRTP）。</p>
<p>我曾经写过一遍文章建议为它起一个更好的名字：do it for me，因为当Widget继承自NewHandlerSupport<widget>，它真的像是在说：“我是Widget，我需要为Widget继承NewHandlerSupport类“。没有人使用我建议的名字，但是使用“do it for me”来想象一下CRTP可能会帮助你理解模板化的继承会做什么。</widget></p>
<p>有了像NewHandlerSupport这样的模板，为任何需要new-hadler的类添加一个特定的new-handler就会变得容易。混合风格的继承总是会将你引入多继承的主题，在开始进入这个主题之前，你可能想读一下<a href="http://www.cnblogs.com/harlanc/p/6641852.html" title="Item 40" target="_blank" rel="external">Item<br>40</a>。</p>
<h2 id="3-Nothrow版本的new"><a href="#3-Nothrow版本的new" class="headerlink" title="3. Nothrow版本的new"></a>3. Nothrow版本的new</h2><p>直到1993年，当不能满足分配内存的要求时，C++要求operator new要返回null。现在指定operator new要抛出bad_alloc异常，但是大量的C++是在编译器支持修订版本之前写出来的。C++标准委员会也不想废弃test-for-null的代码，所以它们为operator<br>new提供了一种替代形式，它能够提供传统的“失败产生null（failure-yields-null）”行为。这些形式被叫做“nothrow”形式，某种程度上是因为他们使用了不会抛出异常的对象（定义在头文件<new>中），new在这种情况下被使用：</new></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Widget &#123; ... &#125;;</div><div class="line">Widget *pw1 = new Widget;                        // throws bad_alloc if</div><div class="line">// allocation fails</div><div class="line"></div><div class="line">if (pw1 == 0) ...                                             // this test must fail</div><div class="line"></div><div class="line">Widget *pw2 = new (std::nothrow) Widget;   // returns 0 if allocation for</div><div class="line">// the Widget fails</div><div class="line"></div><div class="line">if (pw2 == 0) ...                                             // this test may succeed</div></pre></td></tr></table></figure>
<p>nothrow版本的new不会像从表面上看起来这样可靠，对于异常它没有提供让人信服的保证。对于表达式“new (std::nothrow) Widget”，会发生两件事情。首先，通过调用nothrow版本的operator<br>new来为一个Widget 对象分配足够的内存。如果分配失败了，operator<br>new会返回null指针。然而如果分配成功了，Widget构造函数会被调用，到这个时候，就会世事难料了。Widget构造函数能够做任何它想做的。它自己可能new一些内存，如果是这样，并没有强迫它使用nothrow版本的new。虽然在”new (std::nothrow) Widget”中的operator<br>new不会抛出异常，但是Widget构造函数却可能抛出来。如果是这样，异常会像平时一样传播出去。结论是什么？使用nothrow<br>new只能保证operator new不会抛出异常，不能保证像“new(std::nothrow)<br>Widget”这样的表达式不抛出异常。十有八九，你将永远不会有使用nothrow new的需要。</p>
<p>不论你是使用”普通的”（也就是抛出异常的）new还是nothrow版本的new，重要的是你需要明白new-handler的行为，因为在两种new中都会使用到它。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul>
<li>Set_new_handler允许你在分配内存不能满足要求的时候指定一个特定的被调用的函数。</li>
<li>Nothrow new功能有限，因为它只能被应用在内存分配上；相关联的构造函数调用可能仍然会抛出异常。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-new-handler介绍&quot;&gt;&lt;a href=&quot;#1-new-handler介绍&quot; class=&quot;headerlink&quot; title=&quot;1. new-handler介绍&quot;&gt;&lt;/a&gt;1. new-handler介绍&lt;/h2&gt;&lt;p&gt;当操作符new不能满足内存分配请求的时候，它就会抛出异常。很久之前，它会返回一个null指针，一些旧的编译器仍然会这么做。你仍然会看到这种旧行为，但是我会把关于它的讨论推迟到本条款结束的时候。&lt;/p&gt;
&lt;h3 id=&quot;1-1-调用set-new-handle&quot;&gt;&lt;a href=&quot;#1-1-调用set-new-handle&quot; class=&quot;headerlink&quot; title=&quot;1.1 调用set_new_handle&quot;&gt;&lt;/a&gt;1.1 调用set_new_handle&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 48  了解模板元编程</title>
    <link href="http://yoursite.com/2017/04/15/2017-04-15_12_54_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_48__%E4%BA%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/04/15/2017-04-15_12_54_读书笔记_effective_c++_Item_48__了解模板元编程/</id>
    <published>2017-04-15T04:54:00.000Z</published>
    <updated>2017-05-20T10:40:57.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-TMP是什么？"><a href="#1-TMP是什么？" class="headerlink" title="1. TMP是什么？"></a>1. TMP是什么？</h2><p><strong>模板元编程（template metaprogramming TMP**</strong>）是实现基于模板的C++<strong>**程序的过程，它能够在编译期执行</strong>。你可以想一想：一个模板元程序是用C++实现的并且可以在C++编译器内部运行的一个程序，它的输出——从模板中实例化出来的C++源码<br><a id="more"></a><br>段——会像往常一样被编译。</p>
<h2 id="2-使用TMP的优势"><a href="#2-使用TMP的优势" class="headerlink" title="2. 使用TMP的优势"></a>2. 使用TMP的优势</h2><p>如果这没有冲击到你，是因为你没有足够尽力去想。</p>
<p>C++不是为了模板元编程而设计的，但是自从TMP早在1990年被发现之后，它就被证明是非常有用的，为了使TMP的使用更加容易，在C++语言和标准库中加入了一些扩展。是的，TMP是被发现的，而不是被发明。当模板被添加到C++中的时候TMP这个特性就被引入了。对于某些人来说所有需要做的就是关注如何以一种聪明的和意想不到的方式来使用它。</p>
<p>TMP有两种强大的力量。<strong>第一，它使得一些事情变得容易</strong>，<strong>也即是说如果没有**</strong>TMP<strong>**，这些事情做起来很难或者不可能实现</strong>。<strong>第二，因为模板元编程在**</strong>C++<strong>**编译期执行，它们可以将一些工作从运行时移动到编译期</strong>。一个结果就是一些原来通常在运行时能够被发现的错误，现在在编译期就能够被发现了。另外一个结果就是使用TMP的C++程序在基本上每个方面都更加高效：<strong>更小的执行体，更短的运行时间，更少的内存需求</strong>。（然而，将工作从运行时移到编译期的一个后果就是<strong>编译时间增加</strong>了。使用TMP的程序比没有使用TMP的程序可能消耗更长的时间来进行编译。）</p>
<h2 id="3-如何使用TMP？"><a href="#3-如何使用TMP？" class="headerlink" title="3. 如何使用TMP？"></a>3. 如何使用TMP？</h2><h3 id="3-1-再次分析Item-47中的实例"><a href="#3-1-再次分析Item-47中的实例" class="headerlink" title="3.1 再次分析Item 47中的实例"></a>3.1 再次分析<a href="http://www.cnblogs.com/harlanc/p/6702242.html" title="Item 47" target="_blank" rel="external">Item 47</a>中的实例</h3><p>考虑在<a href="http://www.cnblogs.com/harlanc/p/6702242.html" title="Item 47" target="_blank" rel="external">Item 47</a>中为STL的advance写出来的伪代码。我已经为伪代码部分做了粗体：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT, typename DistT&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span>(<span class="params">IterT&amp; iter, DistT d</span>)</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (iter <span class="keyword">is</span> a random access iterator) &#123;</div><div class="line"></div><div class="line">iter += d;                           <span class="comment">// use iterator arithmetic</span></div><div class="line"></div><div class="line">&#125;                                        <span class="comment">// for random access iters</span></div><div class="line"></div><div class="line"><span class="keyword">else</span> &#123;                                </div><div class="line"></div><div class="line"><span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125; <span class="comment">// use iterative calls to</span></div><div class="line"><span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125; <span class="comment">// ++ or -- for other</span></div><div class="line">&#125; <span class="comment">// iterator categories</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以使用typeid替换伪代码，让程序能够执行。这就产生了一个“普通的”C++方法——也就是所有工作都在运行时开展的方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT, typename DistT&gt;</div><div class="line">void advance(IterT&amp; iter, DistT d)</div><div class="line">&#123;</div><div class="line">if ( typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category) ==</div><div class="line">typeid(std::random_access_iterator_tag)) &#123;</div><div class="line"></div><div class="line">iter += d;                           // use iterator arithmetic</div><div class="line"></div><div class="line">&#125;                                        // for random access iters</div><div class="line"></div><div class="line">else &#123;                               </div><div class="line"></div><div class="line">if (d &gt;= 0) &#123; while (d--) ++iter; &#125; // use iterative calls to</div><div class="line">else &#123; while (d++) --iter; &#125; // ++ or -- for other</div><div class="line">&#125; // iterator categories</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/harlanc/p/6702242.html" title="Item 47" target="_blank" rel="external">Item 47</a>指出这种基于typeid的方法比使用trait效率更低，因为通过使用这种方法，（1）<strong>类型测试发生在运行时而不是编译期</strong>（2）<strong>执行运行时类型测试的代码在运行的时候必须可见</strong>。事实上，这个例子也展示出了为什么TMP比一个“普通的”C++程序更加高效，因为traits方式属于TMP。记住，trait使得在类型上进行编译期if…else运算成为可能。</p>
<p>我已经在前面提到过一些东西说明其在TMP中比在“普通”C++中更加容易，Item 47中也提供了一个advance的例子。Item 47中提到了advance的基于typeid的实现会导致编译问题，看下面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">std::list&lt;int&gt;::iterator iter;</div><div class="line">...</div><div class="line">advance(iter, 10);               // move iter 10 elements forward;</div><div class="line">// won’t compile with above impl.</div></pre></td></tr></table></figure>
<p>考虑为上面调用所产生的advance的版本，将模板参数IterT和DistT替换为iter和10的类型之后，我们得到下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> void advance(std::list&lt;int&gt;::iterator&amp; iter, int d)</div><div class="line"> &#123;</div><div class="line"> if (typeid(std::iterator_traits&lt;std::list&lt;int&gt;::iterator&gt;::iterator_category) ==</div><div class="line"> typeid(std::random_access_iterator_tag)) &#123;</div><div class="line"></div><div class="line"> **iter += d;</div><div class="line">** </div><div class="line"> // error! won’t compile</div><div class="line"></div><div class="line"> &#125;</div><div class="line"> else &#123;</div><div class="line"> if (d &gt;= 0) &#123; while (d--) ++iter; &#125;</div><div class="line"> else &#123; while (d++) --iter; &#125;</div><div class="line"> &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>有问题的是高亮部分，就是使用+=的语句。在这个例子中，我们在list<int>::iterator上使用+=，但是list<int>::iterator是一个双向迭代器（见Item 47），所以它不支持+=。只有随机访问迭代器支持+=。现在，我们知道了+=这一行将永远不会被执行到，因为为list<int>::iteraotr执行的typeid测试永远都不会为真，<strong>但是编译器有责任确保所有的源码都是有效的，即使不被执行到</strong>，当iter不是随机访问迭代器“iter+=d”就是无效代码。将它同基于tratis的TMP解决方案进行比较，后者把为不同类型实现的代码分别放到了不同的函数中，每个函数中进行的操作只针对特定的类型。</int></int></int></p>
<h3 id="3-2-TMP是图灵完全的"><a href="#3-2-TMP是图灵完全的" class="headerlink" title="3.2 TMP是图灵完全的"></a>3.2 TMP是图灵完全的</h3><p>TMP已经被证明是图灵完全的（Turing-Complete），这也就意味着它足够强大到可以计算任何东西。使用TMP，你可以声明变量，执行循环，实现和调用函数等等。但是这些概念同“普通”C++相对应的部分看起来非常不同。例如，Item 47中if…else条件在TMP中是如何通过使用模板和模板特化来表现的。但这是程序级别（assembly-level）的TMP。TMP库（例如，Boost MPL，见Item 55）提供了更高级别的语法，这些语法不会让你误认为是“普通的”C++。</p>
<h3 id="3-3-TMP中的循环通过递归来实现"><a href="#3-3-TMP中的循环通过递归来实现" class="headerlink" title="3.3 TMP中的循环通过递归来实现"></a>3.3 TMP中的循环通过递归来实现</h3><p>再瞥一眼事情在TMP中是如何工作的，让我们看一下循环。TMP中没有真正的循环的概念，所以循环的效果是通过递归来完成的。（如果一提到递归你就不舒服，在进入TMP 冒险之前你就需要处理好它。TMP主要是一个函数式语言，递归对于函数式语言就如同电视对美国流行文化一样重要：它们是不可分割的。）即使是递归也不是普通的递归，因为TMP循环没有涉及到递归函数调用，所涉及到的是递归模板实例化（template instantiations）。</p>
<p>TMP的“hello world”程序是在编译期计算阶乘。它算不上是令人激动的程序，“hello world”也不是，但是这两个例子对于介绍语言都是有帮助的。TMP阶乘计算通过对模板实例进行递归来对循环进行示范。也同样示范了变量是如何在TMP中被创建和使用的，看下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;unsigned n&gt;          // general case: the value of</div><div class="line"></div><div class="line">struct Factorial &#123;                   // Factorial&lt;n&gt; is n times the value</div><div class="line"></div><div class="line">// of Factorial&lt;n-1&gt;</div><div class="line">enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;;</div><div class="line">&#125;;</div><div class="line">template&lt;&gt; // special case: the value of</div><div class="line">struct Factorial&lt;0&gt; &#123; // Factorial&lt;0&gt; is 1</div><div class="line">enum &#123; value = 1 &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>考虑上面的模板元编程（真的仅仅是单一的元函数Factorial），你通过引用Factorial<n>::value来得到factorial(n)的值。</n></p>
<p>代码的循环部分发生在模板实例Factorial<n>引用模板实例Factorial<n-1>的时候。像所有递归一样，有一种特殊情况来让递归终止。在这里是模板特化Factorial<0>。</0></n-1></n></p>
<p>每个Factorial模板的实例都是一个结构体，每个结构体使用enum hack（<a href="http://www.cnblogs.com/harlanc/p/6376536.html" title="Item 2" target="_blank" rel="external">Item 2</a>）来声明一个叫做value的TMP变量。Value持有递归计算的当前值。如果TMP有一个真正的循环结构，value将会每次循环的时候进行更新。既然TMP使用递归模板实例来替换循环，每个实例会得到它自己的value的拷贝，每个拷贝都会有一个和“循环”中位置想对应的合适的值。</p>
<p>你可以像下面这样使用Facorial：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">std::cout &lt;&lt; Factorial&lt;5&gt;::value; // prints 120</div><div class="line"></div><div class="line">std::cout &lt;&lt; Factorial&lt;10&gt;::value;       // prints 3628800</div><div class="line"></div><div class="line">&#125;        </div></pre></td></tr></table></figure>
<p> 如果你认为这比冰激凌更酷，你就已经获得模板元程序员需要的素材。如果模板和特化，递归实例和enum hacks,还有像Factorial<n-1>::value这样的输入使你毛骨悚然，你还是一个“普通的”C++程序员。</n-1></p>
<h3 id="3-4-TMP还能够做什么？"><a href="#3-4-TMP还能够做什么？" class="headerlink" title="3.4 TMP还能够做什么？"></a>3.4 TMP还能够做什么？</h3><p>当然，Factorial对TMP的功能进行了示范，如同“hello world”程序对任何传统编程语言的功能进行示范一样。为了让你明白为什么TMP是值得了解的，知道它能够做什么很重要，这里有三个例子：</p>
<ul>
<li>确保因次单位（dimensional unit）的正确性。在科学和工程应用中，把因次单位（例如，质量，距离和时间）正确的拼到一起是很必要的。将表示质量的变量赋值给表示速度的变量是错误的，但是用距离变量除以时间变量然后将结果赋值被速度变量就没有问题。通过使用TMP，确保（在编译期间）程序中的所有因次单元组合的正确性就是可能的，不管计算有多复杂。（这也是使用TMP来侦测早期错误的一个例子。）TMP这种用法的一个有趣的方面是它能够支持分数因次的指数。这需要在编译期间将分数简化，然后编译器才能够确认，例如，单元 time1/2同time4/8是相同的。</li>
<li>优化矩阵操作。<a href="http://www.cnblogs.com/harlanc/p/6445461.html" title="Item 21" target="_blank" rel="external">Item 21</a>中解释了有一些函数（包括 operator*）必须返回新的对象，<a href="http://www.cnblogs.com/harlanc/p/6680216.html" title="Item 44" target="_blank" rel="external">Item 44</a>中引入了SquareMatrix类，考虑下面的代码：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1</span> typedef SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10000</span>&gt; BigMatrix;</div><div class="line"><span class="number">2</span> BigMatrix m1, m2, m3, m4, m5; <span class="comment">// create matrices and</span></div><div class="line"><span class="number">3</span> ... <span class="comment">// give them values</span></div><div class="line"><span class="number">4</span> BigMatrix result = m1 * m2 * m3 * m4 * m5; <span class="comment">// compute their product</span></div></pre></td></tr></table></figure>
<p> 用“普通的”方式来计算result会有四次创建临时matrice对象的调用，每次调用都应用在对operator*调用的返回值上面。这些独立的乘法在矩阵元素上产生了四          次循环。使用TMP的高级模板技术——表达式模板（expression templates），来消除临时对象以及合并循环是有可能的，并且不用修改上面的客户端代码的语法。最   后的程序使用了更少的内存，而且运行速度会有很大的提升。</p>
<ul>
<li>产生个性化的设计模式实现。像策略模式，观察者模式，访问者模式等等这些设计模式能够以很多方式被实现。使用基于模板的技术被叫做policy-based设计，我们可以创建表示独立设计选择（choice或者叫”policies”）的 模板，这些模板可以以任意的方式进行组合来产生个性化的模式实现。例如，使用这种技术能够创建一些实现智能指针行为策略（policies）的模板,使用它能够产生（在编译期）上百种不同的智能指针类型。这项技术已经超越了编程工艺领域，如设计模式和智能指针，它成为了生殖编程（generative programming）的基础。</li>
</ul>
<h2 id="4-TMP现状分析"><a href="#4-TMP现状分析" class="headerlink" title="4. TMP现状分析"></a>4. TMP现状分析</h2><p>TMP并不是为每个人准备的。因为语法不直观，支持的相关工具也很弱。（像为模板元编程提供的调试器。）作为一个“突然性“的语言它只是最近才被发现的，TMP编程的一些约定正在实验阶段。然而通过将工作从运行时移到编译期所带来的效率提升带给人很深刻的印象，对一些行为表达的能力（很难或者不可能在运行时实现）也是很吸引人的。</p>
<p>对于TMP的支持正在上升期。很可能下个版本的C++就是显示的支持它。TR1中已经支持了（Item 54）。关于这个主题的书籍已经开始出来了，网上的一些关于TMP信息也越来越多。TMP可能永远不会成为主流，但是对于一些程序员来说——尤其是程序库的实现者——几乎必然会成为主要手段。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul>
<li>模板元编程可以将工作从运行时移到编译期，这样可以更早的发现错误，并且提高运行时性能。</li>
<li>基于策略选择（policy choices）的组合TMP能够被用来产生个性化的代码，也能够用来防止为特定类型生成不合适的代码。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-TMP是什么？&quot;&gt;&lt;a href=&quot;#1-TMP是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. TMP是什么？&quot;&gt;&lt;/a&gt;1. TMP是什么？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;模板元编程（template metaprogramming TMP**&lt;/strong&gt;）是实现基于模板的C++&lt;strong&gt;**程序的过程，它能够在编译期执行&lt;/strong&gt;。你可以想一想：一个模板元程序是用C++实现的并且可以在C++编译器内部运行的一个程序，它的输出——从模板中实例化出来的C++源码&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 47 使用traits class表示类型信息</title>
    <link href="http://yoursite.com/2017/04/13/2017-04-13_08_40_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_47_%E4%BD%BF%E7%94%A8traits_class%E8%A1%A8%E7%A4%BA%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2017/04/13/2017-04-13_08_40_读书笔记_effective_c++_Item_47_使用traits_class表示类型信息/</id>
    <published>2017-04-13T00:40:00.000Z</published>
    <updated>2017-05-20T10:40:57.289Z</updated>
    
    <content type="html"><![CDATA[<p>STL主要由为容器，迭代器和算法创建的模板组成，但是也有一些功能模板。其中之一叫做advance。Advance将一个指定的迭代器移动指定的距离：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> template&lt;typename IterT, typename Dis</div><div class="line">&lt;!--more--&gt;</div><div class="line">T&gt; <span class="comment">// move iter d units</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">advance</span>(<span class="params">IterT&amp; iter, DistT d</span>)</span>; <span class="comment">// forward; if d &lt; 0,</span></div><div class="line"> <span class="comment">// move iter backward</span></div></pre></td></tr></table></figure>
<p>从概念上来说，advance仅仅做了iter += d，但是advance并不是用这种方式实现的，因为只有随机访问迭代器支持+=操作。其他一些更加弱的迭代器类型必须通过反复的++或者–d次来实现advance。</p>
<h2 id="1-五种迭代器种类回顾"><a href="#1-五种迭代器种类回顾" class="headerlink" title="1. 五种迭代器种类回顾"></a>1. 五种迭代器种类回顾</h2><p>你不记得STL迭代器的种类了？没问题，我们现在做一些简单的回顾。总共有5类迭代器，对应着它们支持的五种操作。<strong>输入迭代器（**</strong>input iterator<strong>**）</strong>只能向前移动，一次只能移动一步，只能读取它们指向的内容，并且只能读一次。这种迭代器模拟的是输入文件的读指针；C++库的istream_iterator是这种迭代器的代表。<strong>输出迭代器（**</strong>output<br>iterator<strong>**）</strong>同输入迭代器类似，但是对于输出迭代器来说：它们只能向前移动，每次只能移动一步，只能对它们指向的内存进行写操作，并且只能写一次。它们模拟的是输出文件的写指针；ostream_iterator代表了这种迭代器。这是两类功能最弱的迭代器。因为输入和输出迭代器只能向前移动，只能对它们所指向的内容进行读写最多一次，它们只能为one-pass算法所使用。</p>
<p>一个更加强大的迭代器种类由<strong>前向迭代器（**</strong>forward<br>iterator<strong>**）</strong>组成。这种迭代器能做输入和输出迭代器能做的所有事情，并且它们能对它们指向的内容进行多次的读写。这就使得它们能被multi-pass算法所使用。STL没有提供单链表，但是一些库却提供了（通常叫做slist），这种容器中的迭代器为前向迭代器。TR1中的哈希容器（Item 54）迭代器也可能是前向迭代器。</p>
<p><strong>双向迭代器（**</strong>bidirectional<br>iterators<strong>**）</strong>和前向迭代器相比添加了向后移动的能力。为STL中的list提供的迭代器就属于这种类别，为set,multiset，map和multimap提供的迭代器也是这种类别。</p>
<p>最强大的迭代器类别叫做<strong>随机访问迭代器（**</strong>random<br>access iterator<strong>**）</strong>。这种类型的迭代器和双向迭代器相比添加了执行“迭代器运算（iterator arithmetic）”的能力，也就是在常量时间内向前或者向后跳跃任意的距离。这种运算同指针运算类似，不要吃惊，因为随机访问迭代器模拟的就是内建类型的指针，内建类型指针的行为表现就如同随机访问迭代器。Vector,deque和string迭代器都是随机访问迭代器。</p>
<p>为了识别这五种迭代器类型，C++在标准库中为五种迭代器类型提供了一个“tag结构体”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> output_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> forward_iterator_tag: <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> bidirectional_iterator_tag: <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</div><div class="line"><span class="keyword">struct</span> random_access_iterator_tag: <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</div></pre></td></tr></table></figure>
<p>这些结构体之间的继承关系是有效的“is-a”关系（<a href="http://www.cnblogs.com/harlanc/p/6551155.html" title="Item 32" target="_blank" rel="external">Item32</a>）：所有的前向迭代器同样是输入迭代器，等等。我们很快会看到这种继承的效用。</p>
<h2 id="2-如何实现advance简析"><a href="#2-如何实现advance简析" class="headerlink" title="2. 如何实现advance简析"></a>2. 如何实现advance简析</h2><p>回到advance。考虑到不同的迭代器功能，实现advance的一种方法是使用循环的最小公分母策略：<strong>对迭代器进行反复加或者减</strong>。然而，这个方法会花费<strong>线性的时间</strong>。随机访问迭代器支持<strong>常量时间</strong>的迭代器算法，在我们需要的时候会使用它的这种能力。</p>
<p>我们真正想要的是像下面这样去实现advance:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT, typename DistT&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span>(<span class="params">IterT&amp; iter, DistT d</span>)</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (iter <span class="keyword">is</span> a random access iterator) &#123;</div><div class="line"></div><div class="line">iter += d;                           <span class="comment">// use iterator arithmetic</span></div><div class="line"></div><div class="line">&#125;                                        <span class="comment">// for random access iters</span></div><div class="line"></div><div class="line"><span class="keyword">else</span> &#123;                                </div><div class="line"></div><div class="line"><span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125; <span class="comment">// use iterative calls to</span></div><div class="line"><span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125; <span class="comment">// ++ or -- for other</span></div><div class="line">&#125; <span class="comment">// iterator categories</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这需要决定iter是不是一个随机访问迭代器，也就是需要知道它的类型，IterT，是不是随机访问迭代器类型。换句话说，我们需要获取一个类型的相关信息。这也是trait让你所做的：<strong>它们允许你在编译期间获取一个类型的相关信息</strong>。</p>
<h2 id="3-Traits技术分析"><a href="#3-Traits技术分析" class="headerlink" title="3. Traits技术分析"></a>3. Traits技术分析</h2><h3 id="3-1-使用traits技术的要求"><a href="#3-1-使用traits技术的要求" class="headerlink" title="3.1 使用traits技术的要求"></a>3.1 使用traits技术的要求</h3><p>Traits不是C++中的关键字或者一个预定义的概念；它们是一种技术，也是一个C++程序员需要遵守的约定。<strong>使用这项技术的一个要求是它必须使内建类型同用户自定义类型一样能够很好的工作</strong>。例如，如果advance的入参为一个指针（像const<br>char*）和一个Int,advance必须能够工作，但是这就意味着trait技术必须能够使用在像指针一样的内建类型上。</p>
<p>Traits必须能够同内建类型一块工作就意味着不能在类型内部嵌入一些信息，因为没有方法在指针内部嵌入信息。于是对于一种类型的traits信息，必须是放在类型外部的。标准的技术是将其放在模板和模板的一个或多个特化实例中。对于迭代器来说，标准库中的模板被命名为iterator_traits:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT&gt; <span class="comment">// template for information about</span></div><div class="line"><span class="keyword">struct</span> iterator_traits; <span class="comment">// iterator types</span></div></pre></td></tr></table></figure>
<p>正如你所见的，iterator_traits是一个结构体。按照惯例，traits经常被实现为一个结构体。另外一种常用手法是将实现traits的结构体替换为traits class(这不是我说的)。</p>
<p>Iterator_traits的工作方式是对于每个类型IterT，在结构体iterator_traits<itert>中声明一个叫做iterator_category的typedef。这个typedef唯一确认了IterT的迭代器类别。</itert></p>
<h3 id="3-2-实现traits-class需要处理用户自定义类型"><a href="#3-2-实现traits-class需要处理用户自定义类型" class="headerlink" title="3.2 实现traits class需要处理用户自定义类型"></a>3.2 实现traits class需要处理用户自定义类型</h3><p>Iterator_traits会在两部分中实现它。首先，它强制任何用户自定义的迭代器类型必须包含一个叫做iterator_category的内嵌typedef，它能够识别合适的tag结构体。举个例子，deque的迭代器是随机访问的，因此一个deque迭代器的类会像是下面这个样子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template &lt; ... &gt;                                                                         <span class="comment">// template params elided</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">deque</span> &#123;                                                                           </div><div class="line"></div><div class="line"><span class="keyword">public</span>:                                                                                    </div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">iterator</span> &#123;                                                                        </div><div class="line"></div><div class="line"><span class="keyword">public</span>:                                                                                    </div><div class="line"></div><div class="line">typedef random_access_iterator_tag iterator_category;          </div><div class="line"></div><div class="line">...                                                                                             </div><div class="line"></div><div class="line">&#125;;                                                                                            </div><div class="line"></div><div class="line">...                                                                                             </div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>List的迭代器是双向的，所以用下面的方式处理：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template &lt; ... &gt;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">list</span> &#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">typedef bidirectional_iterator_tag iterator_category;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> iterator_traits只是重复使用iterator类的内嵌typedef:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// the iterator_category for type IterT is whatever IterT says it is;</div><div class="line"></div><div class="line">// see [Item 42](http://www.cnblogs.com/harlanc/p/6661228.html "Item 42") for info on the use of “typedef typename”</div><div class="line"></div><div class="line">template&lt;typename IterT&gt;</div><div class="line"></div><div class="line">struct iterator_traits &#123;</div><div class="line"></div><div class="line">typedef typename IterT::iterator_category iterator_category;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="3-3-实现traits-class需要处理指针类型"><a href="#3-3-实现traits-class需要处理指针类型" class="headerlink" title="3.3 实现traits class需要处理指针类型"></a>3.3 实现traits class需要处理指针类型</h3><p>这对用户自定义类型来说会工作的很好，但是对于指针迭代器来说就不工作了，因为指针中没有内嵌的typedef。Iterator_trait实现的第二部分需要处理指针迭代器。</p>
<p>为了支持这种迭代器，iterator_traits为指针类型提供了一种部分模板特化（partial template specialization）。指针的行为表现同随机访问迭代器类似，所以iterator_trait为它们指定了随机访问类别：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt; <span class="comment">// partial template specialization</span></div><div class="line"><span class="keyword">struct</span> iterator_traits&lt;T*&gt; <span class="comment">// for built-in pointer types</span></div><div class="line">&#123;</div><div class="line">typedef random_access_iterator_tag iterator_category;</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="3-4-实现traits-class总结"><a href="#3-4-实现traits-class总结" class="headerlink" title="3.4 实现traits class总结"></a>3.4 实现traits class总结</h3><p>到现在你应该了解了如何设计和实现一个traits class：</p>
<ul>
<li>确认你想要支持的类型的一些信息(例如，对于迭代器来说，它们的迭代器类别)。</li>
<li>为了确认信息，你需要选择一个名字（例如，iterator_category）</li>
<li>为你想支持的类型提供包含相关信息的一个模板和一些特化（例如，iterator_traits）</li>
</ul>
<h2 id="4-使用traits"><a href="#4-使用traits" class="headerlink" title="4. 使用traits"></a>4. 使用traits</h2><p>class实现advance</p>
<h3 id="4-1-类别判断不应该在运行时进行"><a href="#4-1-类别判断不应该在运行时进行" class="headerlink" title="4.1 类别判断不应该在运行时进行"></a>4.1 类别判断不应该在运行时进行</h3><p>考虑iterator_traits——实际上是std::iterator_traits，既然它是C++标准库的一部分——我们能为advance的实现精炼成我们自己的伪代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT, typename DistT&gt;</div><div class="line">void advance(IterT&amp; iter, DistT d)</div><div class="line">&#123;</div><div class="line">if (typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category) ==</div><div class="line">typeid(std::random_access_iterator_tag))</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这看上去很有希望，但它不会如我们所愿。第一，它会导致编译问题，这个问题我们将在Item 48研究；现在，有更加基本的问题需要考虑。IterT的类型在编译期被确认，所以iterator_traits<itert>::iterator_category同样能够在编译期被确定。但是if语句会在运行时被评估（除非你的优化器足够疯狂，把if语句去掉）。为什么将本来可以在编译期做的事情挪到运行时去做呢？它会浪费时间，并且会造成执行代码膨胀。</itert></p>
<h3 id="4-2-将条件评估提前到编译期——使用重载"><a href="#4-2-将条件评估提前到编译期——使用重载" class="headerlink" title="4.2 将条件评估提前到编译期——使用重载"></a>4.2 将条件评估提前到编译期——使用重载</h3><p>我们真正想要的是为类型提供一个能够在编译期进行评估的条件结构（也就是一个if…else语句）。C++已经有一种方法来实现这种行为。她叫做<strong>重载</strong>。</p>
<p>当你重载某个函数f的时候，你为不同的重载函数指定不同的参数类型。当你调用f时，编译器会根据你所传递的参数选择最佳匹配重载函数。编译器会说：“如果这个重载对于传递过来的参数来说是最佳匹配，那么调用这个f；如果另外一个重载函数是最佳匹配，那么调用另外一个函数；如果第三个函数是最佳匹配，调用第三个”等等，看到了么？这是一个与类型相关的编译期条件结构。为了让advance表现出我们想要的行为，所有我们必须要做的是创建一个重载函数的多个版本，它们包含了advance的“内脏”，每个函数都带有一个不同类型的iterator_category对象。我将这些函数命名为doAdvance：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT, typename DistT&gt; // use this impl for</div><div class="line">void doAdvance(IterT&amp; iter, DistT d, // random access</div><div class="line">std::random_access_iterator_tag) // iterators</div><div class="line">&#123;</div><div class="line">iter += d;</div><div class="line">&#125;</div><div class="line">template&lt;typename IterT, typename DistT&gt; // use this impl for</div><div class="line">void doAdvance(IterT&amp; iter, DistT d, // bidirectional</div><div class="line">std::bidirectional_iterator_tag) // iterators</div><div class="line">&#123;</div><div class="line">if (d &gt;= 0) &#123; while (d--) ++iter; &#125;</div><div class="line">else &#123; while (d++) --iter; &#125;</div><div class="line">&#125;</div><div class="line">template&lt;typename IterT, typename DistT&gt; // use this impl for</div><div class="line">void doAdvance(IterT&amp; iter, DistT d, // input iterators</div><div class="line">std::input_iterator_tag)</div><div class="line">&#123;</div><div class="line">if (d &lt; 0 ) &#123;</div><div class="line">throw std::out_of_range("Negative distance"); // see below</div><div class="line">&#125;</div><div class="line">while (d--) ++iter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为forward_iterator_tag继承自input_iterator_tag，为input_iterator_tag提供的doAdvance版本同样能够处理forward迭代器。这是在不同iterator_tag结构体之间引入继承的动机。（事实上，这也是所有的使用public继承的动机：为基类类型实现的代码对于派生类类型来说同样适用。）</p>
<p>对于随机访问迭代器和双向迭代器来说，advance的特化版本同时能够做正向或者负向的移动，但是对于forward迭代器或者input迭代器来说，如果你想进行一个负向的移动就会出现未定义行为。实现中如果简单的假设d是非负的，当传递一个负参数时，你就会进入一个很长的循环中，直到d变为0为止。在上面的代码中，我所使用的替代方法是抛出一个异常。两种实现都是有效的。这就是未定义行为的诅咒：你不能预测出来会发成什么。  </p>
<p>考虑为doAdvance所重载的不同版本，所有advance需要做的就是调用它们，传递一个额外的合适的迭代器类别对象，最后编译器就能够使用重载方案来调用合适的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT, typename DistT&gt;</div><div class="line">void advance(IterT&amp; iter, DistT d)</div><div class="line">&#123;</div><div class="line">doAdvance( // call the version</div><div class="line">iter, d, // of doAdvance</div><div class="line">typename // that is</div><div class="line">std::iterator_traits&lt;IterT&gt;::iterator_category() // appropriate for</div><div class="line">); // iter’s iterator</div><div class="line"></div><div class="line">&#125;                                                                                  // category</div></pre></td></tr></table></figure>
<h2 id="5-traits-class使用总结"><a href="#5-traits-class使用总结" class="headerlink" title="5. traits class使用总结"></a>5. traits class使用总结</h2><p>我们可以总结一下如何使用traits class:</p>
<ul>
<li>创建一系列重载的”worker”函数或者函数模板（例如，doAdvance），通过使用traits 参数来进行区分。根据传递的traits信息来对应的实现每个函数。</li>
<li>创建一个“master”函数或者函数模板（例如，advance）来调用worker，将traits class提供的信息传递进去。</li>
</ul>
<p>Traits被广泛使用在标准库中。对于iterator_traits来说，除了iterator_category，还为迭代器提供了四种其它的信息（最有用的就是value_type—<a href="http://www.cnblogs.com/harlanc/p/6661228.html" title="Item 42" target="_blank" rel="external">Item 42</a>中给出了一个例子。）还有char_traits，存储了字符类型的信息，numeric_limits,提供数字类型信息，例如，它们能够表示的最大和最小值等等。（numeric_limits这个名字可能让你感到意外，因为传统的命名方式是以“traits”结尾，但是numeric_limits没有遵守。）</p>
<p>TR1（Item 54）为了为类型提供信息引入了大量的新的traits class，包括is_fundamental<t>(判断T是否为内建类型)，is_array<t>(判断T是否为数组)，和is_base_of<t1,t2>（判断T1和T2是否相同或者是T2的基类）。TR1向标准C++中添加了大概有50个traits classes。</t1,t2></t></t></p>
<h2 id="6-本条款总结"><a href="#6-本条款总结" class="headerlink" title="6. 本条款总结"></a>6. 本条款总结</h2><ul>
<li>Traits classes使得在编译期就能够获得类型信息。它们用模板和模板特化版本来进行实现。</li>
<li>利用重载，traits classes使得在类型上执行编译期if-else测试成为可能。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL主要由为容器，迭代器和算法创建的模板组成，但是也有一些功能模板。其中之一叫做advance。Advance将一个指定的迭代器移动指定的距离：&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 46 如果想进行类型转换，在模板内部定义非成员函数</title>
    <link href="http://yoursite.com/2017/04/11/2017-04-11_08_38_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_46_%E5%A6%82%E6%9E%9C%E6%83%B3%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%9C%A8%E6%A8%A1%E6%9D%BF%E5%86%85%E9%83%A8%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/04/11/2017-04-11_08_38_读书笔记_effective_c++_Item_46_如果想进行类型转换，在模板内部定义非成员函数/</id>
    <published>2017-04-11T00:38:00.000Z</published>
    <updated>2017-05-20T10:40:57.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题的引入——将operator-模板化"><a href="#1-问题的引入——将operator-模板化" class="headerlink" title="1. 问题的引入——将operator*模板化"></a>1. 问题的引入——将operator*模板化</h2><p><a href="http://www.cnblogs.com/harlanc/p/6482417.html" title="Item 24" target="_blank" rel="external">Item 24</a>中解释了为什么对于所有参数的隐式类型转换，只有非成员函数是合格的，并且使用了一个为Rati<br><a id="more"></a><br>nal 类创建的operator<em>函数作为实例。在继续之前建议你先回顾一下这个例子，因为这个条款的讨论是对它的扩展，我们会对<a href="http://www.cnblogs.com/harlanc/p/6482417.html" title="Item 24" target="_blank" rel="external">Item 24</a>的实例做一些看上去无伤大雅的修改：对Rational和opeartor</em>同时进行模板化：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>, <span class="comment">// see [Item 20](http://www.cnblogs.com/harlanc/p/6440868.html "Item 20") for why params</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);         <span class="comment">// are now passed by reference</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> T <span class="title">numerator</span>(<span class="params"></span>) <span class="keyword">const</span></span>;          <span class="comment">// see [Item 28](http://www.cnblogs.com/harlanc/p/6512595.html "Item 28") for why return</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> T <span class="title">denominator</span>(<span class="params"></span>) <span class="keyword">const</span></span>; <span class="comment">// values are still passed by value,</span></div><div class="line">... <span class="comment">//[ Item 3](http://www.cnblogs.com/harlanc/p/6384546.html "Item 3") for why they’re const</span></div><div class="line">&#125;;</div><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</div><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>正如<a href="http://www.cnblogs.com/harlanc/p/6482417.html" title="Item 24" target="_blank" rel="external">Item 24</a>中讨论的，我们想支持混合模式的算术运算，所以我们想让下面的代码通过编译。这应该没有问题，因为我们在<a href="http://www.cnblogs.com/harlanc/p/6482417.html" title="Item 24" target="_blank" rel="external">Item 24</a>中使用了相同的代码。唯一的区别是Rational和operator*现在变成了模板：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Rational&lt;<span class="keyword">int</span>&gt; <span class="title">oneHalf</span>(<span class="params"><span class="number">1</span>, <span class="number">2</span></span>)</span>;            <span class="comment">// this example is from Item 24,</span></div><div class="line"><span class="comment">// except Rational is now a template</span></div><div class="line"></div><div class="line">Rational&lt;<span class="keyword">int</span>&gt; result = oneHalf * <span class="number">2</span>; <span class="comment">// error! won’t compile</span></div></pre></td></tr></table></figure>
<h2 id="2-问题分析——模板参数演绎不能进行隐式转换"><a href="#2-问题分析——模板参数演绎不能进行隐式转换" class="headerlink" title="2. 问题分析——模板参数演绎不能进行隐式转换"></a>2. 问题分析——模板参数演绎不能进行隐式转换</h2><p>但事实上上面的代码不会通过编译，这就表明了模板化的Rational和非模板版本有些地方还是不一样的，确实是有区别的。在<a href="http://www.cnblogs.com/harlanc/p/6482417.html" title="Item 24" target="_blank" rel="external">Item<br>24</a>中，编译器知道我们尝试调用什么函数（带两个Rational参数的operator<em>），但是这里，编译器不知道我们想要调用哪个函数。相反，它们尝试确认<strong>从模板**</strong>operator<em>**</em></em>中实例化出（也即是创建）什么样的函数<strong>。它们知道它们想实例化一些名字为operator*的函数，这些函数带有两个类型为Rational<t>的参数，但是为了进行实例化，</t></strong>它们必须确认<strong><strong>T</strong></strong>是什么。问题是他们不可能知道**。</p>
<p>为了演绎出T类型，它们看到了调用operator*时传递的参数类型。在上面的例子中，两个参数类型分别是Rational<int>（oneHalf的类型）和int(2的类型)。每个参数进行单独考虑。</int></p>
<p>使用oneHalf进行演绎（deduction）很容易，operator<em>的第一个参数所需要的类型为Rational<t>，实际上这里传递给operator</t></em>的第一个参数的类型是Rational<int>，所以T必须为int。不幸的是，对其他参数的演绎就没有这么简单了，operator<em>的第二个参数所需要的类型也为Rational<t>，但是传递给operator</t></em>的第二个参数是一个int值。在这种情况下编译器该如何确认T是什么呢？你可能期望它们使用Rational<int>的非显示构造函数来将2转换为一个Rational<int>，这样就允许它们将T演绎成int，但是它们没有这么做。<strong>因为在模板参数演绎期间永远不会考虑使用隐式类型转换函数</strong>。这样的转换是在函数调用期间被使用的，所以在你调用一个函数之前，你必须知道哪个函数是存在的。为了知道这些，你就必须为相关的函数模板演绎出参数类型（然后你才能实例化出合适的函数。）但是在模板参数演绎期间不会通过调用构造函数来进行隐式转换<strong>。</strong>Item 24没有涉及到模板，所以模板参数的演绎不是问题。现在我们正在讨论C++的模板部分（<a href="http://www.cnblogs.com/harlanc/p/6371997.html" title="Item 1" target="_blank" rel="external">Item<br>1</a>）,这变为了主要问题。</int></int></int></p>
<h2 id="3-问题解决——使用友元函数"><a href="#3-问题解决——使用友元函数" class="headerlink" title="3. 问题解决——使用友元函数"></a>3. 问题解决——使用友元函数</h2><h3 id="3-1-在类模板中声明友元函数——编译通过"><a href="#3-1-在类模板中声明友元函数——编译通过" class="headerlink" title="3.1 在类模板中声明友元函数——编译通过"></a>3.1 在类模板中声明友元函数——编译通过</h3><p>我们可以利用如下事实来缓和编译器接受的对模板参数演绎的挑战：<strong>模板类中的一个友元声明能够引用一个实例化函数</strong>。这就意味着类Ration<t>能够为Ration<t>声明一个友元函数的operator<em>。类模板不再依赖于模板参数演绎（这个过程只应用于函数模板），所以T总是在类Ration<t>被实例化的时候就能被确认。所以声明一个合适的友元operator</t></em>函数能简化整个问题：</t></t></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">...</div><div class="line"></div><div class="line">friend <span class="comment">// declare operator*</span></div><div class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="comment">// function (see</span></div><div class="line"><span class="keyword">const</span> Rational&amp; rhs); <span class="comment">// below for details)</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;typename T&gt;                                                              <span class="comment">// define operator*</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="comment">// functions  </span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</div><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>现在我们对operator<em>的混合模式的调用就能通过编译了，因为当对象oneHalf被声明为类型Rational<int>的时候，Ratinonal<t>被实例化称Rational<int>,作为这个过程的一部分，参数为Rational<int>的友元函数operator</int></int></t></int></em>被自动声明。<strong>作为一个被声明的函数</strong>（不是函数模板），<strong>编译器在调用它时就能够使用隐式类型转换函数</strong>（像Rational的非显示构造函数），<strong>这就是如何使混合模式调用成功的</strong>。</p>
<h3 id="3-2-关于模板和模板参数的速写符号"><a href="#3-2-关于模板和模板参数的速写符号" class="headerlink" title="3.2 关于模板和模板参数的速写符号"></a>3.2 关于模板和模板参数的速写符号</h3><p>虽然代码能够通过编译，但是却不能链接成功。我们稍后处理，但是对于上面的语法我首先要讨论的是在Rational中声明operator*。</p>
<p>在一个类模板中，<strong>模板的名字能够被用来当作模板和模板参数的速写符号</strong>，所以在Rational<t>中，我们可以写成Rational来代替Rational<t>。在这个例子中只为我们的输入减少了几个字符，但是如果有多个参数或者更长的参数名字的时候，它既能减少输入也能使代码看起来更清晰。我提出这些是因为在上面的例子中operator*的声明用Rational作为参数和返回值，而不是Rational<t>。下面的声明效果是一样的：</t></t></t></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">...</div><div class="line">friend</div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs);</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然而，使用速写形式更加容易（更加大众化）。</p>
<h3 id="3-3-把友元函数的定义合并到声明中——链接通过"><a href="#3-3-把友元函数的定义合并到声明中——链接通过" class="headerlink" title="3.3 把友元函数的定义合并到声明中——链接通过"></a>3.3 把友元函数的定义合并到声明中——链接通过</h3><p>现在让我们回到链接问题。混合模式的代码能够通过编译，因为编译器知道我们想调用一个实例化函数（带两个Rational<int>参数的operator<em>函数），但是这个函数只在Rational内部进行声明，而不是被定义。我们的意图是让类外部的operator</em>模板提供定义，但是编译器不会以这种方式进行工作。<strong>如果我们自己声明一个函数（这是我们在**</strong>Rational<strong>**模板内部所做的），我们同样有责任去定义这个函数</strong>。在上面的例子中，我们并没有提供一个定义，这就是为什么连接器不能知道函数定义的原因。</int></p>
<p>最简单的可能工作的解决方案是将operator*函数体合并到声明中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">...</div><div class="line">friend <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(), <span class="comment">// same impl</span></div><div class="line">lhs.denominator() * rhs.denominator()); <span class="comment">// as in</span></div><div class="line">&#125; <span class="comment">// Item 24</span></div><div class="line">&#125;;</div><div class="line"></div></pre></td></tr></table></figure>
<p>确实这能够工作：对operator*的混合模式调用，编译，链接，运行都没有问题。</p>
<h3 id="3-4-如此使用友元函数很意思"><a href="#3-4-如此使用友元函数很意思" class="headerlink" title="3.4 如此使用友元函数很意思"></a>3.4 如此使用友元函数很意思</h3><p>这种技术的有意思的地方是<strong>友元函数并没有被用来访问类的非**</strong>public<strong>**部分</strong>。为了使所有参数间的类型转换成为可能，我们需要一个非成员函数（Item 24在这里仍然适用）；并且为了让合适的函数被自动实例化出来，我们需要在类内部声明一个函数。在类内部声明一个非成员函数的唯一方法是将其声明为友元函数。这就是我们所做的，不符合惯例？是的。有效么？毋庸置疑。</p>
<h2 id="4-关于模板友元函数inline的讨论"><a href="#4-关于模板友元函数inline的讨论" class="headerlink" title="4. 关于模板友元函数inline的讨论"></a>4. 关于模板友元函数inline的讨论</h2><p>正如在<a href="http://www.cnblogs.com/harlanc/p/6523201.html" title="Item 30" target="_blank" rel="external">Item 30</a>中解释的，在类内部定义的函数被隐式的声明为inline函数，这同样包含像operator<em>这样的友元函数。你可以最小化这种inline声明的影响：通过让operator</em>只调用一个定义在类体外的helper函数。在这个条款的例子中没有必要这么做，因为operator*已经被实现成了只有一行的函数，对于更加复杂的函数体，helper才可能是你想要的。“让友元函数调用helper”的方法值得一看。</p>
<p>Rationl是模板的事实意味着helper函数通常情况下也会是一个模板，所以在头文件中定义Rational的代码会像下面这个样子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt; <span class="keyword">class</span> <span class="title">Rational</span>; <span class="comment">// declare</span></div><div class="line"><span class="comment">// Rational</span></div><div class="line"><span class="comment">// template</span></div><div class="line"></div><div class="line">template&lt;typename T&gt; <span class="comment">// declare</span></div><div class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span>(<span class="params"> <span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, // helper</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs);                                         <span class="comment">// template</span></div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">...</div><div class="line">friend</div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)                                          <span class="comment">// Have friend</span></div><div class="line"></div><div class="line">&#123; <span class="keyword">return</span> doMultiply(lhs, rhs); &#125;                <span class="comment">// call helper</span></div><div class="line"></div><div class="line">...                                                            </div><div class="line"></div><div class="line">&#125;;           </div></pre></td></tr></table></figure>
<p>许多编译器从根本上强制你将所有的模板定义放在头文件中，所以你可能同样需要在你的头文件中定义doMultiply。（正如<a href="http://www.cnblogs.com/harlanc/p/6523201.html" title="Item 30" target="_blank" rel="external">Item30</a>解释的，这样的模板不需要inline）。这会像下面这个样子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt; <span class="comment">// define</span></div><div class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span>(<span class="params"><span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, // helper</span></span></div><div class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs) <span class="comment">// template in</span></div><div class="line">&#123; <span class="comment">// header file,</span></div><div class="line"><span class="keyword">return</span> Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(), <span class="comment">// if necessary</span></div><div class="line">lhs.denominator() * rhs.denominator());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，作为一个模板，doMultiply不支持混合模式的乘法，但是也不需要支持。它只被operator<em>调用，operator</em>支持混合模式操作就够了！从根本上来说，函数operator*支持必要的类型转换，以确保两个Rational对象被相乘，然后它将这两个对象传递到doMultiply模板的合适实例中进行实际的乘法操作。协同行动，不是么？</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>当实现一个提供函数的类模版时，如果这些函数的所有参数支持和模板相关的隐式类型转换，将这些函数定义为类模板内部的友元函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题的引入——将operator-模板化&quot;&gt;&lt;a href=&quot;#1-问题的引入——将operator-模板化&quot; class=&quot;headerlink&quot; title=&quot;1. 问题的引入——将operator*模板化&quot;&gt;&lt;/a&gt;1. 问题的引入——将operator*模板化&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/harlanc/p/6482417.html&quot; title=&quot;Item 24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Item 24&lt;/a&gt;中解释了为什么对于所有参数的隐式类型转换，只有非成员函数是合格的，并且使用了一个为Rati&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 45 使用成员函数模板来接受“所有兼容类型”</title>
    <link href="http://yoursite.com/2017/04/10/2017-04-10_08_36_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_45_%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%9D%A5%E6%8E%A5%E5%8F%97%E2%80%9C%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B%E2%80%9D/"/>
    <id>http://yoursite.com/2017/04/10/2017-04-10_08_36_读书笔记_effective_c++_Item_45_使用成员函数模板来接受“所有兼容类型”/</id>
    <published>2017-04-10T00:36:00.000Z</published>
    <updated>2017-05-20T10:40:57.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>智能指针的行为像是指针，但是没有提供加的功能。例如，<a href="http://www.cnblogs.com/harlanc/p/6412222.html" title="Item 13" target="_blank" rel="external">Item 13</a>中解释了如何使用标准auto_ptr和tr1::shared_ptr指针在正确的时间自动删<br><a id="more"></a><br>堆上的资源。STL容器中的迭代器基本上都是智能指针：当然，你不能通过使用“++”来将链表中的指向一个节点的内建指针移到下一个节点上去，但是list::iterator可以这么做。</p>
<h2 id="1-问题分析——如何实现智能指针的隐式转换"><a href="#1-问题分析——如何实现智能指针的隐式转换" class="headerlink" title="1. 问题分析——如何实现智能指针的隐式转换"></a>1. 问题分析——如何实现智能指针的隐式转换</h2><p>真正的指针能够做好的一件事情是支持隐式转换。派生类指针可以隐式转换为基类指针，指向非const的指针可以隐式转换成为指向const对象的指针，等等。例如，考虑可以在一个三层继承体系中发生的转换：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Top</span> &#123; ... &#125;;</div><div class="line"><span class="keyword">class</span> <span class="title">Middle</span>: <span class="title">public</span> <span class="title">Top</span> &#123; ... &#125;;</div><div class="line"><span class="keyword">class</span> <span class="title">Bottom</span>: <span class="title">public</span> <span class="title">Middle</span> &#123; ... &#125;;</div><div class="line">Top *pt1 = <span class="keyword">new</span> Middle;           <span class="comment">// convert Middle* ⇒ Top*</span></div><div class="line"></div><div class="line">Top *pt2 = <span class="keyword">new</span> Bottom;          <span class="comment">// convert Bottom* ⇒ Top*</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Top *pct2 = pt1;             <span class="comment">// convert Top* ⇒ const Top*</span></div></pre></td></tr></table></figure>
<p>在用户自定义的智能指针中模仿这种转换是很微妙的。我们想让下面的代码通过编译：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</div><div class="line"><span class="keyword">public</span>: <span class="comment">// smart pointers are typically</span></div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span>(<span class="params">T *realPtr</span>)</span>; <span class="comment">// initialized by built-in pointers</span></div><div class="line">...</div><div class="line">&#125;;</div><div class="line">SmartPtr&lt;Top&gt; pt1 = <span class="comment">// convert SmartPtr&lt;Middle&gt; ⇒</span></div><div class="line">SmartPtr&lt;Middle&gt;(<span class="keyword">new</span> Middle); <span class="comment">// SmartPtr&lt;Top&gt;</span></div><div class="line">SmartPtr&lt;Top&gt; pt2 = <span class="comment">// convert SmartPtr&lt;Bottom&gt; ⇒</span></div><div class="line">SmartPtr&lt;Bottom&gt;(<span class="keyword">new</span> Bottom); <span class="comment">// SmartPtr&lt;Top&gt;</span></div><div class="line">SmartPtr&lt;<span class="keyword">const</span> Top&gt; pct2 = pt1; <span class="comment">// convert SmartPtr&lt;Top&gt; ⇒</span></div><div class="line"><span class="comment">// SmartPtr&lt;const Top&gt;</span></div></pre></td></tr></table></figure>
<p>同一个模板的不同实例之间没有固有的关系，所以编译器将SmartPtr<middle>和SmartPtr<top>视为完全不同的类，它们之间的关系不比vector<float>和Widget来的近。为了实现SmartPtr类之间的转换，我们必须显示的实现。</float></top></middle></p>
<p>在上面的智能指针示例代码中，每个语句都创建了一个新的智能指针对象，所以现在我们把焦点放在如何实现出一个行为表现如我们所愿的智能指针构造函数。关键的一点是没有办法实现我们需要的所有构造函数。在上面的继承体系中，我们可以用一个SmartPtr<middle>或一个SmartPtr<bottom>来构造一个SmartPtr<top>，但是如果这个继承体系在未来扩展了，SmartPtr<top>对象必须能够从其他智能指针类型中构造出来。例如，如果我们增加了下面的类：</top></top></bottom></middle></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">BelowBottom</span>: <span class="title">public</span> <span class="title">Bottom</span> &#123; ... &#125;;</div></pre></td></tr></table></figure>
<p>我们将会需要支持用SmartPtr<belowbottom>对象来创建SmartPtr<top>对象，我们当然不想通过修改SmartPtr模板来实现它。</top></belowbottom></p>
<h2 id="2-使用成员函数模板——泛化拷贝构造函数进行隐式转换"><a href="#2-使用成员函数模板——泛化拷贝构造函数进行隐式转换" class="headerlink" title="2. 使用成员函数模板——泛化拷贝构造函数进行隐式转换"></a>2. 使用成员函数模板——泛化拷贝构造函数进行隐式转换</h2><p>从原则上来说，我们所需要的构造函数的数量是没有限制的。既然模板可以被实例化成为没有限制数量的函数，因此看上去我们不需要一个SmartPtr的构造函数，我们需要的是一个构造函数模板。这样的模板是<strong>成员函数模板</strong>(member function templates) （也被叫做member templates）的一个例子——也即是为类产生成员函数的模板：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">template&lt;typename U&gt; <span class="comment">// member template</span></div><div class="line">SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other); <span class="comment">// for a ”generalized</span></div><div class="line"></div><div class="line">...                                  <span class="comment">// copy constructor”</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这就是说对于每个类型T和每个类型U，一个SmartPtr<t>能够用SmartPtr<u>创造出来，因为SmartPtr<t>有一个以SmartPtr<u>作为参数的构造函数 。像这样的构造函数——用一个对象来创建另外一个对象，两个对象来自于相同的模板但是它们为不同类型（例如，用SmartPtr<u>来创建SmartPtr<t>）,它通常被叫做<strong>泛化拷贝构造函数</strong>（generalized copy constructors）。</t></u></u></t></u></t></p>
<h3 id="2-1-隐式转换不需要explicit"><a href="#2-1-隐式转换不需要explicit" class="headerlink" title="2.1 隐式转换不需要explicit"></a>2.1 隐式转换不需要explicit</h3><p>上面的泛化拷贝构造函数并没有被声明为explicit。这是经过仔细考虑的。内建指针类型之间的类型转换（例如从派生类转换到基类指针）是隐式的，并且不需要cast，因此智能指针模仿这种行为就是合理的。在模板化的构造函数上省略explicit正好做到了这一点。</p>
<h3 id="2-2-将不符合要求的模板实例化函数剔除掉"><a href="#2-2-将不符合要求的模板实例化函数剔除掉" class="headerlink" title="2.2 将不符合要求的模板实例化函数剔除掉"></a>2.2 将不符合要求的模板实例化函数剔除掉</h3><p>为SmartPtr实现的泛化拷贝构造函数比我们想要的提供了更多的东西。我们想要用SmartPtr<bottom>创建SmartPtr<top>，但是我们不想用SmartPtr<top>创建SmartPtr<bottom>，因为这违背了public继承的含义（<a href="http://www.cnblogs.com/harlanc/p/6551155.html" title="Item 32" target="_blank" rel="external">Item 32</a>）。我们同样不想用SmartPtr<double>创建SmartPtr<int>,因为没有从double<em>到int</em>之间的隐式转换。因此，我们必须将成员模板生成的这种成员函数集合剔除掉。</int></double></bottom></top></top></bottom></p>
<p>假设SmartPtr遵循auto_ptr和tr1::shared_ptr的设计，也提供一个get成员函数来返回智能指针对象所包含的内建类型指针的一份拷贝（<a href="http://www.cnblogs.com/harlanc/p/6418038.html" title="Item 15" target="_blank" rel="external">Item 15</a>），我们可以使用构造函数模板的实现来对一些转换进行限制：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">template&lt;typename U&gt;</div><div class="line">SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) <span class="comment">// initialize this held ptr</span></div><div class="line">: heldPtr(other.<span class="keyword">get</span>()) &#123; ... &#125; <span class="comment">// with other’s held ptr</span></div><div class="line">T* <span class="keyword">get</span>() <span class="keyword">const</span> &#123; <span class="keyword">return</span> heldPtr; &#125;</div><div class="line">...</div><div class="line"><span class="keyword">private</span>: <span class="comment">// built-in pointer held</span></div><div class="line">T *heldPtr; <span class="comment">// by the SmartPtr</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在成员初始化列表中用SmartPtr<u>中包含的类型为U<em>的指针来初始化SmartPtr<t>中的类型为T</t></em>的数据成员。这只有在能够从U<em>指针到T</em>指针进行隐式转换的情况下才能通过编译，这也正是我们所需要的。实际结果是现在SmartPtr<t>有了一个泛化拷贝构造函数，只有传递的参数为兼容类型时才能够通过编译。</t></u></p>
<h2 id="3-成员函数模板对赋值的支持"><a href="#3-成员函数模板对赋值的支持" class="headerlink" title="3. 成员函数模板对赋值的支持"></a>3. 成员函数模板对赋值的支持</h2><p>成员函数模板的使用不仅仅限定在构造函数上。它们的另外一个普通的角色是对赋值的支持。例如，tr1的shared_ptr（<a href="http://www.cnblogs.com/harlanc/p/6412222.html" title="Item 13" target="_blank" rel="external">Item 13</a>）支持用所有兼容的内建指针来对其进行构造，可以用tr1::shared_ptr，auto_ptr和tr1::weak_ptr（Item 54）来进行构造，对赋值也同样使用，但是tr1::weak_ptr例外。下面是从tr1的说明中摘录下来的tr1::shared_ptr的实现，可以看到在声明模板参数的时候它倾向于使用class而不是typename。（<a href="http://www.cnblogs.com/harlanc/p/6661228.html" title="Item 42" target="_blank" rel="external">Item 42</a>中描述的，在这个上下文中它们的意义相同。）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt; class shared_ptr &#123;</div><div class="line">public:</div><div class="line"></div><div class="line">template&lt;class Y&gt;                              // construct from</div><div class="line"></div><div class="line">explicit shared_ptr(Y * p);                   // any compatible</div><div class="line"></div><div class="line">template&lt;class Y&gt;                              // built-in pointer,</div><div class="line"></div><div class="line">shared_ptr(shared_ptr&lt;Y&gt; const&amp; r); // shared_ptr,</div><div class="line">template&lt;class Y&gt; // weak_ptr, or</div><div class="line"></div><div class="line">explicit shared_ptr(weak_ptr&lt;Y&gt; const&amp; r);    // auto_ptr</div><div class="line"></div><div class="line">template&lt;class Y&gt;                                          </div><div class="line"></div><div class="line">explicit shared_ptr(auto_ptr&lt;Y&gt;&amp; r);             </div><div class="line"></div><div class="line">template&lt;class Y&gt; // assign from</div><div class="line">shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r); // any compatible</div><div class="line">template&lt;class Y&gt; // shared_ptr or</div><div class="line">shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp; r); // auto_ptr</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所有的这些构造函数都是explicit的，除了泛化拷贝构造函数。这就意味着从shared_ptr的一种类型隐式转换到shared_ptr的另一种类型是允许的，但是内建类型指针和其他的智能指针类型到shared_ptr的隐式转换是禁止的。（显示的转换是可以的（例如通过使用cast））。同样有趣的是传递给tr1::shared_ptr构造函数和赋值运算符的auto_ptr没有被声明为const，但是tr1::shared_ptr和tr1::weak_ptr的传递却声明为const了。这是因为auto_ptr被拷贝的时候已经被修改了（Item 13）。</p>
<h2 id="4-成员函数模板会生成默认拷贝构造函数"><a href="#4-成员函数模板会生成默认拷贝构造函数" class="headerlink" title="4. 成员函数模板会生成默认拷贝构造函数"></a>4. 成员函数模板会生成默认拷贝构造函数</h2><p>成员函数模板是美好的东西，但是它们没有修改语言的基本规则。<a href="http://www.cnblogs.com/harlanc/p/6390731.html" title="Item 5" target="_blank" rel="external">Item 5</a>解释了编译器会自动生成的4个成员函数中的两个函数为拷贝构造函数和拷贝赋值运算符。Tr1::shared_ptr声明了一个泛化拷贝构造函数，很清楚的是如果类型T和类型Y是相同的，泛化拷贝构造函数就会被实例化成一个“普通”的拷贝构造函数。那么编译器会为tr1::shared_ptr生成一个拷贝构造函数么？或者说用相同类型的tr1::shared_ptr构造另外一个tr1::shared_ptr的时候，编译器会实例化泛化拷贝构造函数么？</p>
<p>正如我所说的，成员模板没有修改语言的规则。“如果你需要一个拷贝构造函数而你没有自己声明，编译器会为你生成一个”这条规则也是其中之一。在一个类中声明一个泛化拷贝构造函数（一个member template）不会阻止编译器生成它们自己的拷贝构造函数（non-template），所以如果你想控制拷贝构造函数的所有方面，你必须同时声明一个泛化拷贝构造函数和“普通的”构造函数。对于赋值同样适用。下面是tr1::shared_ptr的定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt; class shared_ptr &#123;</div><div class="line">public:</div><div class="line">shared_ptr(shared_ptr const&amp; r);       // copy constructor</div><div class="line"></div><div class="line">template&lt;class Y&gt;                        // generalized</div><div class="line"></div><div class="line">shared_ptr(shared_ptr&lt;Y&gt; const&amp; r);       // copy constructor</div><div class="line"></div><div class="line">shared_ptr&amp; operator=(shared_ptr const&amp; r);            // copy assignment</div><div class="line"></div><div class="line">template&lt;class Y&gt;                                     // generalized</div><div class="line"></div><div class="line">shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r); // copy assignment</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul>
<li>使用成员函数模板来生成接受所有兼容类型的函数。</li>
<li>如果你为泛化拷贝构造函数和泛化赋值运算符声明成员模板，你同样需要声明普通的拷贝构造函数和拷贝赋值运算符。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h1&gt;&lt;p&gt;智能指针的行为像是指针，但是没有提供加的功能。例如，&lt;a href=&quot;http://www.cnblogs.com/harlanc/p/6412222.html&quot; title=&quot;Item 13&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Item 13&lt;/a&gt;中解释了如何使用标准auto_ptr和tr1::shared_ptr指针在正确的时间自动删&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 44  将与模板参数无关的代码抽离出来</title>
    <link href="http://yoursite.com/2017/04/07/2017-04-07_22_01_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_44__%E5%B0%86%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB%E5%87%BA%E6%9D%A5/"/>
    <id>http://yoursite.com/2017/04/07/2017-04-07_22_01_读书笔记_effective_c++_Item_44__将与模板参数无关的代码抽离出来/</id>
    <published>2017-04-07T14:01:00.000Z</published>
    <updated>2017-05-20T10:40:57.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-使用模板可能导致代码膨胀"><a href="#1-使用模板可能导致代码膨胀" class="headerlink" title="1. 使用模板可能导致代码膨胀"></a>1. 使用模板可能导致代码膨胀</h2><p>使用模板是节省时间和避免代码重用的很好的方法。你不需要手动输入20个相同的类名，每个类有15个成员函数，相反，你只需要输入一个类模板，然后让编译器来为你实例化20个特定的类和300个你需要的函数。（只有在被使用的情况下类模版的成员函数才会被隐式的实例<br><a id="more"></a><br>，所以只有在300个函数被实际用到的情况下才会生成300个成员函数。）函数模板同样吸引人。你不用手动实现许多函数，你只需要实现一个函数模板，然后让编译器来做余下的事情。</p>
<p>然而在有些时候，如果你不小心，使用模板会导致代码膨胀（code bloat）:产生重复代码或者数据的二进制文件，或者两者都有。结果可能是源码看起来合身整齐，但是目标代码（object code）臃肿松弛。臃肿松弛很不好，因此你需要知道如果避免这样的二进制浮夸。</p>
<h2 id="2-共性和可变性分析"><a href="#2-共性和可变性分析" class="headerlink" title="2. 共性和可变性分析"></a>2. 共性和可变性分析</h2><p> 你的主要工具有着很威风的名字：共性和可变性分析（commonality and variability analysis），但是这个概念很平常。即使在你的编程生涯中从未实现过一个模板，你也总是会做这样的分析。</p>
<h3 id="2-1-函数和类中的代码重复分析"><a href="#2-1-函数和类中的代码重复分析" class="headerlink" title="2.1 函数和类中的代码重复分析"></a>2.1 函数和类中的代码重复分析</h3><p>当你正在实现一个函数，你意识到函数实现的某些部分同另外一个函数实现基本上是相同的 ，你会重复这些代码么？当然不会。你将两个函数的公共代码提取出来，放进第三个函数中，然后在两个函数中调用这个新函数。总结一下就是，你对两个函数进行分析，找到相同和不同的部分，将相同的部分移到一个新的函数中去，将不同的部分保留在原来的函数中。类似的，如果你正在实现一个类，你意识到类中的一部分另一个类中的一部分是相同的，你不应该重写相同的部分。相反，你可以将相同的部分移到一个新类中，然后使用继承或者组合（<a href="http://www.cnblogs.com/harlanc/p/6551155.html" title="Item 32" target="_blank" rel="external">Item 32</a>,<a href="http://www.cnblogs.com/harlanc/p/6628670.html" title="Item 38" target="_blank" rel="external">Item 38</a>,<a href="http://www.cnblogs.com/harlanc/p/6636917.html" title="Item 39" target="_blank" rel="external">Item 39</a>）让原始类访问共同的特性。原始类中不同的部分仍然保留在原来的位置。</p>
<h3 id="2-2-模板中的代码重复分析及消除重复方法"><a href="#2-2-模板中的代码重复分析及消除重复方法" class="headerlink" title="2.2 模板中的代码重复分析及消除重复方法"></a>2.2 模板中的代码重复分析及消除重复方法</h3><p>当实现模板的时候，你也会做相同的分析，你会使用相同的方式来阻止重复，但是这里有一个让你伤痛的地方。在非模板(non-template)代码中，重复是显示的：你可以看到在函数之间或者类之间会有代码重复。在模板代码中，重复是隐式的：只有一份模板源码，<strong>所以你必须训练你自己当一个模板被实例化多次的时候，你能够感觉到重复会不会发生</strong>。</p>
<h4 id="2-2-1-消除代码膨胀第一关——去掉非类型参数"><a href="#2-2-1-消除代码膨胀第一关——去掉非类型参数" class="headerlink" title="2.2.1 消除代码膨胀第一关——去掉非类型参数"></a>2.2.1 消除代码膨胀第一关——去掉非类型参数</h4><p>例如，假设你想为固定大小的矩阵实现一个模板，需要支持矩阵的转置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, // template for n x n matrices of</div><div class="line">std::size_t n&gt; // objects of type T; see below for info</div><div class="line">class SquareMatrix &#123; // on the size_t parameter</div><div class="line">public:</div><div class="line">...</div><div class="line"></div><div class="line">void invert();                         // invert the matrix in place</div><div class="line"></div><div class="line">&#125;;     </div></pre></td></tr></table></figure>
<p>这个模板带了一个类型参数，T，但是也带了一个类型size_t的参数，一个非类型（non-type）参数。非类型参数比类型参数少了共性，但是它们是完全合法的，并且在这个例子中，它们也能非常自然。</p>
<p>现在考虑下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sm1;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">sm1.invert();</div><div class="line"></div><div class="line"><span class="comment">// call SquareMatrix&lt;double, 5&gt;::invert</span></div><div class="line"></div><div class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">sm2.invert();</div><div class="line"></div><div class="line"><span class="comment">// call SquareMatrix&lt;double, 10&gt;::invert</span></div><div class="line"></div></pre></td></tr></table></figure>
<p>在这里将会实例化invert的两份拷贝。这两个函数并不相同，因为一个在5<em>5的矩阵上工作，另外一个在10</em>10的矩阵上工作，但是如果不考虑常量5和10，这两个函数将会是一样的。这是使得包含模板的代码出现膨胀的典型方式。</p>
<p>如果你看到两个函数，它们的所有字符都是相同的，除了一个版本使用5而另外一个版本使用10，你接下来会做什么？你的直觉是会创建一个带一个参数的函数版本，然后以5或者10为入参调用这个函数而不是重复代码。你的直觉能够很好的为你服务！这是实现SquareMatrix的第一关：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> template&lt;typename T&gt; // size-independent base class for</div><div class="line"> class SquareMatrixBase &#123; // square matrices</div><div class="line"> protected:</div><div class="line"> ...</div><div class="line"> void invert(std::size_t matrixSize); // invert matrix of the given size</div><div class="line"> ...</div><div class="line"> &#125;;</div><div class="line"> template&lt;typename T, std::size_t n&gt;</div><div class="line"> class SquareMatrix: private SquareMatrixBase&lt;T&gt; &#123;</div><div class="line"> private:</div><div class="line"> using SquareMatrixBase&lt;T&gt;::invert; // make base class version of invert</div><div class="line"> // visible in this class; see [Items 33</div><div class="line">](http://www.cnblogs.com/harlanc/p/6556371.html "Item 33") // and [Item 43](http://www.cnblogs.com/harlanc/p/6665825.html "Item 43")</div><div class="line"> public:</div><div class="line"> ...</div><div class="line"> void invert() &#123; invert(n); &#125; // make inline call to base class</div><div class="line"> &#125;; // version of invert</div></pre></td></tr></table></figure>
<p>正如你所看到的，带参数的invert版本被放在基类SquareMatrixBase中。像SquareMatrix一样，SquareMatrixBase是一个模板，但是与SquareMatrix不同的是，它在矩阵中只对对象类型进行模板化。因此，包含一个给定类型对象的所有矩阵将会分享一个单一的SquareMatrixBase类。这样它们会分享SquareMatrixBase类的invert版本的单一拷贝。（你不能将其声明为inline，因为一旦被inline了，每个SquareMatrix::invert的实例都会得到SquareMatrixBase::invert代码的一份拷贝（看<a href="http://www.cnblogs.com/harlanc/p/6523201.html" title="Item 30" target="_blank" rel="external">Item 30</a>）,你会发现你有回到了对象代码重复的原点。）</p>
<p>SquareMatrixBase::invert只被用来在派生类中防止代码重复，所以是protected而不是public的。调用它的额外开销应该是0，因为派生类的inverts调用基类版本使用了inline函数。（inline是隐式的 见<a href="http://www.cnblogs.com/harlanc/p/6523201.html" title="Item 30" target="_blank" rel="external">Item 30</a>）同时注意SquareMatrix和SquareMarixBase之间的继承是private的。这精确的反映出一个事实：<strong>使用基类的唯一原因是帮助派生类的实现，并非表达出**</strong>SquareMatrix<strong><strong>和</strong></strong>SquareMatrixBase<strong><strong>之间的“</strong></strong>is-a<strong>**”关系</strong>。（有关private继承的信息，见<a href="http://www.cnblogs.com/harlanc/p/6636917.html" title="Item 39" target="_blank" rel="external">Item 39</a>）</p>
<h4 id="2-2-2-消除代码膨胀第二关——派生类如何告知基类数据在哪里"><a href="#2-2-2-消除代码膨胀第二关——派生类如何告知基类数据在哪里" class="headerlink" title="2.2.2 消除代码膨胀第二关——派生类如何告知基类数据在哪里"></a>2.2.2 消除代码膨胀第二关——派生类如何告知基类数据在哪里</h4><p>到现在为止看上去都很好，但是还有一个我们没有处理的棘手的问题。SquareMatrixBase::invert如何知道在什么数据上进行操作？它从参数中得知矩形的大小，但是它如何知道为特殊矩阵提供的数据在哪里？大概只有派生类才会知道。派生类如何同基类进行通讯才能让基类执行invert?</p>
<p>一个可能的方法是向SquareMatrixBase::invert中添加另外一个参数，可能是一个指向一块内存的指针，内存中存放矩形数据。这种方法可以工作，但是十有八九，invert<strong>不是</strong>存在于SquareMatrix中的能够以独立于size的方式重写的，并且移入SquareMatrixBase中的<strong>唯一函数</strong>。如果有几个这样的函数，我们就需要一种方法能够找到存放矩形数据的内存，我们可以为所有的函数添加一个额外的参数，但是如此以来我们就重复告诉了SquareMatrixBase同样的信息。这看上去是错误的。</p>
<p>一个替换方法是让SquareMatrixBase存储一个指向存放矩形数据的内存的指针。这同存放矩形大小有相同的效果。结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class SquareMatrixBase &#123;</div><div class="line">protected:</div><div class="line">SquareMatrixBase(std::size_t n, T *pMem) // store matrix size and a</div><div class="line">: size(n), pData(pMem) &#123;&#125; // ptr to matrix values</div><div class="line"></div><div class="line">void setDataPtr(T *ptr) &#123; pData = ptr; &#125;   // reassign pData</div><div class="line"></div><div class="line">...                                                            </div><div class="line"></div><div class="line">private:                                                  </div><div class="line"></div><div class="line">std::size_t size;           // size of matrix</div><div class="line"></div><div class="line">T *pData;       // pointer to matrix values</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这就让派生类来决定如何分配内存。一些实现会在SquareMatrix对象内部存储矩形数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, std::size_t n&gt;</div><div class="line">class SquareMatrix: private SquareMatrixBase&lt;T&gt; &#123;</div><div class="line">public:</div><div class="line">SquareMatrix() // send matrix size and</div><div class="line">: SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125; // data ptr to base class</div><div class="line">...</div><div class="line">private:</div><div class="line">T data[n*n];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这种类型的对象没有必要做动态内存分配，但是对象本身可能会非常大。一个替换的方法是为每个矩形在堆上存放数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, std::size_t n&gt;</div><div class="line">class SquareMatrix: private SquareMatrixBase&lt;T&gt; &#123;</div><div class="line">public:</div><div class="line">SquareMatrix() // set base class data ptr to null,</div><div class="line">: SquareMatrixBase&lt;T&gt;(n, 0), // allocate memory for matrix</div><div class="line">pData(new T[n*n]) // values, save a ptr to the</div><div class="line">&#123; this-&gt;setDataPtr(pData.get()); &#125; // memory, and give a copy of it</div><div class="line"></div><div class="line">...                                              // to the base class</div><div class="line"></div><div class="line">private:</div><div class="line">boost::scoped_array&lt;T&gt; pData;          // see[ Item 13](http://www.cnblogs.com/harlanc/p/6412222.html "Item 13") for info on</div><div class="line"></div><div class="line">&#125;;                                   // boost::scoped_array</div></pre></td></tr></table></figure>
<h4 id="2-2-3-消除代码膨胀前后效率对比"><a href="#2-2-3-消除代码膨胀前后效率对比" class="headerlink" title="2.2.3 消除代码膨胀前后效率对比"></a>2.2.3 消除代码膨胀前后效率对比</h4><p>不管将数据存放在哪里，从代码膨胀的角度来说，关键结果是<strong>现在很多（可能是所有的）**</strong>SquareMatrix的成员函数可以简单的inline调用基类的（non-inline）函数版本，所有持有相同类型数据的矩形共享基类中的函数，不管size是多少**。同时，不同size的SquareMatrix对象属于不同类型，所以即使SquareMatrix<double,5>和SquareMatrix<double,10>对象在SquareMatrixBase<double>中使用相同的成员函数，把一个SquareMatrix<double,5>对象传给一个需要SquareMatrix<double,10>的函数是没有机会的。好还是不好呢。</double,10></double,5></double></double,10></double,5></p>
<p>好是好，但是需要付出代价。矩形size大小固定的invert版本比按函数参数传递size大小（或者存储在对象中）的invert版本可能产生更好的代码。例如，在指定size的版本中，sizes是编译期常量，因此是常量传播优化的合格者，也可以把其放入生成指令中作为直接操作数。这在同size无关的版本中无法做到。</p>
<p>从另外一个方面，为不同size的矩阵只提供一个invert版本可以减小可执行程序的大小，这能减少程序的工作集大小，并且能够强化指令高速缓存的引用集中化。这些东西能够使得程序运行速度更快，并且相对size指定的版本才能做出的优化，它可能会做出更好的补偿。哪种方法效果更好？唯一的方法是两种方法都试一下，在你的特定平台和有代表性的数据集上观察它们的行为。</p>
<p>另外一个有关效率的需要考虑的地方是有关对象的大小。如果你不介意，将size大小无关的版本向上移动到基类中会增加每个对象的大小。例如，在我刚刚展示的代码中，每个SquareMatrix对象有一个指向SquareMatrixBase类中数据的指针。即使每个派生类中已经有取得数据的方法，这也为每个SquareMatrix对象至少增加一个指针的大小。我们可以修改设计来去掉指针，但是这也是需要付出代价的。例如，让基类存储一个指向数据的protected指针，但会导致封装性的降低（<a href="http://www.cnblogs.com/harlanc/p/6471815.html" title="Item 22" target="_blank" rel="external">Item 22</a>）.它同样能导致资源管理并发症：如果基类存储了指向矩阵数据的指针，但是数据既有可能是动态分配的也可能存储在派生类对象中（正如我们看到的），如何决定是不是需要delete指针？这样的问题是有答案的，但是你做的越精细事情就变得越复杂。从某种意义上讲，有一点代码重复开始开起来有点幸运了。</p>
<h3 id="2-3-如何处理类型模板参数导致的代码膨胀"><a href="#2-3-如何处理类型模板参数导致的代码膨胀" class="headerlink" title="2.3 如何处理类型模板参数导致的代码膨胀"></a>2.3 如何处理类型模板参数导致的代码膨胀</h3><p>这个条款仅仅讨论了由于非类型模板参数导致的代码膨胀，但是类型参数同样可以导致代码膨胀。例如，在许多平台中，int和long有着相同的二进制表示，所以在成员函数中使用vector<int>和vector<long>看起来会一样，这正是代码膨胀的定义。一些连接器会把相同的代码实现整合到一起，但是有一些不会，这就意味着由模板实例化的int和long版本会在一些环境中导致代码膨胀。类似的，在大多数平台上，所有的指针类型有着相同的二进制表示，所以带指针类型的模板（例如，list<int*>,list<const*>,list<squarematrix<long,3><em>&gt;等等）应该通常能够为每个成员函数使用一个单一的底层实现。特别的，这就意味着实现一个强类型指针（T</em> 指针）的成员函数时，让它们调用一个无类型指针的函数（void*指针）。一些标准C++库的实现为模板就是这么做的（如vector,deque,和list）。如果你关心在你的模板中出现的代码膨胀问题，你可能就会想开发出做相同事情的模板。</squarematrix<long,3></const*></int*></long></int></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul>
<li>模板会产生多个类和多个函数，所以任何模板不应该依赖于会导致代码膨胀的模板参数。</li>
<li>非类型模板参数导致的代码膨胀通常情况下可以将模板参数<strong>替换为函数参数或者类数据成员</strong>来清除。</li>
<li>由类型参数导致的代码膨胀也可以被降低，方式是为实例化类型共享相同的二进制表示。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-使用模板可能导致代码膨胀&quot;&gt;&lt;a href=&quot;#1-使用模板可能导致代码膨胀&quot; class=&quot;headerlink&quot; title=&quot;1. 使用模板可能导致代码膨胀&quot;&gt;&lt;/a&gt;1. 使用模板可能导致代码膨胀&lt;/h2&gt;&lt;p&gt;使用模板是节省时间和避免代码重用的很好的方法。你不需要手动输入20个相同的类名，每个类有15个成员函数，相反，你只需要输入一个类模板，然后让编译器来为你实例化20个特定的类和300个你需要的函数。（只有在被使用的情况下类模版的成员函数才会被隐式的实例&lt;br&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 43 了解如何访问模板化基类中的名字</title>
    <link href="http://yoursite.com/2017/04/04/2017-04-04_18_20_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_43_%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%90%8D%E5%AD%97/"/>
    <id>http://yoursite.com/2017/04/04/2017-04-04_18_20_读书笔记_effective_c++_Item_43_了解如何访问模板化基类中的名字/</id>
    <published>2017-04-04T10:20:00.000Z</published>
    <updated>2017-05-20T10:40:57.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题的引入——派生类不会发现模板基类中的名字"><a href="#1-问题的引入——派生类不会发现模板基类中的名字" class="headerlink" title="1. 问题的引入——派生类不会发现模板基类中的名字"></a>1. 问题的引入——派生类不会发现模板基类中的名字</h2><p>假设我们需要写一个应用，使用它可以为不同的公司发送消息。消息可以以加密或者明文（未加密）的方式被发送。如果在编译阶段我们有足够的信息来确定哪个信息会被发送到哪个公司，我们可以使用基于模板的解决方案：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class CompanyA &#123;</div><div class="line">public:</div><div class="line">...</div><div class="line">void sendCleartext(const std::string&amp; msg);</div><div class="line">void sendEncrypted(const std::string&amp; msg);</div><div class="line">...</div><div class="line">&#125;;</div><div class="line">class CompanyB &#123;</div><div class="line">public:</div><div class="line">...</div><div class="line">void sendCleartext(const std::string&amp; msg);</div><div class="line">void sendEncrypted(const std::string&amp; msg);</div><div class="line">...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">...                                                       // classes for other companies</div><div class="line"></div><div class="line">class MsgInfo &#123; ... &#125;;                            // class for holding information</div><div class="line">// used to create a message</div><div class="line"></div><div class="line">template&lt;typename Company&gt;</div><div class="line">class MsgSender &#123;</div><div class="line">public:</div><div class="line">...                                                       // ctors, dtor, etc.</div><div class="line"></div><div class="line">void sendClear(const MsgInfo&amp; info)</div><div class="line">&#123;</div><div class="line">std::string msg;</div><div class="line">create msg from info;</div><div class="line">Company c;</div><div class="line">c.sendCleartext(msg);</div><div class="line">&#125;</div><div class="line">void sendSecret(const MsgInfo&amp; info)           // similar to sendClear, except</div><div class="line"></div><div class="line">&#123; ... &#125;                                              // calls c.sendEncrypted</div><div class="line"></div><div class="line">&#125;        </div></pre></td></tr></table></figure>
<a id="more"></a>
<p> 这会工作的很好，但是假设有时候我们需要在发送信息之前log一些信息。一个派生类就能够很容易的添加这些信息，下面的实现看上去是合理的实现方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Company&gt;</div><div class="line"></div><div class="line">class LoggingMsgSender: public MsgSender&lt;Company&gt; &#123;</div><div class="line"></div><div class="line">public:</div><div class="line"></div><div class="line">...                                                         // ctors, dtor, etc.</div><div class="line"></div><div class="line">void sendClearMsg(const MsgInfo&amp; info)     </div><div class="line"></div><div class="line">&#123;                                                         </div><div class="line"></div><div class="line">write "before sending" info to the log;</div><div class="line"></div><div class="line">sendClear(info); // call base class function;</div><div class="line">// this code will not compile!</div><div class="line">write "after sending" info to the log;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意派生类中的消息发送函数和基类相比（sendClear）是一个不同的名字（sendClearMsg）。这是好的设计，因为<strong>这避免了隐藏继承而来的名字的问题（**</strong><a href="http://www.cnblogs.com/harlanc/p/6556371.html" title="Item 33" target="_blank" rel="external">Item 33</a>），同时避免了重新定义继承而来的非虚函数问题**（<a href="http://www.cnblogs.com/harlanc/p/6613194.html" title="Item 36" target="_blank" rel="external">Item 36</a>）。但是代码不能通过编译，至少符合标准的编译器不能通过编译。这些编译器会发出sendClear不存在的抱怨。我们能够看到sendClear是在基类中，但是编译器没有在基类中发现它。我们需要知道为什么。</p>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h2><h3 id="2-1-一般化分析"><a href="#2-1-一般化分析" class="headerlink" title="2.1 一般化分析"></a>2.1 一般化分析</h3><p>问题出现在当编译器遇到类模版LoggingMsgSender的定义时，它们不知道它继承自什么类。当然，它是继承自MsgSender<company>，但是Company是一个模板参数，这个参数只有在LoggingMsgSender被实例化的时候才会被确认。在不知道Company是什么的情况下，我们也不知道MsgSender<company>是什么样子的。因此也就没有方法获知是否存在sendClear函数。</company></company></p>
<h3 id="2-2-用实例来证明问题所在"><a href="#2-2-用实例来证明问题所在" class="headerlink" title="2.2 用实例来证明问题所在"></a>2.2 用实例来证明问题所在</h3><p>为了使问题更加具体，假设我们有一个类CompanyZ使用加密的方式进行通信：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">CompanyZ</span> &#123;                                               <span class="comment">// this class offers no</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:                                                                <span class="comment">// sendCleartext function</span></div><div class="line"></div><div class="line">...                                                                       </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span>(<span class="params"><span class="keyword">const</span> std::<span class="keyword">string</span>&amp; msg</span>)</span>;   </div><div class="line"></div><div class="line">...                                                                       </div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>普通的MsgSender模板对于CompanyZ来说是不合适的，因为普通模板提供了一个对于CompanyZ对象来说没有意义的函数。为了改正这个问题，我们能够为CompanyZ创建一个MsgSender的特化版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">template&lt;&gt;                                     // a total specialization of</div><div class="line"></div><div class="line">class MsgSender&lt;CompanyZ&gt; &#123;      // MsgSender; the same as the</div><div class="line"></div><div class="line">public: // general template, except</div><div class="line">... // sendClear is omitted</div><div class="line">void sendSecret(const MsgInfo&amp; info)</div><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>注意在类定义开始的地方出现的”template&lt;&gt;” 语法。它表明这既不是模板也不是单独的类。它是当使用CompanyZ作为模板参数时，会使用到的MsgSender模板的特化版本。<strong>这叫做模板全特化（**</strong>total template specialization）：模板MsgSender为类型CompanyZ进行了特化，并且特化是全特化——一旦类型参数被定义为ComanyZ，模板参数的其它地方就不会再发生变化**。</p>
<p>在MsgSender已经有了CompanyZ的特化版本的情况下，再看一下派生类LoggingMsgSender:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Company&gt;</div><div class="line">class LoggingMsgSender: public MsgSender&lt;Company&gt; &#123;</div><div class="line">public:</div><div class="line">...</div><div class="line">void sendClearMsg(const MsgInfo&amp; info)</div><div class="line">&#123;</div><div class="line">write "before sending" info to the log;</div><div class="line">sendClear(info); // if Company == CompanyZ,</div><div class="line">// this function doesn’t exist!</div><div class="line">write "after sending" info to the log;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>正如注释中所写的，当基类是MsgSender<companyz>的情况下这段代码没有意义，因为基类中没有提供sendClear函数。这也是C++拒绝这个调用的原因：<strong>它认识到基类模板可能被特化了，但是特化版本并没有提供普通模板中的一般接口</strong>。因此，它拒绝在模板化基类中寻找继承而来的名字。从某种意义上讲，当我们从面向对象C++转到模板C++的时候（<a href="http://www.cnblogs.com/harlanc/p/6371997.html" title="Item 1" target="_blank" rel="external">Item 1</a>），继承就会停止工作。</companyz></p>
<h2 id="3-如何解决问题——三种方法"><a href="#3-如何解决问题——三种方法" class="headerlink" title="3. 如何解决问题——三种方法"></a>3. 如何解决问题——三种方法</h2><p>如果让其重新工作，我们必须让C++“不在模板化基类中寻找“的行为失效。有三种方法达到这个目标。</p>
<p>第一，<strong>调用基类函数时你可以为其加上”**</strong>this-&gt;“**：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Company&gt;</div><div class="line">class LoggingMsgSender: public MsgSender&lt;Company&gt; &#123;</div><div class="line">public:</div><div class="line">...</div><div class="line">void sendClearMsg(const MsgInfo&amp; info)</div><div class="line">&#123;</div><div class="line">write "before sending" info to the log;</div><div class="line">this-&gt;sendClear(info); // okay, assumes that</div><div class="line">// sendClear will be inherited</div><div class="line">write "after sending" info to the log;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二，<strong>你可以使用**</strong>using<strong>**声明</strong>，你可能会熟悉，因为<a href="http://www.cnblogs.com/harlanc/p/6556371.html" title="Item 33" target="_blank" rel="external">Item 33</a>中用了类似的解决方案。那个条款中解释了如何使用using声明来将隐藏起来的基类名字带入派生类作用域。我们于是可以像下面这种方式实现sendClearMsg:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Company&gt;</div><div class="line">class LoggingMsgSender: public MsgSender&lt;Company&gt; &#123;</div><div class="line">public:</div><div class="line">using MsgSender&lt;Company&gt;::sendClear; // tell compilers to assume</div><div class="line">... // that sendClear is in the</div><div class="line">// base class</div><div class="line">void sendClearMsg(const MsgInfo&amp; info)</div><div class="line">&#123;</div><div class="line">...</div><div class="line"></div><div class="line">sendClear(info);                                  // okay, assumes that</div><div class="line"></div><div class="line">...                                                          // sendClear will be inherited</div><div class="line"></div><div class="line">&#125;                                                         </div><div class="line"></div><div class="line">...                                                        </div><div class="line"></div><div class="line">&#125;;             </div></pre></td></tr></table></figure>
<p>最后，让你的代码通过编译的方法是<strong>在基类中明确指出需要调用的函数</strong>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Company&gt;</div><div class="line"></div><div class="line">class LoggingMsgSender: public MsgSender&lt;Company&gt; &#123;</div><div class="line"></div><div class="line">public:</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">void sendClearMsg(const MsgInfo&amp; info)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">MsgSender&lt;Company&gt;::sendClear(info);</div><div class="line"></div><div class="line">// okay, assumes that</div><div class="line"></div><div class="line">... // sendClear will be</div><div class="line">&#125; // inherited</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这基本上会是你最不愿意使用的解决这个问题的方法，因为如果被调用的函数是virtual的，显示的限定符会关掉virtual绑定行为。</p>
<p>从名字可见性的观点来看，每个方法都做了同样的事情：它向编译器许诺，接下来的任何基类模板特化都会支持一般模板提供的接口。这样的许诺是当所有的编译器解析一个像LoggingMsgSender的派生类模板的时候所需要的，但是如果这个许诺并没有兑现，在接下来的编译中真理就会浮现。例如，如果下面的源码有这种情况：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LoggingMsgSender&lt;CompanyZ&gt; zMsgSender;</div><div class="line">MsgInfo msgData;</div><div class="line">...                                                                  <span class="comment">// put info in msgData</span></div><div class="line"></div><div class="line">zMsgSender.sendClearMsg(msgData);         <span class="comment">// error! won’t compile</span></div></pre></td></tr></table></figure>
<p>对sendClearMsg的编译不会通过，因为从这个点上来说，编译器知道基类是模板的特化版本MsgSender<companyz>,并且它们知道这个类没有提供sendClearMsg想要调用的sendClear函数。</companyz></p>
<h2 id="4-本条款讨论的根本所在"><a href="#4-本条款讨论的根本所在" class="headerlink" title="4. 本条款讨论的根本所在"></a>4. 本条款讨论的根本所在</h2><p>从根本上来说，这个问题是编译器对基类成员的无效引用进行诊断的早（当派生类模板被解析的时候）或晚（当这些模板用特定的模板参数进行实例化的时候）的问题。C++的方针是更加喜欢早点诊断，这也是为什么当类从模板中特化的时候，它假定对基类的内容一无所知。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在派生类模板中，引用基类模板中的名字可以使用“-&gt;this“前缀，通过使用using声明，或者通过使用显示的使用基类限定符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题的引入——派生类不会发现模板基类中的名字&quot;&gt;&lt;a href=&quot;#1-问题的引入——派生类不会发现模板基类中的名字&quot; class=&quot;headerlink&quot; title=&quot;1. 问题的引入——派生类不会发现模板基类中的名字&quot;&gt;&lt;/a&gt;1. 问题的引入——派生类不会发现模板基类中的名字&lt;/h2&gt;&lt;p&gt;假设我们需要写一个应用，使用它可以为不同的公司发送消息。消息可以以加密或者明文（未加密）的方式被发送。如果在编译阶段我们有足够的信息来确定哪个信息会被发送到哪个公司，我们可以使用基于模板的解决方案：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class CompanyA &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void sendCleartext(const std::string&amp;amp; msg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void sendEncrypted(const std::string&amp;amp; msg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class CompanyB &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void sendCleartext(const std::string&amp;amp; msg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void sendEncrypted(const std::string&amp;amp; msg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...                                                       // classes for other companies&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class MsgInfo &amp;#123; ... &amp;#125;;                            // class for holding information&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// used to create a message&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;template&amp;lt;typename Company&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class MsgSender &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;public:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...                                                       // ctors, dtor, etc.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void sendClear(const MsgInfo&amp;amp; info)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;std::string msg;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;create msg from info;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Company c;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;c.sendCleartext(msg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void sendSecret(const MsgInfo&amp;amp; info)           // similar to sendClear, except&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123; ... &amp;#125;                                              // calls c.sendEncrypted&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;        &lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 effective c++ Item 42 理解typename的两种涵义</title>
    <link href="http://yoursite.com/2017/04/03/2017-04-03_08_15_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_effective_c++_Item_42_%E7%90%86%E8%A7%A3typename%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%B6%B5%E4%B9%89/"/>
    <id>http://yoursite.com/2017/04/03/2017-04-03_08_15_读书笔记_effective_c++_Item_42_理解typename的两种涵义/</id>
    <published>2017-04-03T00:15:00.000Z</published>
    <updated>2017-05-20T10:40:57.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-class和typename含义相同的例子"><a href="#1-class和typename含义相同的例子" class="headerlink" title="1. class和typename含义相同的例子"></a>1. class和typename含义相同的例子</h2><p>问题：在下面的模板声明中class和typename的区别是什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> template&lt;class T&gt; class Widget;     // uses “class”</div><div class="line">&lt;!--more--&gt;</div><div class="line"></div><div class="line"></div><div class="line"> template&lt;typename T&gt; class Widget;            // uses “typename”</div></pre></td></tr></table></figure>
<p>答案：没有任何区别。当声明一个模板类型参数时，class和typename意味着相同的事情。一些程序员喜欢使用class，因为容易敲打。其他的（包括我）更加喜欢使用typename，因为用它表明参数不需要是一个class类型。一些程序员在允许使用任何type的时候使用typename，只用对用户自定义的类型使用class。但是从C++ 的观点来看，在声明模板参数的时候class和typename意味着相同的事情。</p>
<h2 id="2-必须使用typename的例子"><a href="#2-必须使用typename的例子" class="headerlink" title="2. 必须使用typename的例子"></a>2. 必须使用typename的例子</h2><p>然而，C++并不总是将class和typename同等对待。有时你必须使用typename。为了理解在什么时候必须使用，我们必须讨论能够在模板中引用的两种名字。</p>
<p>假设我们有一个函数模板，用和STL兼容的容器作为模板参数，此容器中包含的对象能够被赋值给int类型。进一步假设这个函数打印容器中的第二个元素值。我在下面以愚蠢的方式实现了一个愚蠢的函数，它甚至不能通过编译，但是请忽略这些事情，看下面的例子: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">template&lt;typename C&gt; // print 2nd element in</div><div class="line">void print2nd(const C&amp; container) // container;</div><div class="line">&#123; // this is not valid C++!</div><div class="line">if (container.size() &gt;= 2) &#123;</div><div class="line">C::const_iterator iter(container.begin()); // get iterator to 1st element</div><div class="line">++iter; // move iter to 2nd element</div><div class="line">int value = *iter; // copy that element to an int</div><div class="line"></div><div class="line">std::cout &lt;&lt; value;                       // print the int</div><div class="line"></div><div class="line">&#125;                                                 </div><div class="line"></div><div class="line">&#125;     </div></pre></td></tr></table></figure>
<p> 我对此函数中的两个本地变量做了高亮，iter和value。Iter的类型是C::const_iterator，它依赖于模板参数C。模板中依赖于模板参数的名字被称作依赖名字(dependent names)。当一个依赖名字嵌套在一个类中的时候，我把它叫做内嵌依赖名字（nested dependent name）。C::const_iterator是一个内嵌依赖名字。事实上，它是一个内嵌依赖类型名字（nested dependent type name）,也即是指向一个类型（type）的内嵌依赖名字。</p>
<p>对于print2nd中的其他本地变量，value，类型为int。int不依赖于任何模板参数。这种名字被称作“非依赖名字”（non-dependent names）。（我不知道为什么不把它们叫做独立名字（independent names）。“non-dependent”是一种不好的命名方式，但毕竟它是术语，所以需要遵守这个约定。）</p>
<p>内嵌依赖名字会导致解析困难。例如，如果我们让print2nd函数以下面的方式开始，会更加愚蠢：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;typename C&gt;</div><div class="line"></div><div class="line">void print2nd(const C&amp; container)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">C::const_iterator * x;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上去像是我们声明了一个本地变量x，这个x指针指向一个C::const_iterator。但是它看上去是这样的仅仅因为我们“知道”C::const_iterator是一个type。但是如果C::const_iterator不是一个type会是怎样呢？如果C有个静态数据成员恰好被命名为const_iterator会发生什么？如果x恰巧是一个全局变量的名字呢？在这种情况下，上面的code就不会声明一个本地变量，它会是C::const_iterator和x的乘积！听起来有些疯狂，但这是可能的，实现C++编译器的人员也必须考虑到所有可能的输入，包括一些看起来很疯狂的例子。</p>
<p>直到C被确定之前，没有办法知道C::const_iterator是否是一个type，当函数模板print2nd被解析的时候，C不能够被确认。为了处理这种模棱两可的问题，C++有一个准则：<strong>如果解析器在模板中碰到了一个内嵌依赖名字，它不会认为这是一个**</strong>type，除非你告诉它<strong>。默认情况下，</strong>内嵌依赖名字不是<strong>**types。</strong>（对于这个规则有个例外，一会会提到。）</p>
<p>将上面的规则记在心中，再看一次print2nd的开始部分：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename C&gt;</div><div class="line">void print2nd(const C&amp; container)</div><div class="line">&#123;</div><div class="line">if (container.size() &gt;= 2) &#123;</div><div class="line">C::const_iterator iter(container.begin()); // this name is assumed to</div><div class="line">... // not be a type</div></pre></td></tr></table></figure>
<p>现在应该清楚为什么这不是有效的C++了。Iter的声明只有在C::const_iterator是一个type的情况下才有意义，但是我们并没有告知C++它是一个类型，于是C++假设它不是一个类型。为了纠正这种情况，我们必须告诉C++ C::const_iterator是一个类型。我们将typename放在type之前就能达到这个目的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">template&lt;typename C&gt;                                                               // this is valid C++</div><div class="line"></div><div class="line">void print2nd(const C&amp; container)                                            </div><div class="line"></div><div class="line">&#123;                                                                                                </div><div class="line"></div><div class="line">if (container.size() &gt;= 2) &#123;                                                          </div><div class="line"></div><div class="line">typename C::const_iterator iter(container.begin());                  </div><div class="line"></div><div class="line">...                                                                                                </div><div class="line"></div><div class="line">&#125;                                                                                                </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个规则很简单：在一个模板中，任何时候你引用一个内嵌依赖类型名字，你都必须在名字前加上typename。（也有例外，一会会提到。）</p>
<p><strong>typename应该只被用来确认一个内嵌依赖类型名字</strong>；其他的名字不应该加这个前缀。例如，下面的函数模板使用两个参数，一个容器和一个容器的迭代器：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">template&lt;typename C&gt;                        <span class="comment">// typename allowed (as is “class”)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span>(<span class="params"><span class="keyword">const</span> C&amp; container, // typename not allowed</span></span></div><div class="line">typename C::iterator iter); <span class="comment">// typename required</span></div></pre></td></tr></table></figure>
<p>C不是内嵌依赖类型名字（它没有内嵌在任何依赖于模板参数的东西中），所以在声明容器的时候不应该加typename，但是C::iterator是一个内嵌依赖类型名字，所以需要加typename。</p>
<h2 id="3-一个例外——不能使用typename的地方"><a href="#3-一个例外——不能使用typename的地方" class="headerlink" title="3. 一个例外——不能使用typename的地方"></a>3. 一个例外——不能使用typename的地方</h2><p>”typename”必须加在内嵌依赖类型名字之前“这个规则有一个例外：<strong>基类列表中的内嵌依赖类型名字或者成员初始化列表中的基类标识符不能加typename</strong>。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class Derived: public Base&lt;T&gt;::Nested &#123; // base class list: typename not</div><div class="line"></div><div class="line">public:                                    // allowed</div><div class="line"></div><div class="line">explicit Derived(int x)           </div><div class="line"></div><div class="line">: Base&lt;T&gt;::Nested(x)          // base class identifier in mem.</div><div class="line"></div><div class="line">&#123;                                         // init. list: typename not allowed</div><div class="line"></div><div class="line">typename Base&lt;T&gt;::Nested temp; // use of nested dependent type</div><div class="line">... // name not in a base class list or</div><div class="line">&#125; // as a base class identifier in a</div><div class="line">... // mem. init. list: typename</div><div class="line">required</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这种不一致性令人感到厌烦，但是一旦你有了一点经验，你就会注意到它。</p>
<h2 id="4-最后的例子——为typename使用typedef"><a href="#4-最后的例子——为typename使用typedef" class="headerlink" title="4. 最后的例子——为typename使用typedef"></a>4. 最后的例子——为typename使用typedef</h2><p>让我们看最后一个typename的例子，因为它代表了你将会在真实代码中看到的某些东西。假设我们正在实现一个函数模板，带了一个迭代器参数，我们想为迭代器指向的对象做一份本地拷贝，temp。我们可以像下面这样实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT&gt;</div><div class="line">void workWithIterator(IterT iter)</div><div class="line">&#123;</div><div class="line">typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要让 std::iterator_traits<itert>::value_type 吓到你。这只是标准特性类（standard traits class）的一种使用方法，这是“类型IterT对象指向的类型“的C++实现方式。这个句子声明了一个本地变量(temp)，它的类型同IterT对象指向的对象的类型一致，它将temp初始化为iter指向的对象。如果IterT是vector<int>::iterator，那么temp就是int类型的。如果IterT是list<string>::iterator，temp就是string类型的。因为std::iterator_traits<itert>::value_type是一个内嵌依赖类型名字（在iterator_traits<itert>内部value_type是内嵌的，IterT是一个模板参数），我们必须为其添加typename。</itert></itert></string></int></itert></p>
<p>如果你认为读std::iterator_traits<itert>::value_type是一件不让人愉快的事情，想像一下将其打出来会是什么样的。如果你像大部分程序员一样，多次输入这个表达式的想法是可怕的，所以你会想为其创建一个typedef。对于像value_type这样的特性（traits）成员名字来说（对于特性的信息看Item47）,使用惯例是使得typedef名字和特性成员名字相同，所以这样一个本地typedef通常被定义成下面这样：</itert></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;typename IterT&gt;</div><div class="line">void workWithIterator(IterT iter)</div><div class="line">&#123;</div><div class="line">typedef typename std::iterator_traits&lt;IterT&gt;::value_type value_type;</div><div class="line">value_type temp(*iter);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>许多程序员发现将“typedef typename“并列看上去不和谐，但是对于使用内嵌依赖类型名字的规则来说，这是一个合乎逻辑的结果。你会很快习惯这种用法。毕竟，你有着很强的驱动力。你想输入typename std::iterator_traits<itert>::value_type多少次呢？</itert></p>
<h2 id="5-Typename的执行因编译器而异"><a href="#5-Typename的执行因编译器而异" class="headerlink" title="5. Typename的执行因编译器而异"></a>5. Typename的执行因编译器而异</h2><p>作为结束语，我应该提及的是关于typename规则的强制执行随着编译器的不同而不同，一些编译器接受需要typename但实际上没有输入的情况；一些编译器接受输入了typename但实际上不允许的情况；还有一些（通常是老的编译器）在需要输入typename时拒绝了typename输入。这就意味着typename和内嵌依赖类型名字的交互会产生让你头痛的问题。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul>
<li>当声明模板参数的时候，class和typename是可以互换的。</li>
<li>使用typename来识别内嵌依赖类型名字，但在基类列表中或者成员初始化列表中的基类标识符除外。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-class和typename含义相同的例子&quot;&gt;&lt;a href=&quot;#1-class和typename含义相同的例子&quot; class=&quot;headerlink&quot; title=&quot;1. class和typename含义相同的例子&quot;&gt;&lt;/a&gt;1. class和typenam
    
    </summary>
    
      <category term="Effective c++" scheme="http://yoursite.com/categories/Effective-c/"/>
    
    
      <category term="effective c++" scheme="http://yoursite.com/tags/effective-c/"/>
    
  </entry>
  
</feed>
