<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="HarlanC's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="生有涯，知无涯。">
<meta property="og:type" content="website">
<meta property="og:title" content="HarlanC&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="HarlanC&#39;s Blog">
<meta property="og:description" content="生有涯，知无涯。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HarlanC&#39;s Blog">
<meta name="twitter:description" content="生有涯，知无涯。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>HarlanC's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HarlanC's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/19/2017-02-19_09_32_读书笔记_effective_c++_Item_14_对资源管理类的拷贝行为要谨慎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/19/2017-02-19_09_32_读书笔记_effective_c++_Item_14_对资源管理类的拷贝行为要谨慎/" itemprop="url">读书笔记 effective c++ Item 14 对资源管理类的拷贝行为要谨慎</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-19T09:32:00+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/19/2017-02-19_09_32_读书笔记_effective_c++_Item_14_对资源管理类的拷贝行为要谨慎/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 14 对资源管理类的拷贝行为要谨慎">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="1-自己实现一个资源管理类"><a href="#1-自己实现一个资源管理类" class="headerlink" title="1. 自己实现一个资源管理类"></a>1. 自己实现一个资源管理类</h2><p><a href="http://www.cnblogs.com/harlanc/p/6412222.html" title="Item 13" target="_blank" rel="external">Item 13</a>中介绍了 “资源获取之时也是初始化之时（RAII）”的概念，这个概念被当作资源管理类的“脊柱“，也描述了auto_ptr和<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/19/2017-02-19_09_32_读书笔记_effective_c++_Item_14_对资源管理类的拷贝行为要谨慎/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/18/2017-02-18_07_56_读书笔记_effective_c++_Item_13_用对象来管理资源/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/18/2017-02-18_07_56_读书笔记_effective_c++_Item_13_用对象来管理资源/" itemprop="url">读书笔记 effective c++ Item 13 用对象来管理资源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-18T07:56:00+08:00">
                2017-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/18/2017-02-18_07_56_读书笔记_effective_c++_Item_13_用对象来管理资源/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 13 用对象来管理资源">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-不要手动释放从函数返回的堆资源"><a href="#1-不要手动释放从函数返回的堆资源" class="headerlink" title="1.不要手动释放从函数返回的堆资源"></a>1.不要手动释放从函数返回的堆资源</h2><p>假设你正在处理一个模拟Investment的程序库，不同的Investmetn类型从Investment基类继承而来，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">class</span> <span class="title">Investment</span> &#123; ... &#125;; <span class="comment">// root class</span></div><div class="line">&lt;!--more--&gt;</div><div class="line">of hierarchy of</div><div class="line"></div><div class="line"> <span class="comment">// investment types</span></div></pre></td></tr></table></figure>
<p>进一步假设这个程序库通过一个工厂函数(Item 7)来给我们提供特定Investment对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Investment* createInvestment(); <span class="comment">// return ptr to dynamically allocated</span></div><div class="line"></div><div class="line"><span class="comment">// object in the Investment hierarchy;</span></div><div class="line"></div><div class="line"><span class="comment">// the caller must delete it</span></div><div class="line"></div><div class="line"><span class="comment">// (parameters omitted for simplicity)</span></div></pre></td></tr></table></figure>
<p>正如注释所表述的，当createInvesment返回的对象不再被使用时，调用者有责任将此对象释放掉。我们用函数f来履行这个职责：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span>(<span class="params"></span>)</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">Investment *pInv = createInvestment(); <span class="comment">// call factory function</span></div><div class="line"></div><div class="line">... <span class="comment">// use pInv</span></div><div class="line"></div><div class="line">delete pInv; <span class="comment">// release object</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法看上去挺好，但是在一些情况下释放从createInvestment得来的对象有可能会失败。在函数的”…”部分中有可能会出现过早的reture语句，如果这个return被执行了，那么最后的delete语句永远不会被执行到；如果createInvesment和delete在一个循环中，break和goto语句会使循环过早退出，delete也不会被执行到；最后在…中的一些语句有可能会抛出异常，如果这样的话，控制流程会再次不能执行到delete。不管delete是怎么被跳过去的，不仅会泄露Invesment对象所使用的内存，也会泄露Investment对象所拥有的任何资源。</p>
<p>当然，小心的编程可以防止这类错误的发生，但是你应该想到随着时间的推移代码有可能发生变化。在软件的维护过程中，一些人可能在没有完全领会这个函数的资源管理策略的情况下为其添加一个return或者continue语句。更糟糕的是，f函数的”…”部分有可能调用一个从来没有抛出异常的函数，但这个函数被“改善”后，它抛出异常了。所以依赖f来到达delete语句通常是不可行的。</p>
<h2 id="2-通过对象来管理需要手动释放的资源"><a href="#2-通过对象来管理需要手动释放的资源" class="headerlink" title="2.通过对象来管理需要手动释放的资源"></a>2.通过对象来管理需要手动释放的资源</h2><p>为了确保从createInvestment返回的资源总是被释放，我们需要将资源放到一个对象中，当离开函数f的时候，对象的析构函数会自动释放对象拥有的资源。事实上，我们已经说出了这个条款一半的内容：<strong>通过将资源放入对象中，我们可以依赖**</strong>c++<strong>**的析构函数自动调用机制来确保资源被释放</strong>。（另一半一会就会讲到）</p>
<h3 id="2-1-使用auto-ptr来管理资源"><a href="#2-1-使用auto-ptr来管理资源" class="headerlink" title="2.1 使用auto_ptr来管理资源"></a>2.1 使用auto_ptr来管理资源</h3><p>许多资源是被动态的分配在堆上的，它们被用在一个单独的块或者函数中，当控制流离开块或者函数时，这些资源应该被释放。标准库中的auto_ptr正是为这种情况量身定做的。Auto_ptr是一个指针（智能指针）一样的对象，它的析构函数会自动为其指向的对象调用delete函数。下面演示如何使用auto_ptr来防止可能出现的资源泄露：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void f()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); // call factory</div><div class="line"></div><div class="line">// function</div><div class="line"></div><div class="line">... // use pInv as</div><div class="line"></div><div class="line">// before</div><div class="line"></div><div class="line">&#125; // automatically</div><div class="line"></div><div class="line">// delete pInv via</div><div class="line"></div><div class="line">// auto_ptr’s dtor</div></pre></td></tr></table></figure>
<h3 id="2-2-用对象管理资源的两个关键点"><a href="#2-2-用对象管理资源的两个关键点" class="headerlink" title="2.2 用对象管理资源的两个关键点"></a>2.2 用对象管理资源的两个关键点</h3><p>这个简单的例子指出了使用对象管理资源的两个关键点：</p>
<ul>
<li><strong>获取资源后应该立即将其转交给资源管理对象</strong>。从上面的例子看出，使用createInvestment返回的资源来初始化对其进行管理的auto_ptr指针。事实上，用对象来管理资源的想法通常被叫做”资源获取的时候就是初始化的时候”(Resource Acquisition Is Initialization RAII）,因为将资源获取和资源管理对象的初始化放在同一个语句中是非常常见的。有时用获取的资源给资源管理对象赋值而不是初始化，但是不管哪种方法，都是在资源获取到之后马上将控制权转交给资源管理对象。</li>
<li><strong>资源管理对象使用它们的析构函数来确保资源被释放</strong>。因为不管控制流是怎么离开块或函数的，对象销毁的时候析构函数会被自动调用（例如当一个对象超出了作用域），资源因此能够被正确释放。释放资源时抛出异常会使问题变的棘手，这个问题在Item8中讨论了，我们不再担心这种问题。</li>
</ul>
<p>因为 当auto_ptr被销毁时会自动delete它所指向的资源，所以有没有多个auto_ptr指向通一个对象是很重要的。如果有多个，对象会被多次delete,这就会导致出现未定义行为。为了防止这样的问题出现，auto_ptrs有一个与众不同的性质：<strong>被拷贝的指针（通过拷贝构造函数或者拷贝赋值运算符）会被置为**</strong>null<strong>**，进行拷贝的指针将拥有资源的所有权</strong>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">std::auto_ptr&lt;Investment&gt; // pInv1 points to the</div><div class="line"></div><div class="line">pInv1(createInvestment()); // object returned from</div><div class="line"></div><div class="line">// createInvestment</div><div class="line"></div><div class="line">std::auto_ptr&lt;Investment&gt; pInv2(pInv1); // pInv2 now points to the</div><div class="line"></div><div class="line">// object; pInv1 is now null</div><div class="line"></div><div class="line">pInv1 = pInv2; // now pInv1 points to the</div><div class="line"></div><div class="line">// object, and pInv2 is null</div></pre></td></tr></table></figure>
<h3 id="2-3-用shared-ptr来管理资源"><a href="#2-3-用shared-ptr来管理资源" class="headerlink" title="2.3 用shared_ptr来管理资源"></a>2.3 用shared_ptr来管理资源</h3><p>奇特的拷贝行为，加上“不能有超过一个的auto_ptr指向被auto_ptr管理的资源”，这两种特性使得auto_ptrs不是管理所有动态分配资源的最好方法。举个例子，STL容器需要”正常的”拷贝行为，因此就不能将容器放入auto_ptr中。</p>
<p>Auto_ptr的一种替代方法是使用“引用计数的智能指针”（reference-counting smart pointer RCSP）.RCSP是一种能够跟踪有多少对象指向同个一特定资源的指针，资源只有在没有指针指向的情况下才能被释放。因此，RCSP提供的行为同垃圾回收机制类似。和垃圾回收机制不同的是，RCSP不会制止循环引用（例如，两个都不被使用的对象却指向彼此，看上去在被使用一样。）</p>
<p>TR1的tr1::shared_ptr(看Item54)是是一个RCSP,所以你可以这么实现f:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void f()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">std::tr1::shared_ptr&lt;Investment&gt;</div><div class="line"></div><div class="line">pInv(createInvestment()); // call factory function</div><div class="line"></div><div class="line">... // use pInv as before</div><div class="line"></div><div class="line">&#125; // automatically delete</div><div class="line"></div><div class="line">// pInv via shared_ptr’s dtor</div></pre></td></tr></table></figure>
<p>这段代码看上去同使用auto_ptr大致相同，但是拷贝shared_ptrs的行为更加自然：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void f()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">std::tr1::shared_ptr&lt;Investment&gt; // pInv1 points to the</div><div class="line"></div><div class="line">pInv1(createInvestment()); // object returned from</div><div class="line"></div><div class="line">// createInvestment</div><div class="line"></div><div class="line">std::tr1::shared_ptr&lt;Investment&gt; // both pInv1 and pInv2 now</div><div class="line">pInv2(pInv1); // point to the object</div><div class="line">pInv1 = pInv2; // ditto — nothing has</div><div class="line">// changed</div><div class="line">...</div><div class="line">&#125; // pInv1 and pInv2 are</div><div class="line">// destroyed, and the</div><div class="line">// object they point to is</div><div class="line">// automatically deleted</div></pre></td></tr></table></figure>
<p>因为拷贝tr1::shared_ptrs的工作方式是你所想要的，它们可以被用在像STL容器和其他上下文中，在这里auto_ptr的古怪的拷贝方式不再合适。</p>
<h3 id="2-4-不要将auto-ptr和shared-ptr用于动态分配数组"><a href="#2-4-不要将auto-ptr和shared-ptr用于动态分配数组" class="headerlink" title="2.4 不要将auto_ptr和shared_ptr用于动态分配数组"></a>2.4 不要将auto_ptr和shared_ptr用于动态分配数组</h3><p>不要被误导。这个条款不是用来介绍关于auto_ptr,tr1::shared_ptr或者其它类型的智能指针。这个条款讲述的是用对象管理资源的重要性。使用Auto_ptr和tr1::shared_ptr只是举个例子。（关于tr1::shared_ptr的更多内容，查看Item14 18和54）</p>
<p>Auto_ptr和tr1::shared_ptr的析构函数中使用的是delete而不是delete[]。（Item16 描述了区别）这意味着在auto_ptr或者tr1::shared_ptr中存放动态分配的数组不是一个好方法，令人遗憾的是，这种用法可以通过编译：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">std::auto_ptr&lt;std::string&gt; // bad idea! the wrong</div><div class="line"></div><div class="line">aps(new std::string[10]); // delete form will be used</div><div class="line"></div><div class="line">std::tr1::shared_ptr&lt;int&gt; spi(new int[1024]); // same problem</div></pre></td></tr></table></figure>
<p>你会惊奇的发现c++中没有用于动态分配数组的类似auto_ptr或者tr1::shared_ptr的东西，TR1中也没有。因为vector和string基本可以替代动态分配数组了。如果你仍然认为存在用于动态分配数组的类似于auto_ptr和tr1::shared_ptr的类是好的，可以看一下Boost（Item 55）.你会非常高兴的发现boost::scoped_array和boost::shared_array类提供了你正在寻找的。</p>
<h2 id="3-其他问题"><a href="#3-其他问题" class="headerlink" title="3.其他问题"></a>3.其他问题</h2><p>这个条款中，使用对象管理资源的指导方针意味着如果你自己手动释放资源（例如使用delete而不是一个资源管理类），你的做法就是错误的。 预装的资源管理类，像auto_ptr和tr1::shared_ptr使遵守这个条款变的更加容易，但有时候当你使用一个资源的时候你会发现这些预制的类没有做到你想要的。这种情况下，你就需要编写你自己的资源管理类了。这也不是非常难的，但确实有一些微妙的地方需要你考虑。这些注意点将要在Item14和Item15种进行讨论。</p>
<p>最后，我必须指出createInvestment的原生指针返回类型是资源泄露的导火索，因为调用者很容易就会忘记调用delete(即使使用auto_ptr和tr1::shared_ptr来执行delete，它们仍然需要记得将createInvestment的返回值放入智能指针对象中)。对付这个问题需要调用createInvestment的修订版本，这个问题会在Item18中进行讨论。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/17/2017-02-17_07_42_读书笔记_effective_c++_Item_12_拷贝对象的所有部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/17/2017-02-17_07_42_读书笔记_effective_c++_Item_12_拷贝对象的所有部分/" itemprop="url">读书笔记 effective c++ Item 12 拷贝对象的所有部分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-17T07:42:00+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/17/2017-02-17_07_42_读书笔记_effective_c++_Item_12_拷贝对象的所有部分/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 12 拷贝对象的所有部分">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="1-默认构造函数介绍"><a href="#1-默认构造函数介绍" class="headerlink" title="1.默认构造函数介绍"></a>1.默认构造函数介绍</h2><p>在设计良好的面向对象系统中，会将对象的内部进行封装，只有两个函数可以拷贝对象：<strong>拷贝构造函数和拷贝赋值运算符</strong>。我们把这两个函数统一叫做拷贝函数。从Item5中，我们得知，如果需要的话编译器会为你生成这两个拷贝函数，并且编译器生成的版本能够精确的做到你想做的：它们拷贝了<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/17/2017-02-17_07_42_读书笔记_effective_c++_Item_12_拷贝对象的所有部分/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/2017-02-15_23_48_读书笔记_effective_c++_Item_11_在operator=中处理自我赋值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/15/2017-02-15_23_48_读书笔记_effective_c++_Item_11_在operator=中处理自我赋值/" itemprop="url">读书笔记 effective c++ Item 11 在operator=中处理自我赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-15T23:48:00+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/15/2017-02-15_23_48_读书笔记_effective_c++_Item_11_在operator=中处理自我赋值/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 11 在operator=中处理自我赋值">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-自我赋值是如何发生的"><a href="#1-自我赋值是如何发生的" class="headerlink" title="1.自我赋值是如何发生的"></a>1.自我赋值是如何发生的</h2><p>当一个对象委派给自己的时候，自我赋值就会发生：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">class</span> <span class="title">Widget</span> &#123; ... &#125;;</div><div class="line"></div><div class="line"> Widget w;</div><div class="line"></div><div class="line"> ...</div><div class="line"></div><div class="line"> w = w; <span class="comment">// assignment to</span></div><div class="line">&lt;!--more--&gt;</div><div class="line">self、</div></pre></td></tr></table></figure>
<p>这看上去是愚蠢的，但这是合法的，所以请放心，客户端是可以这么做的。此外，自身赋值也并不总是很容易的能够被辨别出来。举个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[i] = a[j]; <span class="comment">// potential assignment to self</span></div></pre></td></tr></table></figure>
<p>上面的代码在ｉ和ｊ相等的情况下就是自我赋值，同样的，看下面的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*px = *py; <span class="comment">// potential assignment to self</span></div></pre></td></tr></table></figure>
<p>如果px和py恰巧指向同一个东西，那么上面的语句就是自身赋值。这些并不怎么明显的自我赋值是使用别名的结果：<strong>也就是使用不止一种方法来指向同一个对象</strong>。一般情况下，当我们操作指向不同同类型对象的引用和指针时，需要考虑这些不同的对象是否是同一个对象。事实上，如果两个对象来自同一个继承体系，这两个对象甚至不必声明为同类型的，因为基类的指针或者引用可以指向派生类对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Base</span> &#123; ... &#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Derived</span>: <span class="title">public</span> <span class="title">Base</span> &#123; ... &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span>(<span class="params"><span class="keyword">const</span> Base&amp; rb, // rb and *pd might actually be</span></span></div><div class="line"></div><div class="line">Derived* pd); <span class="comment">// the same object</span></div></pre></td></tr></table></figure>
<h2 id="2-处理不好自我赋值会使你掉入陷阱"><a href="#2-处理不好自我赋值会使你掉入陷阱" class="headerlink" title="2.处理不好自我赋值会使你掉入陷阱"></a>2.处理不好自我赋值会使你掉入陷阱</h2><p>如果你遵循Item13和Item14的建议，你就会使用对象来管理资源，并且你也能够确信对资源进行管理的对象在进行拷贝时会运行的很好。在这种情况下，你的赋值运算符有可能就是自我赋值安全的，而不用去特定的考虑这件事情。如果你尝试自己来管理资源（如果你自己写一个资源管理类这是必须做的），你可能会掉入一个陷阱：<strong>在用完某个资源之前，资源突然被释放掉了</strong>。举个例子，假设你创建了一个类来管理一个原生指针，这个指针指向动态分配的bitmap对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123; ... &#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">Bitmap *pb; <span class="comment">// ptr to a heap-allocated object</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面是operator=的一个实现，从表面上看是合理的，但因为自我赋值的存在，实际上它是不安全的。（它也不是异常安全的，我们稍会会处理）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Widget&amp;</div><div class="line"></div><div class="line">Widget::operator=(const Widget&amp; rhs) // unsafe impl. of operator=</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">delete pb; // stop using current bitmap</div><div class="line"></div><div class="line">pb = new Bitmap(*rhs.pb); // start using a copy of rhs’s bitmap</div><div class="line"></div><div class="line">return *this; // see Item 10</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自我赋值的问题出现在operator=内部，*this（赋值目标）和rhs可能是同一个对象。如果这是真的，delete不仅会为当前对象销毁bitmap,也同样会为ths销毁bitmap。在函数的结尾，Widget对象本不应该通过自我赋值有所改变，但你会发现现在它拥有的是一个指向被删除对象的指针！</p>
<h2 id="3-处理自我赋值的方法一：鉴定测试，防止自我赋值"><a href="#3-处理自我赋值的方法一：鉴定测试，防止自我赋值" class="headerlink" title="3.处理自我赋值的方法一：鉴定测试，防止自我赋值"></a>3.处理自我赋值的方法一：鉴定测试，防止自我赋值</h2><h3 id="3-1-实现代码"><a href="#3-1-实现代码" class="headerlink" title="3.1 实现代码"></a>3.1 实现代码</h3><p>防止这个错误的传统方法是<strong>在**</strong>operator=<strong>**函数的开始进行一个鉴定测试</strong>，看是否是一个自我赋值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Widget&amp; Widget::operator=(const Widget&amp; rhs)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">if (this == &amp;rhs) return *this; // identity test: if a self-assignment,</div><div class="line"></div><div class="line">// do nothing</div><div class="line"></div><div class="line">delete pb;</div><div class="line"></div><div class="line">pb = new Bitmap(*rhs.pb);</div><div class="line"></div><div class="line">return *this;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2这个方法的缺陷"><a href="#3-2这个方法的缺陷" class="headerlink" title="3.2这个方法的缺陷"></a>3.2这个方法的缺陷</h3><p>这个方法是可以工作的，但是上面已经提到operator=的早先版本不仅是自我赋值不安全的，同样也是异常不安全的(exception-unsafe)，在当前版本中关于异常的麻烦会继续存在。特别的，如果”new Bitmap”语句产生一个异常（因为没有足够的内存可以分配或者因为Bitmap的拷贝构造函数抛出一个异常），Widget将会拥有一个指向被删除Bitmap对象的指针。这样的指针是有毒的，因为你不能够安全的释放它们。你甚至不能够安全的读取它们。你唯一能够做的安全的事情就是花费大量的调试的精力来找出问题出在哪里。</p>
<h2 id="4-处理自我赋值的方法二：对语句进行排序"><a href="#4-处理自我赋值的方法二：对语句进行排序" class="headerlink" title="4.处理自我赋值的方法二：对语句进行排序"></a>4.处理自我赋值的方法二：对语句进行排序</h2><p> 让人高兴的是，使operator=变得异常安全的方法也往往能使其变得自我赋值安全。所以，我们将自我赋值 的问题忽略掉，集中精力去达到异常安全。Item29比较深入的探索了异常安全，在这个条款中，我们只需要观察：<strong>对一些语句进行仔细的排序就可以生成**</strong>exception<strong>**安全（同样能够达到自我赋值安全）的代码</strong>，这就足够了。举个例子，我们只需要注意在对pb指向对象的拷贝完成之前不要将pb释放:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Widget&amp; Widget::operator=(const Widget&amp; rhs)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">Bitmap *pOrig = pb; // remember original pb</div><div class="line"></div><div class="line">pb = new Bitmap(*rhs.pb); // point pb to a copy of rhs’s bitmap</div><div class="line"></div><div class="line">delete pOrig; // delete the original pb</div><div class="line"></div><div class="line">return *this;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，如果”new BItmap”抛出异常，pb仍然不会发生变化。在没有鉴别测试的情况下，这段代码进行了自我赋值，因为我们将源bitmap做了一份拷贝，让pb去指向拷贝的数据，然后删除源bitmap。这也许不是处理自我赋值的最有效率的方法，但这确实是可行的方法。</p>
<p>如果你关系效率，你可以将鉴别测试的代码重新放回到函数的开始处。但是在这么做之前，问问你自己，自我赋值发生的频率会有多高，因为鉴别测试不是免费的。它会增加一些代码（obj文件也会增大），同时引入了一个流程控制的分支，两者都会使得程序运行速度变慢。Prefetching,caching和pipelining指令的效率都会降低。</p>
<h2 id="5-处理自我赋值的方法三：copy-and-swap"><a href="#5-处理自我赋值的方法三：copy-and-swap" class="headerlink" title="5.处理自我赋值的方法三：copy and swap"></a>5.处理自我赋值的方法三：<strong>copy and swap</strong></h2><h3 id="5-1-实现方法一"><a href="#5-1-实现方法一" class="headerlink" title="5.1 实现方法一"></a>5.1 实现方法一</h3><p>我们换一种方法来对operator=中的语句进行手动排序，来同时保证自我赋值和异常安全，<strong>这种技术叫做拷贝和交换**</strong>(copy  and swap)**。这种技术与异常安全是紧密相关的，所以会在Item29中描述。然而，它也是实现operator=的一个非常普通的方法，因此值得我们来看看这种实现方法究竟是什么样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Widget &#123;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">void swap(Widget&amp; rhs); // exchange *this’s and rhs’s data;</div><div class="line"></div><div class="line">... // see Item 29 for details</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">Widget&amp; Widget::operator=(const Widget&amp; rhs)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">Widget temp(rhs); // make a copy of rhs’s data</div><div class="line"></div><div class="line">swap(temp); // swap *this’s data with the copy’s</div><div class="line"></div><div class="line">return *this;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-实现方法二"><a href="#5-2-实现方法二" class="headerlink" title="5.2 实现方法二"></a>5.2 实现方法二</h3><p>利用下面的两个事实我们可以将上面的实现换一种写法，这两个事实是：（1）<strong>一个类的拷贝赋值运算符可以被声明为按值传递</strong>。(2)<strong>按值传递会对值进行拷贝</strong>。下面是另外一种写法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Widget&amp; Widget::operator=(Widget rhs) // rhs is a copy of the object</div><div class="line"></div><div class="line">&#123; // passed in — note pass by val</div><div class="line"></div><div class="line">swap(rhs); // swap *this’s data with</div><div class="line"></div><div class="line">// the copy’s</div><div class="line"></div><div class="line">return *this;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从个人观点来说，我担心这种方法为了聪明的实现而牺牲了代码的清晰度，但是通过将拷贝操作从函数体内移动到函数的参数中，编译器有时候能够产生更高效的代码，这是事实。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/2017-02-15_23_42_读书笔记_effective_c++_Item_10_让赋值运算符返回指向_this的引用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/15/2017-02-15_23_42_读书笔记_effective_c++_Item_10_让赋值运算符返回指向_this的引用/" itemprop="url">读书笔记 effective c++ Item 10 让赋值运算符返回指向*this的引用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-15T23:42:00+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/15/2017-02-15_23_42_读书笔记_effective_c++_Item_10_让赋值运算符返回指向_this的引用/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 10 让赋值运算符返回指向*this的引用">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>一个关于赋值的有趣的事情是你可以将它们链在一起：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x, y, z;</div><div class="line"></div><div class="line">x = y = z = <span class="number">15</span>; <span class="comment">// chain of assignments</span></div></pre></td></tr></table></figure>
<p>同样有趣的是赋值<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/15/2017-02-15_23_42_读书笔记_effective_c++_Item_10_让赋值运算符返回指向_this的引用/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/2017-02-15_00_04_读书笔记_effective_c++_Item_9_绝不要在构造函数或者析构函数中调用虚函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/15/2017-02-15_00_04_读书笔记_effective_c++_Item_9_绝不要在构造函数或者析构函数中调用虚函数/" itemprop="url">读书笔记 effective c++ Item 9 绝不要在构造函数或者析构函数中调用虚函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-15T00:04:00+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/15/2017-02-15_00_04_读书笔记_effective_c++_Item_9_绝不要在构造函数或者析构函数中调用虚函数/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 9 绝不要在构造函数或者析构函数中调用虚函数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="1-关于构造函数的一个违反直觉的行为"><a href="#1-关于构造函数的一个违反直觉的行为" class="headerlink" title="1.关于构造函数的一个违反直觉的行为"></a>1.关于构造函数的一个违反直觉的行为</h2><p>我会以重复标题开始：你不应该在构造或者析构的过程中调用虚函数，因为这些调用的结果会和你想的不一样。如果你同时是一个java或者c#程序员，那么请着重注意这个条款，因为这是c++同它们不一样的地方。</p>
<p>假设你已经有一个为股票交易建模的类<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/15/2017-02-15_00_04_读书笔记_effective_c++_Item_9_绝不要在构造函数或者析构函数中调用虚函数/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/14/2017-02-14_07_34_读书笔记_effective_c++_Item_8_不要让异常(exceptions)离开析构函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/14/2017-02-14_07_34_读书笔记_effective_c++_Item_8_不要让异常(exceptions)离开析构函数/" itemprop="url">读书笔记 effective c++ Item 8 不要让异常(exceptions)离开析构函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-14T07:34:00+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/14/2017-02-14_07_34_读书笔记_effective_c++_Item_8_不要让异常(exceptions)离开析构函数/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 8 不要让异常(exceptions)离开析构函数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-为什么c-不喜欢析构函数抛出异常"><a href="#1-为什么c-不喜欢析构函数抛出异常" class="headerlink" title="1.为什么c++不喜欢析构函数抛出异常"></a>1.为什么c++不喜欢析构函数抛出异常</h2><p>C++并没有禁止析构函数出现异常，但是它肯定不鼓励这么做。这是有原因的，考虑下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> class Widget &#123;</div><div class="line"></div><div class="line"> public:</div><div class="line"></div><div class="line"> ...</div><div class="line"></div><div class="line"></div><div class="line">&lt;!--more--&gt;</div><div class="line">~Widget() &#123; ... &#125; // assume this might emit an exception</div><div class="line"></div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> void doSomething()</div><div class="line"></div><div class="line"> &#123;</div><div class="line"></div><div class="line"> std::vector&lt;Widget&gt; v;</div><div class="line"></div><div class="line"> ...</div><div class="line"></div><div class="line"> &#125; // v is automatically destroyed here</div></pre></td></tr></table></figure>
<p>当vector V被销毁，V有责任将它包含的所有Widgets都销毁。假设v含有有10个Widgets对象，当销毁第一个Widgets对象时，抛出了一个异常。其余的9个仍然需要被释放掉（否则它们拥有的资源会被泄露），所以V应该触发其余9个对象所有的析构函数。但是假设在这9个析构函数调用过程中，第二个Widget的析构函数抛出了一个异常。现在有两个主动抛出的异常了，这对c++来说太多了。<strong>在两个异常同时出现的情况下，程序的执行要么终止要么产生未定义行为</strong>。在这个例子中，它会产生未定义行为。使用任何其他标准库容器(如list或set)或者TR1中的容器，甚至一个数组也将会产生同样的未定义行为。出现这种麻烦并不只是在容器或者数组中出现。在不使用容器或者数组的情况下，析构函数抛出的异常也可以使程序过早终止或者出现未定义行为。C++不喜欢析构函数发出异常！</p>
<h2 id="2-一个例子-DB资源管理类"><a href="#2-一个例子-DB资源管理类" class="headerlink" title="2.一个例子-DB资源管理类"></a>2.一个例子-DB资源管理类</h2><p>这很容易理解，但是析构函数需要执行的操作有可能由于异常被抛出而导致失败，这时候我们应该怎么做？举个例子，假设你在实现一个关于数据库连接的类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">DBConnection</span> &#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span>(<span class="params"></span>)</span>; <span class="comment">// function to return</span></div><div class="line"></div><div class="line"><span class="comment">// DBConnection objects; params</span></div><div class="line"></div><div class="line"><span class="comment">// omitted for simplicity</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span>(<span class="params"></span>)</span>; <span class="comment">// close connection; throw an</span></div><div class="line"></div><div class="line">&#125;; <span class="comment">// exception if closing fails</span></div></pre></td></tr></table></figure>
<p>为了确保客户端不会忘记调用DBConnection对象的close函数，为DBConnestion创建一个资源管理类是一个理想的方法，close函数会在资源管理类的析构函数中被调用。这样的资源管理类将在第三章有详细的讲述，在这里，考虑这样一个类的析构函数会长成什么样子就足够了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">DBConn</span> &#123; <span class="comment">// class to manage DBConnection</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>: <span class="comment">// objects</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">~DBConn() <span class="comment">// make sure database connections</span></div><div class="line"></div><div class="line">&#123; <span class="comment">// are always closed</span></div><div class="line"></div><div class="line">db.close();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">DBConnection db;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>于是客户端代码可以写成这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="comment">// open a block</span></div><div class="line"></div><div class="line"><span class="function">DBConn <span class="title">dbc</span>(<span class="params">DBConnection::create(</span>))</span>; <span class="comment">// create DBConnection object</span></div><div class="line"></div><div class="line"><span class="comment">// and turn it over to a DBConn</span></div><div class="line"></div><div class="line"><span class="comment">// object to manage</span></div><div class="line"></div><div class="line">... <span class="comment">// use the DBConnection object</span></div><div class="line"></div><div class="line"><span class="comment">// via the DBConn interface</span></div><div class="line"></div><div class="line">&#125; <span class="comment">// at end of block, the DBConn</span></div><div class="line"></div><div class="line"><span class="comment">// object is destroyed, thus</span></div><div class="line"></div><div class="line"><span class="comment">// automatically calling close on</span></div><div class="line"></div><div class="line"><span class="comment">// the DBConnection object</span></div></pre></td></tr></table></figure>
<p>只要close函数的调用成功了这个实现就是很好的，但是如果调用产生一个异常，DBConn的析构函数会传播这个异常，也就是<strong>允许异常离开析构函数。这是一个问题，因为在析构函数中发生**</strong>throw<strong>**就意味这麻烦。</strong></p>
<h2 id="3-如何阻止析构函数中的异常被传播出去"><a href="#3-如何阻止析构函数中的异常被传播出去" class="headerlink" title="3.如何阻止析构函数中的异常被传播出去"></a>3.如何阻止析构函数中的异常被传播出去</h2><p>有两种方法来避免这个麻烦。DBConn的析构函数可以这么做：</p>
<h3 id="3-1用abort函数使程序终止"><a href="#3-1用abort函数使程序终止" class="headerlink" title="3.1用abort函数使程序终止"></a>3.1用abort函数使程序终止</h3><p>如果close函数抛出异常就将程序终止，可以调用abort函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">DBConn::~DBConn()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">try &#123; db.close(); &#125;</div><div class="line"></div><div class="line">catch (...) &#123;</div><div class="line"></div><div class="line">make log entry that the call to close failed;</div><div class="line"></div><div class="line">std::abort();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在执行析构函数的时候遇到一个错误程序就不能继续运行了，上面的做法会是一个合理的选择。它的优点是能够阻止异常从析构函数传播出去，传播异常会导致未定义行为。因此，对于未定义行为，调用abort能够先发制人。</p>
<h3 id="3-2-将异常吞掉"><a href="#3-2-将异常吞掉" class="headerlink" title="3.2 将异常吞掉"></a>3.2 将异常吞掉</h3><p>将调用close时抛出的异常吞掉</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">DBConn::~DBConn()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">try &#123; db.close(); &#125;</div><div class="line"></div><div class="line">catch (...) &#123;</div><div class="line"></div><div class="line">make log entry that the call to close failed;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在一般情况下，将异常吞掉是一个坏的方法，因为它会抑制重要错误信息-有一些失败的事情-的出现！但是有时候，比起程序过早终止或者未定义行为，将异常吞掉会是更好的方法。这是一个可行的选择，程序必须能够可靠的继续执行下去甚至在碰到错误出现然后将其忽略的情况。</p>
<p>这两种方法都不是特别吸引人。这两种的方法的问题是，程序没有办法在第一时间对导致close抛出异常的条件做出反应。</p>
<hr>
<h2 id="4-一个更好的方法-使类能够对异常做出反应"><a href="#4-一个更好的方法-使类能够对异常做出反应" class="headerlink" title="4.一个更好的方法-使类能够对异常做出反应"></a>4.一个更好的方法-使类能够对异常做出反应</h2><hr>
<p>一个更好的方法是对DBConn的接口进行设计，于是客户端有机会对可能出现的问题做出反应。举个例子，DBConn类自己可以提供一个close函数，这就可以给客户端一个处理从close抛出异常的机会，同时也能够追踪DBConnection是否已经被关掉了，如果在close中没有被关掉就在析构函数中再次执行。这就阻止了连接无法被正确释放。如果在DBConn的析构函数中对close的调用将会失败，我们还得使用终止程序或者吞掉异常的方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span>(<span class="params"></span>) <span class="comment">// new function for</span></span></div><div class="line"></div><div class="line">&#123; <span class="comment">// client use</span></div><div class="line"></div><div class="line">db.close();</div><div class="line"></div><div class="line">closed = <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">~DBConn()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!closed) &#123;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123; <span class="comment">// close the connection</span></div><div class="line"></div><div class="line">db.close(); <span class="comment">// if the client didn’t</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">catch</span> (...) &#123; <span class="comment">// if closing fails,</span></div><div class="line"></div><div class="line">make log entry that call to close failed; <span class="comment">// note that and</span></div><div class="line"></div><div class="line">... <span class="comment">// terminate or swallow</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">DBConnection db;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> closed;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>将调用close的责任从DBConn的析构函数转移到DBConn的客户端（因为DBConn的析构函数有一个“备份”调用）可能会给你肆无忌惮转移负担的印象。你可能甚至将这种做法当成Item18给出意见的反例（使接口容易被正确使用）。事实上，这两种想法都是错的。如果一个操作有可能因为抛出异常而导致失败，而我们有可能需要去处理这个异常，这个异常必须来自非析构函数才可以。因为析构函数抛出异常是很危险的，常常会导致程序过早终止或者未定义行为。在这个例子中，告诉客户端自己调用close函数并没有给它们增加负担；这反而给了它们一个处理错误的机会，否则就没有机会对错误做出反应了。如果他们发现这个机会没有什么用(可能因为他们相信没有错误会发生)，他们可以忽略它，仅依靠DBConn的析构函数在调用close。如果这时出现了错误-close确实抛出了异常-他们没有资格抱怨DBConn吞掉了异常或者终止了程序。毕竟，他们原来有机会处理这个问题，但是他们没有这么做。<strong> </strong></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><ul>
<li>析构函数不能够发出任何异常。如果在析构函数中调用某个函数可能会发生throw,析构函数应该catch所有异常然后吞掉他们或者终止程序。</li>
<li>如果类的客户端需要对一个操作的异常throw做出反应，这个类应该提供一个普通函数来执行这个操作。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/2017-02-13_19_01_读书笔记_effective_c++_Item_7_在多态基类中将析构函数声明为虚析构函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/13/2017-02-13_19_01_读书笔记_effective_c++_Item_7_在多态基类中将析构函数声明为虚析构函数/" itemprop="url">读书笔记 effective c++ Item 7 在多态基类中将析构函数声明为虚析构函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-13T19:01:00+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/13/2017-02-13_19_01_读书笔记_effective_c++_Item_7_在多态基类中将析构函数声明为虚析构函数/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 7 在多态基类中将析构函数声明为虚析构函数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-继承体系中关于对象释放遇到的问题描述"><a href="#1-继承体系中关于对象释放遇到的问题描述" class="headerlink" title="1. 继承体系中关于对象释放遇到的问题描述"></a>1. 继承体系中关于对象释放遇到的问题描述</h2><h3 id="1-1-手动释放"><a href="#1-1-手动释放" class="headerlink" title="1.1 手动释放"></a>1.1 手动释放</h3><p>关于时间记录有很多种方法，因此为不同的计时方法创建一个TimeKeeper基类和一些派生类就再合理不过了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> class TimeKeepe</div><div class="line">&lt;!--more--&gt;</div><div class="line"> &#123;</div><div class="line"></div><div class="line"> public:</div><div class="line"></div><div class="line"> TimeKeeper();</div><div class="line"></div><div class="line"> ~TimeKeeper();</div><div class="line"></div><div class="line"> ...</div><div class="line"></div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> class AtomicClock: public TimeKeeper &#123; ... &#125;;</div><div class="line"></div><div class="line"> class WaterClock: public TimeKeeper &#123; ... &#125;;</div><div class="line"></div><div class="line"> class WristWatch: public TimeKeeper &#123; ... &#125;;</div><div class="line"></div></pre></td></tr></table></figure>
<p>许多客户端只想访问时间而不想知道关于时间计算的细节，所以可以创建一个工厂方法，这个工厂方法返回一个指向新创建的派生类对象的基类指针，这个指针用来指向一个计时对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TimeKeeper* getTimeKeeper(); <span class="comment">// returns a pointer to a dynamic-</span></div><div class="line"></div><div class="line">                                                         <span class="comment">// ally allocated object of a class</span></div><div class="line"></div><div class="line">                                                          <span class="comment">// derived from TimeKeeper</span></div></pre></td></tr></table></figure>
<p>为了和工厂方法的约定保持一致，getTimeKeeper返回一个堆上的对象，因此为了避免泄露内存和其他资源，每个返回的对象被合理的释放掉(deleted)是很重要的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TimeKeeper *ptk = getTimeKeeper(); <span class="comment">// get dynamically allocated object</span></div><div class="line"></div><div class="line"><span class="comment">// from TimeKeeper hierarchy</span></div><div class="line"></div><div class="line">... <span class="comment">// use it</span></div><div class="line"></div><div class="line">delete ptk; <span class="comment">// release it to avoid resource leak</span></div></pre></td></tr></table></figure>
<p>Item13中解释到依赖客户执行deletion比较容易出错，在Item18中解释了如何改变工厂函数的接口来预防一般的客户端错误，但是这些关注点在这里都是次要的，因为在这个条款中，我们为上面的代码提出一个更基本的弱点：即使客户端把一切都做对了，根本没有方法去知道程序如何运转。</p>
<h3 id="1-2非虚析构函数引入的问题"><a href="#1-2非虚析构函数引入的问题" class="headerlink" title="1.2非虚析构函数引入的问题"></a>1.2非虚析构函数引入的问题</h3><p>问题在于getTimeKeeper返回一个指向派生类对象的指针(AtomicClock),这个对象通过一个基类指针(一个TimeKeeper<em>指针)来进行释放（delete），基类中(TimeKeeper)有一个非虚析构函数。这是造成灾难的一个因素，因为c++指出：<em>*通过一个基类的指针来释放一个派生类的对象，如果基类的析构函数是非虚的，那么结果未定义</em></em>。在运行时有可能发生以下状况：对象的派生类部分永远不会被释放掉。如果对getTimeKeeper的调用恰巧返回一个指向AtomicClock对象的指针，对象的AtomicClock部分（也就是在AtomicClock类中声明的数据成员）可能不会被释放掉，AtomicClock类的析构函数也不会被执行。然而，基类部分（也就是TimeKeeper部分）是会被释放掉的，这会导致产生一个古怪的“部分被释放的”对象。这是使资源泄露，破坏数据结构和在debugger上花费大把时间的绝佳方法。</p>
<h2 id="2-如何解决问题-声明虚析构函数"><a href="#2-如何解决问题-声明虚析构函数" class="headerlink" title="2.如何解决问题-声明虚析构函数"></a>2.如何解决问题-声明虚析构函数</h2><p><strong>消除这个问题很简单：为基类提供一个虚析构函数</strong>。这时如果delete一个派生类对象将会做到你想要的。它会释放掉整个对象，包括派生类的所有部分：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">TimeKeeper();</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> ~TimeKeeper();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">TimeKeeper *ptk = getTimeKeeper();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">delete ptk; <span class="comment">// now behaves correctly</span></div></pre></td></tr></table></figure>
<p>基类中(TimeKeeper)除了析构函数外一般情况下会包含虚函数，<strong>因为虚函数存在的目的是为了函数在派生类中的定制化实现（**</strong>Item34<strong>**）</strong>。举个例子，TimeKeeper会有一个虚函数，getCurrentTime,这个函数在不同的派生类中会有不同的实现。<strong>任何有虚函数的类应该肯定有一个虚析构函数。</strong></p>
<hr>
<h2 id="3-不要在不当作基类的类中声明虚析构函数"><a href="#3-不要在不当作基类的类中声明虚析构函数" class="headerlink" title="3.不要在不当作基类的类中声明虚析构函数"></a>3.不要在不当作基类的类中声明虚析构函数</h2><hr>
<p><strong>如果类中不包含虚函数，这通常表明它不会被用作基类，如果并没有打算将一个类作为一个基类，将析构函数声明为虚是一个坏的想法。</strong>考虑一个表示二维空间的点的类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Point</span> &#123; <span class="comment">// a 2D point</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">Point(<span class="keyword">int</span> xCoord, <span class="keyword">int</span> yCoord);</div><div class="line"></div><div class="line">~Point();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line"><span class="keyword">int</span> x, y;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果int占用32Bits,那么一个Point对象可被放入一个64-bit的缓存器中。并且，这个Point对象可以以一个”64-bit quantity”传给用其他语言编写的函数，例如c语言和Fortran。如果将Point的析构函数声明成虚的，状况就会发生变化。</p>
<p>虚函数的实现需要对象带一些信息，根据这些信息在运行时能够决定对象的哪个虚函数会被触发。这些信息表现为一个被叫做vptr(virtual table pointer)指针的形式。我们把指向一个函数指针数组的vptr指针叫做vtbl(virtual table)；每个有虚函数的类都有一个关联的vtbl.当虚函数在一个对象上被触发，实际调用的函数是由对象的vtbl中的vptr来决定的，在vtbl中会查找到合适的函数指针。</p>
<p>关于虚函数是如何实现的细节并不重要。重要的是如果Point类中包含一个虚函数，这个类型的对象会在占用空间上有所增加：在32位机器中，空间会从64bits(两个int)增加到96bits；在64位机器中，空间会从64bits增加到128bits,因为64位机器上的指针在空间上占用64bits.Point额外增加了一个vptr而致使内存空间增加50-100%。Point将不能在放进64bits的缓存中。并且，c++中的Point也不再同其他语言(如C语言)中声明的对象有类似的结构了，因为其他语言没有vptr,因此你不再能够向(从)其他语言编写的函数中传进(传出)指针了,除非你对vptr进行明确的补偿，这属于实现细节，代码因此也不能够被移植了。</p>
<p>因此，无缘无故的将所有析构函数声明成虚函数同永远不将其声明为虚函数犯了一样的错误。事实上，许多人将上面的情形其总结如下：<strong>在类中声明虚析构函数当且仅当类中至少包含一个虚函数。</strong></p>
<h2 id="4-不要继承析构函数为非虚的类"><a href="#4-不要继承析构函数为非虚的类" class="headerlink" title="4.不要继承析构函数为非虚的类"></a>4.不要继承析构函数为非虚的类</h2><p>在虚函数完全缺席的情况下，非虚析构函数的问题同样会导致只释放部分内存的问题。举个例子，标准string类型不包含虚函数，但是一些被误导的程序员有时会将其当作基类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">SpecialString</span>: <span class="title">public</span> <span class="title">std</span>::<span class="title">string</span> &#123; <span class="comment">// bad idea! std::string has a</span></div><div class="line"></div><div class="line">... <span class="comment">// non-virtual destructor</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>乍一看这么实现也许无伤大雅，但是如果在一个应用中的某个地方，你以某种方式将指向SpecialString的指针转换成指向string的指针，然后你在string指针上使用delete，你马上会被转到未定义行为的领地：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">SpecialString *pss =new SpecialString("Impending Doom");</div><div class="line"></div><div class="line">std::string *ps;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">ps = pss; // SpecialString* ⇒ std::string*</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">delete ps; // undefined! In practice,</div><div class="line"></div><div class="line">// *ps’s SpecialString resources</div><div class="line"></div><div class="line">// will be leaked, because the</div><div class="line"></div><div class="line">// SpecialString destructor won’t</div><div class="line"></div><div class="line">// be called</div></pre></td></tr></table></figure>
<p>同样的分析适用于任何缺少虚析构函数的类，包含所有的STL容器类型（例如 vector,list set,tr1::unordered_map(Item54)）。如果你曾经受到诱惑，从一个标准容器类或其他没有虚析构函数的类中继承，你需要抵抗这种诱惑！（不幸的是，c++没有提供不能继承的机制，java中有final类，c#中有sealed类）。</p>
<h2 id="5-纯虚析构函数"><a href="#5-纯虚析构函数" class="headerlink" title="5.纯虚析构函数"></a>5.纯虚析构函数</h2><p>偶尔情况下为类提供一个纯虚析构函数是很方便的。有纯虚函数的类是一个抽象类，其不能够被实例化。然而有时候，你想将一个类变成一个抽象类，但是没有任何纯虚函数。该怎么办？因为一个抽象类将来会被用作基类，并且基类应该有一个虚析构函数，同时一个纯虚函数产生一个抽象类，所以解决方案很简单：<strong>在你想要其变成抽象的类中声明一个纯虚析构函数</strong>。看下面的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">AWOV</span> &#123; <span class="comment">// AWOV = “Abstract w/o Virtuals”</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>; <span class="comment">// declare pure virtual destructor</span></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个类有一个纯虚函数，所以它是抽象类。因为它有一个虚析构函数，所以你不必担心因为析构函数出现的问题。这里有个窍门，<strong>你必须为纯虚函数提供一份定义</strong>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AWOV::~AWOV() &#123;&#125; // definition of pure virtual dtor</div></pre></td></tr></table></figure>
<p>析构函数工作的方法是最底部的派生类先被调用，然后析构函数的每一个基类会被依次调用。编译器会从派生类的析构函数中生成一个对~AWOV的调用，因此你必须确保为这个函数提供一个函数体。如果不提供会有链接错误。</p>
<h2 id="6-其他一些需要注意的地方"><a href="#6-其他一些需要注意的地方" class="headerlink" title="6.其他一些需要注意的地方"></a>6.其他一些需要注意的地方</h2><p> <strong>为基类提供虚析构函数的法则只适用于多态基类</strong>，多态基类也就是将基类设计成允许通过基类接口来操作派生类型的类。TImeKeeper是一个多态基类，因为我们想能够操作AtomicClokc和WaterClock对象，在即使只有TimeKeeper指针指向这些派生类对象的情况下。</p>
<p><strong>并不是所有的基类都被设计成能够使用多态</strong>。举个例子，标准string类型还有STL容器类型并没有被设计成基类，更不用说多态了。<strong>一些类被设计成当基类使用，但是没有被设计成使用多态</strong>。举个例子，Item6中的UnCopyable和来自标准库中的input_iterator_tag（Item47）,这样的类没有被设计成通过基类接口操作派生类。因此，也不需要虚析构函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/2017-02-13_09_03_读书笔记_effective_c++_Item_6_如果你不想使用编译器自动生成的函数，你需要明确拒绝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/13/2017-02-13_09_03_读书笔记_effective_c++_Item_6_如果你不想使用编译器自动生成的函数，你需要明确拒绝/" itemprop="url">读书笔记 effective c++ Item 6 如果你不想使用编译器自动生成的函数，你需要明确拒绝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-13T09:03:00+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/13/2017-02-13_09_03_读书笔记_effective_c++_Item_6_如果你不想使用编译器自动生成的函数，你需要明确拒绝/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 6 如果你不想使用编译器自动生成的函数，你需要明确拒绝">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="问题描述-阻止对象的拷贝"><a href="#问题描述-阻止对象的拷贝" class="headerlink" title="问题描述-阻止对象的拷贝"></a>问题描述-阻止对象的拷贝</h2><p>现实生活中的房产中介卖房子，一个服务于这个中介的软件系统很自然的会有一个表示要被销售的房屋的类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">HomeForSale</span> &#123; ... &#125;;</div></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/13/2017-02-13_09_03_读书笔记_effective_c++_Item_6_如果你不想使用编译器自动生成的函数，你需要明确拒绝/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/12/2017-02-12_12_25_读书笔记_effective_c++_Item_5_了解c++默认生成并调用的函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Harlan Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://files.cnblogs.com/files/harlanc/elempent.bmp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HarlanC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/12/2017-02-12_12_25_读书笔记_effective_c++_Item_5_了解c++默认生成并调用的函数/" itemprop="url">读书笔记 effective c++ Item 5 了解c++默认生成并调用的函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-12T12:25:00+08:00">
                2017-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-c/" itemprop="url" rel="index">
                    <span itemprop="name">Effective c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/12/2017-02-12_12_25_读书笔记_effective_c++_Item_5_了解c++默认生成并调用的函数/" class="leancloud_visitors" data-flag-title="读书笔记 effective c++ Item 5 了解c++默认生成并调用的函数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="1-编译器会默认生成哪些函数"><a href="#1-编译器会默认生成哪些函数" class="headerlink" title="1 编译器会默认生成哪些函数 "></a>1 编译器会默认生成哪些函数<strong><em> </em></strong></h2><p>什么时候空类不再是一个空类？答案是用c++处理的空类。如果你自己不声明，编译器会为你声明它们自己版本的<strong>拷贝构造函数</strong>，<strong>拷贝赋值运算符和析构函数，</strong>如果你一个构造函数都没有声明，编译器同样会为你声明一个<strong>默认拷贝构造函数</strong>。这些<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/12/2017-02-12_12_25_读书笔记_effective_c++_Item_5_了解c++默认生成并调用的函数/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://files.cnblogs.com/files/harlanc/elempent.bmp"
               alt="Harlan Chen" />
          <p class="site-author-name" itemprop="name">Harlan Chen</p>
           
              <p class="site-description motion-element" itemprop="description">生有涯，知无涯。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">83</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.cnblogs.com/harlanc/" target="_blank" title="博客园">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  博客园
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Harlan Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "8b8d5c70c3a142db9f01c789f95c52b1",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("srG9VazdFVB0NGqAhm2HyMMr-gzGzoHsz", "oEMz0cnj9eimqiBJ3v0os0hF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
